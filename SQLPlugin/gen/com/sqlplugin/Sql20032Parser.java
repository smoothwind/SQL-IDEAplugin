// This is a generated file. Not intended for manual editing.
package com.sqlplugin;

import com.intellij.lang.PsiBuilder;
import com.intellij.lang.PsiBuilder.Marker;
import static com.sqlplugin.psi.SqlTypes.*;
import static com.sqlplugin.SqlParserUtil.*;
import com.intellij.psi.tree.IElementType;
import com.intellij.lang.ASTNode;
import com.intellij.psi.tree.TokenSet;
import com.intellij.lang.PsiParser;
import com.intellij.lang.LightPsiParser;

@SuppressWarnings({"SimplifiableIfStatement", "UnusedAssignment"})
public class Sql20032Parser implements PsiParser, LightPsiParser {

  public ASTNode parse(IElementType t, PsiBuilder b) {
    parseLight(t, b);
    return b.getTreeBuilt();
  }

  public void parseLight(IElementType t, PsiBuilder b) {
    boolean r;
    b = adapt_builder_(t, b, this, null);
    Marker m = enter_section_(b, 0, _COLLAPSE_, null);
    if (t == ADA_BLOB_LOCATOR_VARIABLE) {
      r = Ada_BLOB_locator_variable(b, 0);
    }
    else if (t == ADA_BLOB_VARIABLE) {
      r = Ada_BLOB_variable(b, 0);
    }
    else if (t == ADA_CLOB_LOCATOR_VARIABLE) {
      r = Ada_CLOB_locator_variable(b, 0);
    }
    else if (t == ADA_CLOB_VARIABLE) {
      r = Ada_CLOB_variable(b, 0);
    }
    else if (t == ADA_REF_VARIABLE) {
      r = Ada_REF_variable(b, 0);
    }
    else if (t == ADA_ARRAY_LOCATOR_VARIABLE) {
      r = Ada_array_locator_variable(b, 0);
    }
    else if (t == ADA_ASSIGNMENT_OPERATOR) {
      r = Ada_assignment_operator(b, 0);
    }
    else if (t == ADA_DERIVED_TYPE_SPECIFICATION) {
      r = Ada_derived_type_specification(b, 0);
    }
    else if (t == ADA_HOST_IDENTIFIER) {
      r = Ada_host_identifier(b, 0);
    }
    else if (t == ADA_INITIAL_VALUE) {
      r = Ada_initial_value(b, 0);
    }
    else if (t == ADA_MULTISET_LOCATOR_VARIABLE) {
      r = Ada_multiset_locator_variable(b, 0);
    }
    else if (t == ADA_QUALIFIED_TYPE_SPECIFICATION) {
      r = Ada_qualified_type_specification(b, 0);
    }
    else if (t == ADA_TYPE_SPECIFICATION) {
      r = Ada_type_specification(b, 0);
    }
    else if (t == ADA_UNQUALIFIED_TYPE_SPECIFICATION) {
      r = Ada_unqualified_type_specification(b, 0);
    }
    else if (t == ADA_USER_DEFINED_TYPE_LOCATOR_VARIABLE) {
      r = Ada_user_defined_type_locator_variable(b, 0);
    }
    else if (t == ADA_USER_DEFINED_TYPE_VARIABLE) {
      r = Ada_user_defined_type_variable(b, 0);
    }
    else if (t == ADA_VARIABLE_DEFINITION) {
      r = Ada_variable_definition(b, 0);
    }
    else if (t == C_BLOB_LOCATOR_VARIABLE) {
      r = C_BLOB_locator_variable(b, 0);
    }
    else if (t == C_BLOB_VARIABLE) {
      r = C_BLOB_variable(b, 0);
    }
    else if (t == C_CLOB_LOCATOR_VARIABLE) {
      r = C_CLOB_locator_variable(b, 0);
    }
    else if (t == C_CLOB_VARIABLE) {
      r = C_CLOB_variable(b, 0);
    }
    else if (t == C_NCHAR_VARYING_VARIABLE) {
      r = C_NCHAR_VARYING_variable(b, 0);
    }
    else if (t == C_NCHAR_VARIABLE) {
      r = C_NCHAR_variable(b, 0);
    }
    else if (t == C_NCLOB_VARIABLE) {
      r = C_NCLOB_variable(b, 0);
    }
    else if (t == C_REF_VARIABLE) {
      r = C_REF_variable(b, 0);
    }
    else if (t == C_VARCHAR_VARIABLE) {
      r = C_VARCHAR_variable(b, 0);
    }
    else if (t == C_ARRAY_LOCATOR_VARIABLE) {
      r = C_array_locator_variable(b, 0);
    }
    else if (t == C_ARRAY_SPECIFICATION) {
      r = C_array_specification(b, 0);
    }
    else if (t == C_CHARACTER_TYPE) {
      r = C_character_type(b, 0);
    }
    else if (t == C_CHARACTER_VARIABLE) {
      r = C_character_variable(b, 0);
    }
    else if (t == C_CLASS_MODIFIER) {
      r = C_class_modifier(b, 0);
    }
    else if (t == C_DERIVED_VARIABLE) {
      r = C_derived_variable(b, 0);
    }
    else if (t == C_HOST_IDENTIFIER) {
      r = C_host_identifier(b, 0);
    }
    else if (t == C_INITIAL_VALUE) {
      r = C_initial_value(b, 0);
    }
    else if (t == C_MULTISET_LOCATOR_VARIABLE) {
      r = C_multiset_locator_variable(b, 0);
    }
    else if (t == C_NUMERIC_VARIABLE) {
      r = C_numeric_variable(b, 0);
    }
    else if (t == C_STORAGE_CLASS) {
      r = C_storage_class(b, 0);
    }
    else if (t == C_USER_DEFINED_TYPE_LOCATOR_VARIABLE) {
      r = C_user_defined_type_locator_variable(b, 0);
    }
    else if (t == C_USER_DEFINED_TYPE_VARIABLE) {
      r = C_user_defined_type_variable(b, 0);
    }
    else if (t == C_VARIABLE_DEFINITION) {
      r = C_variable_definition(b, 0);
    }
    else if (t == C_VARIABLE_SPECIFICATION) {
      r = C_variable_specification(b, 0);
    }
    else if (t == COBOL_BLOB_LOCATOR_VARIABLE) {
      r = COBOL_BLOB_locator_variable(b, 0);
    }
    else if (t == COBOL_BLOB_VARIABLE) {
      r = COBOL_BLOB_variable(b, 0);
    }
    else if (t == COBOL_CLOB_LOCATOR_VARIABLE) {
      r = COBOL_CLOB_locator_variable(b, 0);
    }
    else if (t == COBOL_CLOB_VARIABLE) {
      r = COBOL_CLOB_variable(b, 0);
    }
    else if (t == COBOL_NCLOB_VARIABLE) {
      r = COBOL_NCLOB_variable(b, 0);
    }
    else if (t == COBOL_REF_VARIABLE) {
      r = COBOL_REF_variable(b, 0);
    }
    else if (t == COBOL_ARRAY_LOCATOR_VARIABLE) {
      r = COBOL_array_locator_variable(b, 0);
    }
    else if (t == COBOL_BINARY_INTEGER) {
      r = COBOL_binary_integer(b, 0);
    }
    else if (t == COBOL_CHARACTER_TYPE) {
      r = COBOL_character_type(b, 0);
    }
    else if (t == COBOL_DERIVED_TYPE_SPECIFICATION) {
      r = COBOL_derived_type_specification(b, 0);
    }
    else if (t == COBOL_HOST_IDENTIFIER) {
      r = COBOL_host_identifier(b, 0);
    }
    else if (t == COBOL_INTEGER_TYPE) {
      r = COBOL_integer_type(b, 0);
    }
    else if (t == COBOL_MULTISET_LOCATOR_VARIABLE) {
      r = COBOL_multiset_locator_variable(b, 0);
    }
    else if (t == COBOL_NATIONAL_CHARACTER_TYPE) {
      r = COBOL_national_character_type(b, 0);
    }
    else if (t == COBOL_NINES) {
      r = COBOL_nines(b, 0);
    }
    else if (t == COBOL_NINES_SPECIFICATION) {
      r = COBOL_nines_specification(b, 0);
    }
    else if (t == COBOL_NUMERIC_TYPE) {
      r = COBOL_numeric_type(b, 0);
    }
    else if (t == COBOL_TYPE_SPECIFICATION) {
      r = COBOL_type_specification(b, 0);
    }
    else if (t == COBOL_USER_DEFINED_TYPE_LOCATOR_VARIABLE) {
      r = COBOL_user_defined_type_locator_variable(b, 0);
    }
    else if (t == COBOL_USER_DEFINED_TYPE_VARIABLE) {
      r = COBOL_user_defined_type_variable(b, 0);
    }
    else if (t == COBOL_VARIABLE_DEFINITION) {
      r = COBOL_variable_definition(b, 0);
    }
    else if (t == FORTRAN_BLOB_LOCATOR_VARIABLE) {
      r = Fortran_BLOB_locator_variable(b, 0);
    }
    else if (t == FORTRAN_BLOB_VARIABLE) {
      r = Fortran_BLOB_variable(b, 0);
    }
    else if (t == FORTRAN_CLOB_LOCATOR_VARIABLE) {
      r = Fortran_CLOB_locator_variable(b, 0);
    }
    else if (t == FORTRAN_CLOB_VARIABLE) {
      r = Fortran_CLOB_variable(b, 0);
    }
    else if (t == FORTRAN_REF_VARIABLE) {
      r = Fortran_REF_variable(b, 0);
    }
    else if (t == FORTRAN_ARRAY_LOCATOR_VARIABLE) {
      r = Fortran_array_locator_variable(b, 0);
    }
    else if (t == FORTRAN_DERIVED_TYPE_SPECIFICATION) {
      r = Fortran_derived_type_specification(b, 0);
    }
    else if (t == FORTRAN_HOST_IDENTIFIER) {
      r = Fortran_host_identifier(b, 0);
    }
    else if (t == FORTRAN_MULTISET_LOCATOR_VARIABLE) {
      r = Fortran_multiset_locator_variable(b, 0);
    }
    else if (t == FORTRAN_TYPE_SPECIFICATION) {
      r = Fortran_type_specification(b, 0);
    }
    else if (t == FORTRAN_USER_DEFINED_TYPE_LOCATOR_VARIABLE) {
      r = Fortran_user_defined_type_locator_variable(b, 0);
    }
    else if (t == FORTRAN_USER_DEFINED_TYPE_VARIABLE) {
      r = Fortran_user_defined_type_variable(b, 0);
    }
    else if (t == FORTRAN_VARIABLE_DEFINITION) {
      r = Fortran_variable_definition(b, 0);
    }
    else if (t == MUMPS_BLOB_LOCATOR_VARIABLE) {
      r = MUMPS_BLOB_locator_variable(b, 0);
    }
    else if (t == MUMPS_BLOB_VARIABLE) {
      r = MUMPS_BLOB_variable(b, 0);
    }
    else if (t == MUMPS_CLOB_LOCATOR_VARIABLE) {
      r = MUMPS_CLOB_locator_variable(b, 0);
    }
    else if (t == MUMPS_CLOB_VARIABLE) {
      r = MUMPS_CLOB_variable(b, 0);
    }
    else if (t == MUMPS_REF_VARIABLE) {
      r = MUMPS_REF_variable(b, 0);
    }
    else if (t == MUMPS_ARRAY_LOCATOR_VARIABLE) {
      r = MUMPS_array_locator_variable(b, 0);
    }
    else if (t == MUMPS_CHARACTER_VARIABLE) {
      r = MUMPS_character_variable(b, 0);
    }
    else if (t == MUMPS_DERIVED_TYPE_SPECIFICATION) {
      r = MUMPS_derived_type_specification(b, 0);
    }
    else if (t == MUMPS_HOST_IDENTIFIER) {
      r = MUMPS_host_identifier(b, 0);
    }
    else if (t == MUMPS_LENGTH_SPECIFICATION) {
      r = MUMPS_length_specification(b, 0);
    }
    else if (t == MUMPS_MULTISET_LOCATOR_VARIABLE) {
      r = MUMPS_multiset_locator_variable(b, 0);
    }
    else if (t == MUMPS_NUMERIC_VARIABLE) {
      r = MUMPS_numeric_variable(b, 0);
    }
    else if (t == MUMPS_TYPE_SPECIFICATION) {
      r = MUMPS_type_specification(b, 0);
    }
    else if (t == MUMPS_USER_DEFINED_TYPE_LOCATOR_VARIABLE) {
      r = MUMPS_user_defined_type_locator_variable(b, 0);
    }
    else if (t == MUMPS_USER_DEFINED_TYPE_VARIABLE) {
      r = MUMPS_user_defined_type_variable(b, 0);
    }
    else if (t == MUMPS_VARIABLE_DEFINITION) {
      r = MUMPS_variable_definition(b, 0);
    }
    else if (t == PL_I_BLOB_LOCATOR_VARIABLE) {
      r = PL_I_BLOB_locator_variable(b, 0);
    }
    else if (t == PL_I_BLOB_VARIABLE) {
      r = PL_I_BLOB_variable(b, 0);
    }
    else if (t == PL_I_CLOB_LOCATOR_VARIABLE) {
      r = PL_I_CLOB_locator_variable(b, 0);
    }
    else if (t == PL_I_CLOB_VARIABLE) {
      r = PL_I_CLOB_variable(b, 0);
    }
    else if (t == PL_I_REF_VARIABLE) {
      r = PL_I_REF_variable(b, 0);
    }
    else if (t == PL_I_ARRAY_LOCATOR_VARIABLE) {
      r = PL_I_array_locator_variable(b, 0);
    }
    else if (t == PL_I_DERIVED_TYPE_SPECIFICATION) {
      r = PL_I_derived_type_specification(b, 0);
    }
    else if (t == PL_I_HOST_IDENTIFIER) {
      r = PL_I_host_identifier(b, 0);
    }
    else if (t == PL_I_MULTISET_LOCATOR_VARIABLE) {
      r = PL_I_multiset_locator_variable(b, 0);
    }
    else if (t == PL_I_TYPE_FIXED_BINARY) {
      r = PL_I_type_fixed_binary(b, 0);
    }
    else if (t == PL_I_TYPE_FIXED_DECIMAL) {
      r = PL_I_type_fixed_decimal(b, 0);
    }
    else if (t == PL_I_TYPE_FLOAT_BINARY) {
      r = PL_I_type_float_binary(b, 0);
    }
    else if (t == PL_I_TYPE_SPECIFICATION) {
      r = PL_I_type_specification(b, 0);
    }
    else if (t == PL_I_USER_DEFINED_TYPE_LOCATOR_VARIABLE) {
      r = PL_I_user_defined_type_locator_variable(b, 0);
    }
    else if (t == PL_I_USER_DEFINED_TYPE_VARIABLE) {
      r = PL_I_user_defined_type_variable(b, 0);
    }
    else if (t == PL_I_VARIABLE_DEFINITION) {
      r = PL_I_variable_definition(b, 0);
    }
    else if (t == PASCAL_BLOB_LOCATOR_VARIABLE) {
      r = Pascal_BLOB_locator_variable(b, 0);
    }
    else if (t == PASCAL_BLOB_VARIABLE) {
      r = Pascal_BLOB_variable(b, 0);
    }
    else if (t == PASCAL_CLOB_LOCATOR_VARIABLE) {
      r = Pascal_CLOB_locator_variable(b, 0);
    }
    else if (t == PASCAL_CLOB_VARIABLE) {
      r = Pascal_CLOB_variable(b, 0);
    }
    else if (t == PASCAL_REF_VARIABLE) {
      r = Pascal_REF_variable(b, 0);
    }
    else if (t == PASCAL_ARRAY_LOCATOR_VARIABLE) {
      r = Pascal_array_locator_variable(b, 0);
    }
    else if (t == PASCAL_DERIVED_TYPE_SPECIFICATION) {
      r = Pascal_derived_type_specification(b, 0);
    }
    else if (t == PASCAL_HOST_IDENTIFIER) {
      r = Pascal_host_identifier(b, 0);
    }
    else if (t == PASCAL_MULTISET_LOCATOR_VARIABLE) {
      r = Pascal_multiset_locator_variable(b, 0);
    }
    else if (t == PASCAL_TYPE_SPECIFICATION) {
      r = Pascal_type_specification(b, 0);
    }
    else if (t == PASCAL_USER_DEFINED_TYPE_LOCATOR_VARIABLE) {
      r = Pascal_user_defined_type_locator_variable(b, 0);
    }
    else if (t == PASCAL_USER_DEFINED_TYPE_VARIABLE) {
      r = Pascal_user_defined_type_variable(b, 0);
    }
    else if (t == PASCAL_VARIABLE_DEFINITION) {
      r = Pascal_variable_definition(b, 0);
    }
    else if (t == SQL_ARGUMENT) {
      r = SQL_argument(b, 0);
    }
    else if (t == SQL_ARGUMENT_LIST) {
      r = SQL_argument_list(b, 0);
    }
    else if (t == SQL_CONDITION) {
      r = SQL_condition(b, 0);
    }
    else if (t == SQL_CONNECTION_STATEMENT) {
      r = SQL_connection_statement(b, 0);
    }
    else if (t == SQL_CONTROL_STATEMENT) {
      r = SQL_control_statement(b, 0);
    }
    else if (t == SQL_DATA_CHANGE_STATEMENT) {
      r = SQL_data_change_statement(b, 0);
    }
    else if (t == SQL_DATA_STATEMENT) {
      r = SQL_data_statement(b, 0);
    }
    else if (t == SQL_DIAGNOSTICS_INFORMATION) {
      r = SQL_diagnostics_information(b, 0);
    }
    else if (t == SQL_DIAGNOSTICS_STATEMENT) {
      r = SQL_diagnostics_statement(b, 0);
    }
    else if (t == SQL_DYNAMIC_DATA_STATEMENT) {
      r = SQL_dynamic_data_statement(b, 0);
    }
    else if (t == SQL_DYNAMIC_STATEMENT) {
      r = SQL_dynamic_statement(b, 0);
    }
    else if (t == SQL_EXECUTABLE_STATEMENT) {
      r = SQL_executable_statement(b, 0);
    }
    else if (t == SQL_LANGUAGE_CHARACTER) {
      r = SQL_language_character(b, 0);
    }
    else if (t == SQL_LANGUAGE_IDENTIFIER) {
      r = SQL_language_identifier(b, 0);
    }
    else if (t == SQL_LANGUAGE_IDENTIFIER_PART) {
      r = SQL_language_identifier_part(b, 0);
    }
    else if (t == SQL_LANGUAGE_IDENTIFIER_START) {
      r = SQL_language_identifier_start(b, 0);
    }
    else if (t == SQL_PARAMETER_DECLARATION) {
      r = SQL_parameter_declaration(b, 0);
    }
    else if (t == SQL_PARAMETER_DECLARATION_LIST) {
      r = SQL_parameter_declaration_list(b, 0);
    }
    else if (t == SQL_PARAMETER_NAME) {
      r = SQL_parameter_name(b, 0);
    }
    else if (t == SQL_PARAMETER_REFERENCE) {
      r = SQL_parameter_reference(b, 0);
    }
    else if (t == SQL_PREFIX) {
      r = SQL_prefix(b, 0);
    }
    else if (t == SQL_PROCEDURE_STATEMENT) {
      r = SQL_procedure_statement(b, 0);
    }
    else if (t == SQL_ROUTINE_BODY) {
      r = SQL_routine_body(b, 0);
    }
    else if (t == SQL_ROUTINE_SPEC) {
      r = SQL_routine_spec(b, 0);
    }
    else if (t == SQL_SCHEMA_DEFINITION_STATEMENT) {
      r = SQL_schema_definition_statement(b, 0);
    }
    else if (t == SQL_SCHEMA_MANIPULATION_STATEMENT) {
      r = SQL_schema_manipulation_statement(b, 0);
    }
    else if (t == SQL_SCHEMA_STATEMENT) {
      r = SQL_schema_statement(b, 0);
    }
    else if (t == SQL_SESSION_STATEMENT) {
      r = SQL_session_statement(b, 0);
    }
    else if (t == SQL_SPECIAL_CHARACTER) {
      r = SQL_special_character(b, 0);
    }
    else if (t == SQL_STATEMENT_NAME) {
      r = SQL_statement_name(b, 0);
    }
    else if (t == SQL_STATEMENT_VARIABLE) {
      r = SQL_statement_variable(b, 0);
    }
    else if (t == SQL_TERMINATOR) {
      r = SQL_terminator(b, 0);
    }
    else if (t == SQL_TRANSACTION_STATEMENT) {
      r = SQL_transaction_statement(b, 0);
    }
    else if (t == SQL_CLIENT_MODULE_DEFINITION) {
      r = SQL_client_module_definition(b, 0);
    }
    else if (t == SQL_CLIENT_MODULE_NAME) {
      r = SQL_client_module_name(b, 0);
    }
    else if (t == SQL_DATA_ACCESS_INDICATION) {
      r = SQL_data_access_indication(b, 0);
    }
    else if (t == SQL_INVOKED_FUNCTION) {
      r = SQL_invoked_function(b, 0);
    }
    else if (t == SQL_INVOKED_PROCEDURE) {
      r = SQL_invoked_procedure(b, 0);
    }
    else if (t == SQL_INVOKED_ROUTINE) {
      r = SQL_invoked_routine(b, 0);
    }
    else if (t == SQL_PATH_CHARACTERISTIC) {
      r = SQL_path_characteristic(b, 0);
    }
    else if (t == SQL_SERVER_NAME) {
      r = SQL_server_name(b, 0);
    }
    else if (t == SQLSTATE_CHAR) {
      r = SQLSTATE_char(b, 0);
    }
    else if (t == SQLSTATE_CLASS_VALUE) {
      r = SQLSTATE_class_value(b, 0);
    }
    else if (t == SQLSTATE_SUBCLASS_VALUE) {
      r = SQLSTATE_subclass_value(b, 0);
    }
    else if (t == UNICODE_4_DIGIT_ESCAPE_VALUE) {
      r = Unicode_4_digit_escape_value(b, 0);
    }
    else if (t == UNICODE_CHARACTER_ESCAPE_VALUE) {
      r = Unicode_character_escape_value(b, 0);
    }
    else if (t == UNICODE_CHARACTER_STRING_LITERAL) {
      r = Unicode_character_string_literal(b, 0);
    }
    else if (t == UNICODE_DELIMITER_BODY) {
      r = Unicode_delimiter_body(b, 0);
    }
    else if (t == UNICODE_ESCAPE_SPECIFIER) {
      r = Unicode_escape_specifier(b, 0);
    }
    else if (t == UNICODE_ESCAPE_VALUE) {
      r = Unicode_escape_value(b, 0);
    }
    else if (t == UNICODE_IDENTIFIER_PART) {
      r = Unicode_identifier_part(b, 0);
    }
    else if (t == UNICODE_REPRESENTATION) {
      r = Unicode_representation(b, 0);
    }
    else if (t == ABSOLUTE_VALUE_EXPRESSION) {
      r = absolute_value_expression(b, 0);
    }
    else if (t == ACTION) {
      r = action(b, 0);
    }
    else if (t == ACTUAL_IDENTIFIER) {
      r = actual_identifier(b, 0);
    }
    else if (t == ADD_ATTRIBUTE_DEFINITION) {
      r = add_attribute_definition(b, 0);
    }
    else if (t == ADD_COLUMN_DEFINITION) {
      r = add_column_definition(b, 0);
    }
    else if (t == ADD_COLUMN_SCOPE_CLAUSE) {
      r = add_column_scope_clause(b, 0);
    }
    else if (t == ADD_DOMAIN_CONSTRAINT_DEFINITION) {
      r = add_domain_constraint_definition(b, 0);
    }
    else if (t == ADD_ORIGINAL_METHOD_SPECIFICATION) {
      r = add_original_method_specification(b, 0);
    }
    else if (t == ADD_OVERRIDING_METHOD_SPECIFICATION) {
      r = add_overriding_method_specification(b, 0);
    }
    else if (t == ADD_TABLE_CONSTRAINT_DEFINITION) {
      r = add_table_constraint_definition(b, 0);
    }
    else if (t == ADD_TRANSFORM_ELEMENT_LIST) {
      r = add_transform_element_list(b, 0);
    }
    else if (t == AGGREGATE_FUNCTION) {
      r = aggregate_function(b, 0);
    }
    else if (t == ALL) {
      r = all(b, 0);
    }
    else if (t == ALL_FIELDS_COLUMN_NAME_LIST) {
      r = all_fields_column_name_list(b, 0);
    }
    else if (t == ALL_FIELDS_REFERENCE) {
      r = all_fields_reference(b, 0);
    }
    else if (t == ALLOCATE_CURSOR_STATEMENT) {
      r = allocate_cursor_statement(b, 0);
    }
    else if (t == ALLOCATE_DESCRIPTOR_STATEMENT) {
      r = allocate_descriptor_statement(b, 0);
    }
    else if (t == ALTER_COLUMN_ACTION) {
      r = alter_column_action(b, 0);
    }
    else if (t == ALTER_COLUMN_DEFINITION) {
      r = alter_column_definition(b, 0);
    }
    else if (t == ALTER_DOMAIN_ACTION) {
      r = alter_domain_action(b, 0);
    }
    else if (t == ALTER_DOMAIN_STATEMENT) {
      r = alter_domain_statement(b, 0);
    }
    else if (t == ALTER_GROUP) {
      r = alter_group(b, 0);
    }
    else if (t == ALTER_IDENTITY_COLUMN_OPTION) {
      r = alter_identity_column_option(b, 0);
    }
    else if (t == ALTER_IDENTITY_COLUMN_SPECIFICATION) {
      r = alter_identity_column_specification(b, 0);
    }
    else if (t == ALTER_ROUTINE_BEHAVIOR) {
      r = alter_routine_behavior(b, 0);
    }
    else if (t == ALTER_ROUTINE_CHARACTERISTIC) {
      r = alter_routine_characteristic(b, 0);
    }
    else if (t == ALTER_ROUTINE_CHARACTERISTICS) {
      r = alter_routine_characteristics(b, 0);
    }
    else if (t == ALTER_ROUTINE_STATEMENT) {
      r = alter_routine_statement(b, 0);
    }
    else if (t == ALTER_SEQUENCE_GENERATOR_OPTION) {
      r = alter_sequence_generator_option(b, 0);
    }
    else if (t == ALTER_SEQUENCE_GENERATOR_OPTIONS) {
      r = alter_sequence_generator_options(b, 0);
    }
    else if (t == ALTER_SEQUENCE_GENERATOR_RESTART_OPTION) {
      r = alter_sequence_generator_restart_option(b, 0);
    }
    else if (t == ALTER_SEQUENCE_GENERATOR_STATEMENT) {
      r = alter_sequence_generator_statement(b, 0);
    }
    else if (t == ALTER_TABLE_ACTION) {
      r = alter_table_action(b, 0);
    }
    else if (t == ALTER_TABLE_STATEMENT) {
      r = alter_table_statement(b, 0);
    }
    else if (t == ALTER_TRANSFORM_ACTION) {
      r = alter_transform_action(b, 0);
    }
    else if (t == ALTER_TRANSFORM_ACTION_LIST) {
      r = alter_transform_action_list(b, 0);
    }
    else if (t == ALTER_TRANSFORM_STATEMENT) {
      r = alter_transform_statement(b, 0);
    }
    else if (t == ALTER_TYPE_ACTION) {
      r = alter_type_action(b, 0);
    }
    else if (t == ALTER_TYPE_STATEMENT) {
      r = alter_type_statement(b, 0);
    }
    else if (t == AMPERSAND) {
      r = ampersand(b, 0);
    }
    else if (t == APPROXIMATE_NUMERIC_LITERAL) {
      r = approximate_numeric_literal(b, 0);
    }
    else if (t == APPROXIMATE_NUMERIC_TYPE) {
      r = approximate_numeric_type(b, 0);
    }
    else if (t == ARRAY_CONCATENATION) {
      r = array_concatenation(b, 0);
    }
    else if (t == ARRAY_ELEMENT) {
      r = array_element(b, 0);
    }
    else if (t == ARRAY_ELEMENT_LIST) {
      r = array_element_list(b, 0);
    }
    else if (t == ARRAY_ELEMENT_REFERENCE) {
      r = array_element_reference(b, 0);
    }
    else if (t == ARRAY_FACTOR) {
      r = array_factor(b, 0);
    }
    else if (t == ARRAY_TYPE) {
      r = array_type(b, 0);
    }
    else if (t == ARRAY_VALUE_CONSTRUCTOR) {
      r = array_value_constructor(b, 0);
    }
    else if (t == ARRAY_VALUE_CONSTRUCTOR_BY_ENUMERATION) {
      r = array_value_constructor_by_enumeration(b, 0);
    }
    else if (t == ARRAY_VALUE_CONSTRUCTOR_BY_QUERY) {
      r = array_value_constructor_by_query(b, 0);
    }
    else if (t == ARRAY_VALUE_EXPRESSION) {
      r = array_value_expression(b, 0);
    }
    else if (t == ARRAY_VALUE_EXPRESSION_1) {
      r = array_value_expression_1(b, 0);
    }
    else if (t == AS_CLAUSE) {
      r = as_clause(b, 0);
    }
    else if (t == AS_SUBQUERY_CLAUSE) {
      r = as_subquery_clause(b, 0);
    }
    else if (t == ASSERTION_DEFINITION) {
      r = assertion_definition(b, 0);
    }
    else if (t == ASSIGNED_ROW) {
      r = assigned_row(b, 0);
    }
    else if (t == ASTERISK) {
      r = asterisk(b, 0);
    }
    else if (t == ASTERISKED_IDENTIFIER) {
      r = asterisked_identifier(b, 0);
    }
    else if (t == ASTERISKED_IDENTIFIER_CHAIN) {
      r = asterisked_identifier_chain(b, 0);
    }
    else if (t == ATTRIBUTE_DEFAULT) {
      r = attribute_default(b, 0);
    }
    else if (t == ATTRIBUTE_DEFINITION) {
      r = attribute_definition(b, 0);
    }
    else if (t == ATTRIBUTE_NAME) {
      r = attribute_name(b, 0);
    }
    else if (t == ATTRIBUTE_OR_METHOD_REFERENCE) {
      r = attribute_or_method_reference(b, 0);
    }
    else if (t == ATTRIBUTES_SPECIFICATION) {
      r = attributes_specification(b, 0);
    }
    else if (t == ATTRIBUTES_VARIABLE) {
      r = attributes_variable(b, 0);
    }
    else if (t == AUTHORIZATION_IDENTIFIER) {
      r = authorization_identifier(b, 0);
    }
    else if (t == BASIC_IDENTIFIER_CHAIN) {
      r = basic_identifier_chain(b, 0);
    }
    else if (t == BASIC_SEQUENCE_GENERATOR_OPTION) {
      r = basic_sequence_generator_option(b, 0);
    }
    else if (t == BETWEEN_PREDICATE) {
      r = between_predicate(b, 0);
    }
    else if (t == BETWEEN_PREDICATE_PART_2) {
      r = between_predicate_part_2(b, 0);
    }
    else if (t == BINARY_LARGE_OBJECT_STRING_TYPE) {
      r = binary_large_object_string_type(b, 0);
    }
    else if (t == BINARY_SET_FUNCTION) {
      r = binary_set_function(b, 0);
    }
    else if (t == BINARY_SET_FUNCTION_TYPE) {
      r = binary_set_function_type(b, 0);
    }
    else if (t == BINARY_STRING_LITERAL) {
      r = binary_string_literal(b, 0);
    }
    else if (t == BLOB_CONCATENATION) {
      r = blob_concatenation(b, 0);
    }
    else if (t == BLOB_FACTOR) {
      r = blob_factor(b, 0);
    }
    else if (t == BLOB_OVERLAY_FUNCTION) {
      r = blob_overlay_function(b, 0);
    }
    else if (t == BLOB_POSITION_EXPRESSION) {
      r = blob_position_expression(b, 0);
    }
    else if (t == BLOB_PRIMARY) {
      r = blob_primary(b, 0);
    }
    else if (t == BLOB_SUBSTRING_FUNCTION) {
      r = blob_substring_function(b, 0);
    }
    else if (t == BLOB_TRIM_FUNCTION) {
      r = blob_trim_function(b, 0);
    }
    else if (t == BLOB_TRIM_OPERANDS) {
      r = blob_trim_operands(b, 0);
    }
    else if (t == BLOB_TRIM_SOURCE) {
      r = blob_trim_source(b, 0);
    }
    else if (t == BLOB_VALUE_EXPRESSION) {
      r = blob_value_expression(b, 0);
    }
    else if (t == BLOB_VALUE_FUNCTION) {
      r = blob_value_function(b, 0);
    }
    else if (t == BOOLEAN_FACTOR) {
      r = boolean_factor(b, 0);
    }
    else if (t == BOOLEAN_LITERAL) {
      r = boolean_literal(b, 0);
    }
    else if (t == BOOLEAN_PREDICAND) {
      r = boolean_predicand(b, 0);
    }
    else if (t == BOOLEAN_PRIMARY) {
      r = boolean_primary(b, 0);
    }
    else if (t == BOOLEAN_TERM) {
      r = boolean_term(b, 0);
    }
    else if (t == BOOLEAN_TEST) {
      r = boolean_test(b, 0);
    }
    else if (t == BOOLEAN_TYPE) {
      r = boolean_type(b, 0);
    }
    else if (t == BOOLEAN_VALUE_EXPRESSION) {
      r = boolean_value_expression(b, 0);
    }
    else if (t == BRACKETED_COMMENT) {
      r = bracketed_comment(b, 0);
    }
    else if (t == BRACKETED_COMMENT_CONTENTS) {
      r = bracketed_comment_contents(b, 0);
    }
    else if (t == BRACKETED_COMMENT_INTRODUCER) {
      r = bracketed_comment_introducer(b, 0);
    }
    else if (t == BRACKETED_COMMENT_TERMINATOR) {
      r = bracketed_comment_terminator(b, 0);
    }
    else if (t == CALL_STATEMENT) {
      r = call_statement(b, 0);
    }
    else if (t == CARDINALITY_EXPRESSION) {
      r = cardinality_expression(b, 0);
    }
    else if (t == CASE_ABBREVIATION) {
      r = case_abbreviation(b, 0);
    }
    else if (t == CASE_EXPRESSION) {
      r = case_expression(b, 0);
    }
    else if (t == CASE_OPERAND) {
      r = case_operand(b, 0);
    }
    else if (t == CASE_SPECIFICATION) {
      r = case_specification(b, 0);
    }
    else if (t == CAST_FUNCTION) {
      r = cast_function(b, 0);
    }
    else if (t == CAST_OPERAND) {
      r = cast_operand(b, 0);
    }
    else if (t == CAST_OPTION) {
      r = cast_option(b, 0);
    }
    else if (t == CAST_SPECIFICATION) {
      r = cast_specification(b, 0);
    }
    else if (t == CAST_TARGET) {
      r = cast_target(b, 0);
    }
    else if (t == CAST_TO_DISTINCT) {
      r = cast_to_distinct(b, 0);
    }
    else if (t == CAST_TO_DISTINCT_IDENTIFIER) {
      r = cast_to_distinct_identifier(b, 0);
    }
    else if (t == CAST_TO_REF) {
      r = cast_to_ref(b, 0);
    }
    else if (t == CAST_TO_REF_IDENTIFIER) {
      r = cast_to_ref_identifier(b, 0);
    }
    else if (t == CAST_TO_SOURCE) {
      r = cast_to_source(b, 0);
    }
    else if (t == CAST_TO_SOURCE_IDENTIFIER) {
      r = cast_to_source_identifier(b, 0);
    }
    else if (t == CAST_TO_TYPE) {
      r = cast_to_type(b, 0);
    }
    else if (t == CAST_TO_TYPE_IDENTIFIER) {
      r = cast_to_type_identifier(b, 0);
    }
    else if (t == CATALOG_NAME) {
      r = catalog_name(b, 0);
    }
    else if (t == CATALOG_NAME_CHARACTERISTIC) {
      r = catalog_name_characteristic(b, 0);
    }
    else if (t == CEILING_FUNCTION) {
      r = ceiling_function(b, 0);
    }
    else if (t == CHAR_LENGTH_EXPRESSION) {
      r = char_length_expression(b, 0);
    }
    else if (t == CHAR_LENGTH_UNITS) {
      r = char_length_units(b, 0);
    }
    else if (t == CHARACTER_ENUMERATION) {
      r = character_enumeration(b, 0);
    }
    else if (t == CHARACTER_ENUMERATION_EXCLUDE) {
      r = character_enumeration_exclude(b, 0);
    }
    else if (t == CHARACTER_ENUMERATION_INCLUDE) {
      r = character_enumeration_include(b, 0);
    }
    else if (t == CHARACTER_FACTOR) {
      r = character_factor(b, 0);
    }
    else if (t == CHARACTER_LIKE_PREDICATE) {
      r = character_like_predicate(b, 0);
    }
    else if (t == CHARACTER_LIKE_PREDICATE_PART_2) {
      r = character_like_predicate_part_2(b, 0);
    }
    else if (t == CHARACTER_OVERLAY_FUNCTION) {
      r = character_overlay_function(b, 0);
    }
    else if (t == CHARACTER_PATTERN) {
      r = character_pattern(b, 0);
    }
    else if (t == CHARACTER_PRIMARY) {
      r = character_primary(b, 0);
    }
    else if (t == CHARACTER_REPRESENTATION) {
      r = character_representation(b, 0);
    }
    else if (t == CHARACTER_SET_DEFINITION) {
      r = character_set_definition(b, 0);
    }
    else if (t == CHARACTER_SET_NAME) {
      r = character_set_name(b, 0);
    }
    else if (t == CHARACTER_SET_NAME_CHARACTERISTIC) {
      r = character_set_name_characteristic(b, 0);
    }
    else if (t == CHARACTER_SET_SOURCE) {
      r = character_set_source(b, 0);
    }
    else if (t == CHARACTER_SET_SPECIFICATION) {
      r = character_set_specification(b, 0);
    }
    else if (t == CHARACTER_SET_SPECIFICATION_LIST) {
      r = character_set_specification_list(b, 0);
    }
    else if (t == CHARACTER_SPECIFIER) {
      r = character_specifier(b, 0);
    }
    else if (t == CHARACTER_STRING_LITERAL) {
      r = character_string_literal(b, 0);
    }
    else if (t == CHARACTER_STRING_TYPE) {
      r = character_string_type(b, 0);
    }
    else if (t == CHARACTER_SUBSTRING_FUNCTION) {
      r = character_substring_function(b, 0);
    }
    else if (t == CHARACTER_TRANSLITERATION) {
      r = character_transliteration(b, 0);
    }
    else if (t == CHARACTER_VALUE_EXPRESSION) {
      r = character_value_expression(b, 0);
    }
    else if (t == CHARACTER_VALUE_FUNCTION) {
      r = character_value_function(b, 0);
    }
    else if (t == CHECK_CONSTRAINT_DEFINITION) {
      r = check_constraint_definition(b, 0);
    }
    else if (t == CIRCUMFLEX) {
      r = circumflex(b, 0);
    }
    else if (t == CLOSE_STATEMENT) {
      r = close_statement(b, 0);
    }
    else if (t == COLLATE_CLAUSE) {
      r = collate_clause(b, 0);
    }
    else if (t == COLLATION_DEFINITION) {
      r = collation_definition(b, 0);
    }
    else if (t == COLLATION_NAME) {
      r = collation_name(b, 0);
    }
    else if (t == COLLATION_SPECIFICATION) {
      r = collation_specification(b, 0);
    }
    else if (t == COLLECTION_DERIVED_TABLE) {
      r = collection_derived_table(b, 0);
    }
    else if (t == COLLECTION_TYPE) {
      r = collection_type(b, 0);
    }
    else if (t == COLLECTION_VALUE_CONSTRUCTOR) {
      r = collection_value_constructor(b, 0);
    }
    else if (t == COLLECTION_VALUE_EXPRESSION) {
      r = collection_value_expression(b, 0);
    }
    else if (t == COLON) {
      r = colon(b, 0);
    }
    else if (t == COLUMN_CONSTRAINT) {
      r = column_constraint(b, 0);
    }
    else if (t == COLUMN_CONSTRAINT_DEFINITION) {
      r = column_constraint_definition(b, 0);
    }
    else if (t == COLUMN_DEFAULT_OPTION) {
      r = column_default_option(b, 0);
    }
    else if (t == COLUMN_DEFINITION) {
      r = column_definition(b, 0);
    }
    else if (t == COLUMN_NAME) {
      r = column_name(b, 0);
    }
    else if (t == COLUMN_NAME_LIST) {
      r = column_name_list(b, 0);
    }
    else if (t == COLUMN_OPTION_LIST) {
      r = column_option_list(b, 0);
    }
    else if (t == COLUMN_OPTIONS) {
      r = column_options(b, 0);
    }
    else if (t == COLUMN_REFERENCE) {
      r = column_reference(b, 0);
    }
    else if (t == COMMA) {
      r = comma(b, 0);
    }
    else if (t == COMMENT) {
      r = comment(b, 0);
    }
    else if (t == COMMENT_CHARACTER) {
      r = comment_character(b, 0);
    }
    else if (t == COMMIT_STATEMENT) {
      r = commit_statement(b, 0);
    }
    else if (t == COMMON_SEQUENCE_GENERATOR_OPTION) {
      r = common_sequence_generator_option(b, 0);
    }
    else if (t == COMMON_SEQUENCE_GENERATOR_OPTIONS) {
      r = common_sequence_generator_options(b, 0);
    }
    else if (t == COMMON_VALUE_EXPRESSION) {
      r = common_value_expression(b, 0);
    }
    else if (t == COMP_OP) {
      r = comp_op(b, 0);
    }
    else if (t == COMPARISON_PREDICATE) {
      r = comparison_predicate(b, 0);
    }
    else if (t == COMPARISON_PREDICATE_PART_2) {
      r = comparison_predicate_part_2(b, 0);
    }
    else if (t == COMPUTATIONAL_OPERATION) {
      r = computational_operation(b, 0);
    }
    else if (t == CONCATENATION) {
      r = concatenation(b, 0);
    }
    else if (t == CONCATENATION_OPERATOR) {
      r = concatenation_operator(b, 0);
    }
    else if (t == CONDITION) {
      r = condition(b, 0);
    }
    else if (t == CONDITION_ACTION) {
      r = condition_action(b, 0);
    }
    else if (t == CONDITION_INFORMATION) {
      r = condition_information(b, 0);
    }
    else if (t == CONDITION_INFORMATION_ITEM) {
      r = condition_information_item(b, 0);
    }
    else if (t == CONDITION_INFORMATION_ITEM_NAME) {
      r = condition_information_item_name(b, 0);
    }
    else if (t == CONDITION_NUMBER) {
      r = condition_number(b, 0);
    }
    else if (t == CONNECT_STATEMENT) {
      r = connect_statement(b, 0);
    }
    else if (t == CONNECTION_NAME) {
      r = connection_name(b, 0);
    }
    else if (t == CONNECTION_OBJECT) {
      r = connection_object(b, 0);
    }
    else if (t == CONNECTION_TARGET) {
      r = connection_target(b, 0);
    }
    else if (t == CONNECTION_USER_NAME) {
      r = connection_user_name(b, 0);
    }
    else if (t == CONSTRAINT_CHARACTERISTICS) {
      r = constraint_characteristics(b, 0);
    }
    else if (t == CONSTRAINT_CHECK_TIME) {
      r = constraint_check_time(b, 0);
    }
    else if (t == CONSTRAINT_NAME) {
      r = constraint_name(b, 0);
    }
    else if (t == CONSTRAINT_NAME_DEFINITION) {
      r = constraint_name_definition(b, 0);
    }
    else if (t == CONSTRAINT_NAME_LIST) {
      r = constraint_name_list(b, 0);
    }
    else if (t == CONSTRUCTOR_METHOD_SELECTION) {
      r = constructor_method_selection(b, 0);
    }
    else if (t == CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR) {
      r = contextually_typed_row_value_constructor(b, 0);
    }
    else if (t == CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR_ELEMENT) {
      r = contextually_typed_row_value_constructor_element(b, 0);
    }
    else if (t == CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR_ELEMENT_LIST) {
      r = contextually_typed_row_value_constructor_element_list(b, 0);
    }
    else if (t == CONTEXTUALLY_TYPED_ROW_VALUE_EXPRESSION) {
      r = contextually_typed_row_value_expression(b, 0);
    }
    else if (t == CONTEXTUALLY_TYPED_ROW_VALUE_EXPRESSION_LIST) {
      r = contextually_typed_row_value_expression_list(b, 0);
    }
    else if (t == CONTEXTUALLY_TYPED_TABLE_VALUE_CONSTRUCTOR) {
      r = contextually_typed_table_value_constructor(b, 0);
    }
    else if (t == CONTEXTUALLY_TYPED_VALUE_SPECIFICATION) {
      r = contextually_typed_value_specification(b, 0);
    }
    else if (t == CORRELATION_NAME) {
      r = correlation_name(b, 0);
    }
    else if (t == CORRESPONDING_COLUMN_LIST) {
      r = corresponding_column_list(b, 0);
    }
    else if (t == CORRESPONDING_SPEC) {
      r = corresponding_spec(b, 0);
    }
    else if (t == CROSS_JOIN) {
      r = cross_join(b, 0);
    }
    else if (t == CUBE_LIST) {
      r = cube_list(b, 0);
    }
    else if (t == CURRENT_COLLATION_SPECIFICATION) {
      r = current_collation_specification(b, 0);
    }
    else if (t == CURRENT_DATE_VALUE_FUNCTION) {
      r = current_date_value_function(b, 0);
    }
    else if (t == CURRENT_LOCAL_TIME_VALUE_FUNCTION) {
      r = current_local_time_value_function(b, 0);
    }
    else if (t == CURRENT_LOCAL_TIMESTAMP_VALUE_FUNCTION) {
      r = current_local_timestamp_value_function(b, 0);
    }
    else if (t == CURRENT_TIME_VALUE_FUNCTION) {
      r = current_time_value_function(b, 0);
    }
    else if (t == CURRENT_TIMESTAMP_VALUE_FUNCTION) {
      r = current_timestamp_value_function(b, 0);
    }
    else if (t == CURSOR_ATTRIBUTE) {
      r = cursor_attribute(b, 0);
    }
    else if (t == CURSOR_ATTRIBUTES) {
      r = cursor_attributes(b, 0);
    }
    else if (t == CURSOR_HOLDABILITY) {
      r = cursor_holdability(b, 0);
    }
    else if (t == CURSOR_INTENT) {
      r = cursor_intent(b, 0);
    }
    else if (t == CURSOR_NAME) {
      r = cursor_name(b, 0);
    }
    else if (t == CURSOR_RETURNABILITY) {
      r = cursor_returnability(b, 0);
    }
    else if (t == CURSOR_SCROLLABILITY) {
      r = cursor_scrollability(b, 0);
    }
    else if (t == CURSOR_SENSITIVITY) {
      r = cursor_sensitivity(b, 0);
    }
    else if (t == CURSOR_SPECIFICATION) {
      r = cursor_specification(b, 0);
    }
    else if (t == CYCLE_CLAUSE) {
      r = cycle_clause(b, 0);
    }
    else if (t == CYCLE_COLUMN) {
      r = cycle_column(b, 0);
    }
    else if (t == CYCLE_COLUMN_LIST) {
      r = cycle_column_list(b, 0);
    }
    else if (t == CYCLE_MARK_COLUMN) {
      r = cycle_mark_column(b, 0);
    }
    else if (t == CYCLE_MARK_VALUE) {
      r = cycle_mark_value(b, 0);
    }
    else if (t == DATA_TYPE) {
      r = data_type(b, 0);
    }
    else if (t == DATA_TYPE_LIST) {
      r = data_type_list(b, 0);
    }
    else if (t == DATE_LITERAL) {
      r = date_literal(b, 0);
    }
    else if (t == DATE_STRING) {
      r = date_string(b, 0);
    }
    else if (t == DATE_VALUE) {
      r = date_value(b, 0);
    }
    else if (t == DATETIME_FACTOR) {
      r = datetime_factor(b, 0);
    }
    else if (t == DATETIME_LITERAL) {
      r = datetime_literal(b, 0);
    }
    else if (t == DATETIME_PRIMARY) {
      r = datetime_primary(b, 0);
    }
    else if (t == DATETIME_TERM) {
      r = datetime_term(b, 0);
    }
    else if (t == DATETIME_TYPE) {
      r = datetime_type(b, 0);
    }
    else if (t == DATETIME_VALUE) {
      r = datetime_value(b, 0);
    }
    else if (t == DATETIME_VALUE_EXPRESSION) {
      r = datetime_value_expression(b, 0);
    }
    else if (t == DATETIME_VALUE_FUNCTION) {
      r = datetime_value_function(b, 0);
    }
    else if (t == DAY_TIME_INTERVAL) {
      r = day_time_interval(b, 0);
    }
    else if (t == DAY_TIME_LITERAL) {
      r = day_time_literal(b, 0);
    }
    else if (t == DAYS_VALUE) {
      r = days_value(b, 0);
    }
    else if (t == DEALLOCATE_DESCRIPTOR_STATEMENT) {
      r = deallocate_descriptor_statement(b, 0);
    }
    else if (t == DEALLOCATE_PREPARED_STATEMENT) {
      r = deallocate_prepared_statement(b, 0);
    }
    else if (t == DECLARE_CURSOR) {
      r = declare_cursor(b, 0);
    }
    else if (t == DEFAULT_CLAUSE) {
      r = default_clause(b, 0);
    }
    else if (t == DEFAULT_OPTION) {
      r = default_option(b, 0);
    }
    else if (t == DEFAULT_SPECIFICATION) {
      r = default_specification(b, 0);
    }
    else if (t == DELETE_RULE) {
      r = delete_rule(b, 0);
    }
    else if (t == DELETE_STATEMENT_POSITIONED) {
      r = delete_statement_positioned(b, 0);
    }
    else if (t == DELETE_STATEMENT_SEARCHED) {
      r = delete_statement_searched(b, 0);
    }
    else if (t == DELIMITED_IDENTIFIER) {
      r = delimited_identifier(b, 0);
    }
    else if (t == DELIMITED_IDENTIFIER_BODY) {
      r = delimited_identifier_body(b, 0);
    }
    else if (t == DELIMITED_IDENTIFIER_PART) {
      r = delimited_identifier_part(b, 0);
    }
    else if (t == DEPENDENT_VARIABLE_EXPRESSION) {
      r = dependent_variable_expression(b, 0);
    }
    else if (t == DEREFERENCE_OPERATION) {
      r = dereference_operation(b, 0);
    }
    else if (t == DEREFERENCE_OPERATOR) {
      r = dereference_operator(b, 0);
    }
    else if (t == DERIVED_COLUMN) {
      r = derived_column(b, 0);
    }
    else if (t == DERIVED_COLUMN_LIST) {
      r = derived_column_list(b, 0);
    }
    else if (t == DERIVED_REPRESENTATION) {
      r = derived_representation(b, 0);
    }
    else if (t == DERIVED_TABLE) {
      r = derived_table(b, 0);
    }
    else if (t == DESCRIBE_INPUT_STATEMENT) {
      r = describe_input_statement(b, 0);
    }
    else if (t == DESCRIBE_OUTPUT_STATEMENT) {
      r = describe_output_statement(b, 0);
    }
    else if (t == DESCRIBE_STATEMENT) {
      r = describe_statement(b, 0);
    }
    else if (t == DESCRIBED_OBJECT) {
      r = described_object(b, 0);
    }
    else if (t == DESCRIPTOR_ITEM_NAME) {
      r = descriptor_item_name(b, 0);
    }
    else if (t == DESCRIPTOR_NAME) {
      r = descriptor_name(b, 0);
    }
    else if (t == DETERMINISTIC_CHARACTERISTIC) {
      r = deterministic_characteristic(b, 0);
    }
    else if (t == DIAGNOSTICS_SIZE) {
      r = diagnostics_size(b, 0);
    }
    else if (t == DIGIT) {
      r = digit(b, 0);
    }
    else if (t == DIRECT_SQL_DATA_STATEMENT) {
      r = direct_SQL_data_statement(b, 0);
    }
    else if (t == DIRECT_SQL_STATEMENT) {
      r = direct_SQL_statement(b, 0);
    }
    else if (t == DIRECT_IMPLEMENTATION_DEFINED_STATEMENT) {
      r = direct_implementation_defined_statement(b, 0);
    }
    else if (t == DIRECT_INVOCATION) {
      r = direct_invocation(b, 0);
    }
    else if (t == DIRECT_SELECT_STATEMENT_MULTIPLE_ROWS) {
      r = direct_select_statement_multiple_rows(b, 0);
    }
    else if (t == DIRECTLY_EXECUTABLE_STATEMENT) {
      r = directly_executable_statement(b, 0);
    }
    else if (t == DISCONNECT_OBJECT) {
      r = disconnect_object(b, 0);
    }
    else if (t == DISCONNECT_STATEMENT) {
      r = disconnect_statement(b, 0);
    }
    else if (t == DISPATCH_CLAUSE) {
      r = dispatch_clause(b, 0);
    }
    else if (t == DISTINCT_PREDICATE) {
      r = distinct_predicate(b, 0);
    }
    else if (t == DISTINCT_PREDICATE_PART_2) {
      r = distinct_predicate_part_2(b, 0);
    }
    else if (t == DOMAIN_CONSTRAINT) {
      r = domain_constraint(b, 0);
    }
    else if (t == DOMAIN_DEFINITION) {
      r = domain_definition(b, 0);
    }
    else if (t == DOMAIN_NAME) {
      r = domain_name(b, 0);
    }
    else if (t == DOUBLE_COLON) {
      r = double_colon(b, 0);
    }
    else if (t == DOUBLE_PERIOD) {
      r = double_period(b, 0);
    }
    else if (t == DOUBLE_QUOTE) {
      r = double_quote(b, 0);
    }
    else if (t == DOUBLEQUOTE_SYMBOL) {
      r = doublequote_symbol(b, 0);
    }
    else if (t == DROP_ASSERTION_STATEMENT) {
      r = drop_assertion_statement(b, 0);
    }
    else if (t == DROP_ATTRIBUTE_DEFINITION) {
      r = drop_attribute_definition(b, 0);
    }
    else if (t == DROP_BEHAVIOR) {
      r = drop_behavior(b, 0);
    }
    else if (t == DROP_CHARACTER_SET_STATEMENT) {
      r = drop_character_set_statement(b, 0);
    }
    else if (t == DROP_COLLATION_STATEMENT) {
      r = drop_collation_statement(b, 0);
    }
    else if (t == DROP_COLUMN_DEFAULT_CLAUSE) {
      r = drop_column_default_clause(b, 0);
    }
    else if (t == DROP_COLUMN_DEFINITION) {
      r = drop_column_definition(b, 0);
    }
    else if (t == DROP_COLUMN_SCOPE_CLAUSE) {
      r = drop_column_scope_clause(b, 0);
    }
    else if (t == DROP_DATA_TYPE_STATEMENT) {
      r = drop_data_type_statement(b, 0);
    }
    else if (t == DROP_DOMAIN_CONSTRAINT_DEFINITION) {
      r = drop_domain_constraint_definition(b, 0);
    }
    else if (t == DROP_DOMAIN_DEFAULT_CLAUSE) {
      r = drop_domain_default_clause(b, 0);
    }
    else if (t == DROP_DOMAIN_STATEMENT) {
      r = drop_domain_statement(b, 0);
    }
    else if (t == DROP_METHOD_SPECIFICATION) {
      r = drop_method_specification(b, 0);
    }
    else if (t == DROP_ROLE_STATEMENT) {
      r = drop_role_statement(b, 0);
    }
    else if (t == DROP_ROUTINE_STATEMENT) {
      r = drop_routine_statement(b, 0);
    }
    else if (t == DROP_SCHEMA_STATEMENT) {
      r = drop_schema_statement(b, 0);
    }
    else if (t == DROP_SEQUENCE_GENERATOR_STATEMENT) {
      r = drop_sequence_generator_statement(b, 0);
    }
    else if (t == DROP_TABLE_CONSTRAINT_DEFINITION) {
      r = drop_table_constraint_definition(b, 0);
    }
    else if (t == DROP_TABLE_STATEMENT) {
      r = drop_table_statement(b, 0);
    }
    else if (t == DROP_TRANSFORM_ELEMENT_LIST) {
      r = drop_transform_element_list(b, 0);
    }
    else if (t == DROP_TRANSFORM_STATEMENT) {
      r = drop_transform_statement(b, 0);
    }
    else if (t == DROP_TRANSLITERATION_STATEMENT) {
      r = drop_transliteration_statement(b, 0);
    }
    else if (t == DROP_TRIGGER_STATEMENT) {
      r = drop_trigger_statement(b, 0);
    }
    else if (t == DROP_USER_DEFINED_CAST_STATEMENT) {
      r = drop_user_defined_cast_statement(b, 0);
    }
    else if (t == DROP_USER_DEFINED_ORDERING_STATEMENT) {
      r = drop_user_defined_ordering_statement(b, 0);
    }
    else if (t == DROP_VIEW_STATEMENT) {
      r = drop_view_statement(b, 0);
    }
    else if (t == DYNAMIC_CLOSE_STATEMENT) {
      r = dynamic_close_statement(b, 0);
    }
    else if (t == DYNAMIC_CURSOR_NAME) {
      r = dynamic_cursor_name(b, 0);
    }
    else if (t == DYNAMIC_DECLARE_CURSOR) {
      r = dynamic_declare_cursor(b, 0);
    }
    else if (t == DYNAMIC_DELETE_STATEMENT_POSITIONED) {
      r = dynamic_delete_statement_positioned(b, 0);
    }
    else if (t == DYNAMIC_FETCH_STATEMENT) {
      r = dynamic_fetch_statement(b, 0);
    }
    else if (t == DYNAMIC_OPEN_STATEMENT) {
      r = dynamic_open_statement(b, 0);
    }
    else if (t == DYNAMIC_PARAMETER_SPECIFICATION) {
      r = dynamic_parameter_specification(b, 0);
    }
    else if (t == DYNAMIC_RESULT_SETS_CHARACTERISTIC) {
      r = dynamic_result_sets_characteristic(b, 0);
    }
    else if (t == DYNAMIC_SELECT_STATEMENT) {
      r = dynamic_select_statement(b, 0);
    }
    else if (t == DYNAMIC_SINGLE_ROW_SELECT_STATEMENT) {
      r = dynamic_single_row_select_statement(b, 0);
    }
    else if (t == DYNAMIC_UPDATE_STATEMENT_POSITIONED) {
      r = dynamic_update_statement_positioned(b, 0);
    }
    else if (t == ELSE_CLAUSE) {
      r = else_clause(b, 0);
    }
    else if (t == EMBEDDED_SQL_ADA_PROGRAM) {
      r = embedded_SQL_Ada_program(b, 0);
    }
    else if (t == EMBEDDED_SQL_C_PROGRAM) {
      r = embedded_SQL_C_program(b, 0);
    }
    else if (t == EMBEDDED_SQL_COBOL_PROGRAM) {
      r = embedded_SQL_COBOL_program(b, 0);
    }
    else if (t == EMBEDDED_SQL_FORTRAN_PROGRAM) {
      r = embedded_SQL_Fortran_program(b, 0);
    }
    else if (t == EMBEDDED_SQL_MUMPS_DECLARE) {
      r = embedded_SQL_MUMPS_declare(b, 0);
    }
    else if (t == EMBEDDED_SQL_MUMPS_PROGRAM) {
      r = embedded_SQL_MUMPS_program(b, 0);
    }
    else if (t == EMBEDDED_SQL_PL_I_PROGRAM) {
      r = embedded_SQL_PL_I_program(b, 0);
    }
    else if (t == EMBEDDED_SQL_PASCAL_PROGRAM) {
      r = embedded_SQL_Pascal_program(b, 0);
    }
    else if (t == EMBEDDED_SQL_BEGIN_DECLARE) {
      r = embedded_SQL_begin_declare(b, 0);
    }
    else if (t == EMBEDDED_SQL_DECLARE_SECTION) {
      r = embedded_SQL_declare_section(b, 0);
    }
    else if (t == EMBEDDED_SQL_END_DECLARE) {
      r = embedded_SQL_end_declare(b, 0);
    }
    else if (t == EMBEDDED_SQL_HOST_PROGRAM) {
      r = embedded_SQL_host_program(b, 0);
    }
    else if (t == EMBEDDED_SQL_STATEMENT) {
      r = embedded_SQL_statement(b, 0);
    }
    else if (t == EMBEDDED_AUTHORIZATION_CLAUSE) {
      r = embedded_authorization_clause(b, 0);
    }
    else if (t == EMBEDDED_AUTHORIZATION_DECLARATION) {
      r = embedded_authorization_declaration(b, 0);
    }
    else if (t == EMBEDDED_AUTHORIZATION_IDENTIFIER) {
      r = embedded_authorization_identifier(b, 0);
    }
    else if (t == EMBEDDED_CHARACTER_SET_DECLARATION) {
      r = embedded_character_set_declaration(b, 0);
    }
    else if (t == EMBEDDED_COLLATION_SPECIFICATION) {
      r = embedded_collation_specification(b, 0);
    }
    else if (t == EMBEDDED_EXCEPTION_DECLARATION) {
      r = embedded_exception_declaration(b, 0);
    }
    else if (t == EMBEDDED_PATH_SPECIFICATION) {
      r = embedded_path_specification(b, 0);
    }
    else if (t == EMBEDDED_TRANSFORM_GROUP_SPECIFICATION) {
      r = embedded_transform_group_specification(b, 0);
    }
    else if (t == EMBEDDED_VARIABLE_NAME) {
      r = embedded_variable_name(b, 0);
    }
    else if (t == EMBEDDED_VARIABLE_SPECIFICATION) {
      r = embedded_variable_specification(b, 0);
    }
    else if (t == EMPTY_GROUPING_SET) {
      r = empty_grouping_set(b, 0);
    }
    else if (t == EMPTY_SPECIFICATION) {
      r = empty_specification(b, 0);
    }
    else if (t == END_FIELD) {
      r = end_field(b, 0);
    }
    else if (t == EQUALS_OPERATOR) {
      r = equals_operator(b, 0);
    }
    else if (t == EQUALS_ORDERING_FORM) {
      r = equals_ordering_form(b, 0);
    }
    else if (t == ESCAPE_CHARACTER) {
      r = escape_character(b, 0);
    }
    else if (t == ESCAPE_OCTET) {
      r = escape_octet(b, 0);
    }
    else if (t == ESCAPED_CHARACTER) {
      r = escaped_character(b, 0);
    }
    else if (t == EXACT_NUMERIC_LITERAL) {
      r = exact_numeric_literal(b, 0);
    }
    else if (t == EXACT_NUMERIC_TYPE) {
      r = exact_numeric_type(b, 0);
    }
    else if (t == EXCLUSIVE_USER_DEFINED_TYPE_SPECIFICATION) {
      r = exclusive_user_defined_type_specification(b, 0);
    }
    else if (t == EXECUTE_IMMEDIATE_STATEMENT) {
      r = execute_immediate_statement(b, 0);
    }
    else if (t == EXECUTE_STATEMENT) {
      r = execute_statement(b, 0);
    }
    else if (t == EXISTING_COLLATION_NAME) {
      r = existing_collation_name(b, 0);
    }
    else if (t == EXISTING_TRANSLITERATION_NAME) {
      r = existing_transliteration_name(b, 0);
    }
    else if (t == EXISTING_WINDOW_NAME) {
      r = existing_window_name(b, 0);
    }
    else if (t == EXISTS_PREDICATE) {
      r = exists_predicate(b, 0);
    }
    else if (t == EXPLICIT_ROW_VALUE_CONSTRUCTOR) {
      r = explicit_row_value_constructor(b, 0);
    }
    else if (t == EXPLICIT_TABLE) {
      r = explicit_table(b, 0);
    }
    else if (t == EXPONENT) {
      r = exponent(b, 0);
    }
    else if (t == EXPONENTIAL_FUNCTION) {
      r = exponential_function(b, 0);
    }
    else if (t == EXTENDED_CURSOR_NAME) {
      r = extended_cursor_name(b, 0);
    }
    else if (t == EXTENDED_STATEMENT_NAME) {
      r = extended_statement_name(b, 0);
    }
    else if (t == EXTERNAL_BODY_REFERENCE) {
      r = external_body_reference(b, 0);
    }
    else if (t == EXTERNAL_ROUTINE_NAME) {
      r = external_routine_name(b, 0);
    }
    else if (t == EXTERNAL_SECURITY_CLAUSE) {
      r = external_security_clause(b, 0);
    }
    else if (t == EXTERNALLY_INVOKED_PROCEDURE) {
      r = externally_invoked_procedure(b, 0);
    }
    else if (t == EXTRACT_EXPRESSION) {
      r = extract_expression(b, 0);
    }
    else if (t == EXTRACT_FIELD) {
      r = extract_field(b, 0);
    }
    else if (t == EXTRACT_SOURCE) {
      r = extract_source(b, 0);
    }
    else if (t == FACTOR) {
      r = factor(b, 0);
    }
    else if (t == FETCH_ORIENTATION) {
      r = fetch_orientation(b, 0);
    }
    else if (t == FETCH_STATEMENT) {
      r = fetch_statement(b, 0);
    }
    else if (t == FETCH_TARGET_LIST) {
      r = fetch_target_list(b, 0);
    }
    else if (t == FIELD_DEFINITION) {
      r = field_definition(b, 0);
    }
    else if (t == FIELD_NAME) {
      r = field_name(b, 0);
    }
    else if (t == FIELD_REFERENCE) {
      r = field_reference(b, 0);
    }
    else if (t == FILTER_CLAUSE) {
      r = filter_clause(b, 0);
    }
    else if (t == FINALITY) {
      r = finality(b, 0);
    }
    else if (t == FLOOR_FUNCTION) {
      r = floor_function(b, 0);
    }
    else if (t == FOLD) {
      r = fold(b, 0);
    }
    else if (t == FREE_LOCATOR_STATEMENT) {
      r = free_locator_statement(b, 0);
    }
    else if (t == FROM_CLAUSE) {
      r = from_clause(b, 0);
    }
    else if (t == FROM_CONSTRUCTOR) {
      r = from_constructor(b, 0);
    }
    else if (t == FROM_DEFAULT) {
      r = from_default(b, 0);
    }
    else if (t == FROM_SQL) {
      r = from_sql(b, 0);
    }
    else if (t == FROM_SQL_FUNCTION) {
      r = from_sql_function(b, 0);
    }
    else if (t == FROM_SUBQUERY) {
      r = from_subquery(b, 0);
    }
    else if (t == FULL_ORDERING_FORM) {
      r = full_ordering_form(b, 0);
    }
    else if (t == FUNCTION_SPECIFICATION) {
      r = function_specification(b, 0);
    }
    else if (t == GENERAL_LITERAL) {
      r = general_literal(b, 0);
    }
    else if (t == GENERAL_SET_FUNCTION) {
      r = general_set_function(b, 0);
    }
    else if (t == GENERAL_VALUE_SPECIFICATION) {
      r = general_value_specification(b, 0);
    }
    else if (t == GENERALIZED_EXPRESSION) {
      r = generalized_expression(b, 0);
    }
    else if (t == GENERALIZED_INVOCATION) {
      r = generalized_invocation(b, 0);
    }
    else if (t == GENERATION_CLAUSE) {
      r = generation_clause(b, 0);
    }
    else if (t == GENERATION_EXPRESSION) {
      r = generation_expression(b, 0);
    }
    else if (t == GENERATION_RULE) {
      r = generation_rule(b, 0);
    }
    else if (t == GET_DESCRIPTOR_INFORMATION) {
      r = get_descriptor_information(b, 0);
    }
    else if (t == GET_DIAGNOSTICS_STATEMENT) {
      r = get_diagnostics_statement(b, 0);
    }
    else if (t == GET_HEADER_INFORMATION) {
      r = get_header_information(b, 0);
    }
    else if (t == GET_ITEM_INFORMATION) {
      r = get_item_information(b, 0);
    }
    else if (t == GLOBAL_OR_LOCAL) {
      r = global_or_local(b, 0);
    }
    else if (t == GO_TO) {
      r = go_to(b, 0);
    }
    else if (t == GOTO_TARGET) {
      r = goto_target(b, 0);
    }
    else if (t == GRANT_PRIVILEGE_STATEMENT) {
      r = grant_privilege_statement(b, 0);
    }
    else if (t == GRANT_ROLE_STATEMENT) {
      r = grant_role_statement(b, 0);
    }
    else if (t == GRANT_STATEMENT) {
      r = grant_statement(b, 0);
    }
    else if (t == GRANTEE) {
      r = grantee(b, 0);
    }
    else if (t == GRANTOR) {
      r = grantor(b, 0);
    }
    else if (t == GREATER_THAN_OPERATOR) {
      r = greater_than_operator(b, 0);
    }
    else if (t == GREATER_THAN_OR_EQUALS_OPERATOR) {
      r = greater_than_or_equals_operator(b, 0);
    }
    else if (t == GROUP_BY_CLAUSE) {
      r = group_by_clause(b, 0);
    }
    else if (t == GROUP_NAME) {
      r = group_name(b, 0);
    }
    else if (t == GROUP_SPECIFICATION) {
      r = group_specification(b, 0);
    }
    else if (t == GROUPING_COLUMN_REFERENCE) {
      r = grouping_column_reference(b, 0);
    }
    else if (t == GROUPING_COLUMN_REFERENCE_LIST) {
      r = grouping_column_reference_list(b, 0);
    }
    else if (t == GROUPING_ELEMENT) {
      r = grouping_element(b, 0);
    }
    else if (t == GROUPING_ELEMENT_LIST) {
      r = grouping_element_list(b, 0);
    }
    else if (t == GROUPING_OPERATION) {
      r = grouping_operation(b, 0);
    }
    else if (t == GROUPING_SET) {
      r = grouping_set(b, 0);
    }
    else if (t == GROUPING_SET_LIST) {
      r = grouping_set_list(b, 0);
    }
    else if (t == GROUPING_SETS_SPECIFICATION) {
      r = grouping_sets_specification(b, 0);
    }
    else if (t == HAVING_CLAUSE) {
      r = having_clause(b, 0);
    }
    else if (t == HEADER_ITEM_NAME) {
      r = header_item_name(b, 0);
    }
    else if (t == HEXIT) {
      r = hexit(b, 0);
    }
    else if (t == HIGH_VALUE) {
      r = high_value(b, 0);
    }
    else if (t == HOLD_LOCATOR_STATEMENT) {
      r = hold_locator_statement(b, 0);
    }
    else if (t == HOST_PL_I_LABEL_VARIABLE) {
      r = host_PL_I_label_variable(b, 0);
    }
    else if (t == HOST_IDENTIFIER) {
      r = host_identifier(b, 0);
    }
    else if (t == HOST_LABEL_IDENTIFIER) {
      r = host_label_identifier(b, 0);
    }
    else if (t == HOST_PARAMETER_DATA_TYPE) {
      r = host_parameter_data_type(b, 0);
    }
    else if (t == HOST_PARAMETER_DECLARATION) {
      r = host_parameter_declaration(b, 0);
    }
    else if (t == HOST_PARAMETER_DECLARATION_LIST) {
      r = host_parameter_declaration_list(b, 0);
    }
    else if (t == HOST_PARAMETER_NAME) {
      r = host_parameter_name(b, 0);
    }
    else if (t == HOST_PARAMETER_SPECIFICATION) {
      r = host_parameter_specification(b, 0);
    }
    else if (t == HOST_VARIABLE_DEFINITION) {
      r = host_variable_definition(b, 0);
    }
    else if (t == HOURS_VALUE) {
      r = hours_value(b, 0);
    }
    else if (t == HYPOTHETICAL_SET_FUNCTION) {
      r = hypothetical_set_function(b, 0);
    }
    else if (t == HYPOTHETICAL_SET_FUNCTION_VALUE_EXPRESSION_LIST) {
      r = hypothetical_set_function_value_expression_list(b, 0);
    }
    else if (t == IDENTIFIER) {
      r = identifier(b, 0);
    }
    else if (t == IDENTIFIER_BODY) {
      r = identifier_body(b, 0);
    }
    else if (t == IDENTIFIER_CHAIN) {
      r = identifier_chain(b, 0);
    }
    else if (t == IDENTIFIER_PART) {
      r = identifier_part(b, 0);
    }
    else if (t == IDENTIFIER_START) {
      r = identifier_start(b, 0);
    }
    else if (t == IDENTITY_COLUMN_SPECIFICATION) {
      r = identity_column_specification(b, 0);
    }
    else if (t == IDENTITY_OPTION) {
      r = identity_option(b, 0);
    }
    else if (t == IMPLEMENTATION_DEFINED_CHARACTER_SET_NAME) {
      r = implementation_defined_character_set_name(b, 0);
    }
    else if (t == IMPLICITLY_TYPED_VALUE_SPECIFICATION) {
      r = implicitly_typed_value_specification(b, 0);
    }
    else if (t == IN_PREDICATE) {
      r = in_predicate(b, 0);
    }
    else if (t == IN_PREDICATE_PART_2) {
      r = in_predicate_part_2(b, 0);
    }
    else if (t == IN_PREDICATE_VALUE) {
      r = in_predicate_value(b, 0);
    }
    else if (t == IN_VALUE_LIST) {
      r = in_value_list(b, 0);
    }
    else if (t == IN_LINE_WINDOW_SPECIFICATION) {
      r = in_line_window_specification(b, 0);
    }
    else if (t == INCLUSIVE_USER_DEFINED_TYPE_SPECIFICATION) {
      r = inclusive_user_defined_type_specification(b, 0);
    }
    else if (t == INDEPENDENT_VARIABLE_EXPRESSION) {
      r = independent_variable_expression(b, 0);
    }
    else if (t == INDICATOR_PARAMETER) {
      r = indicator_parameter(b, 0);
    }
    else if (t == INDICATOR_VARIABLE) {
      r = indicator_variable(b, 0);
    }
    else if (t == INPUT_USING_CLAUSE) {
      r = input_using_clause(b, 0);
    }
    else if (t == INSERT_COLUMN_LIST) {
      r = insert_column_list(b, 0);
    }
    else if (t == INSERT_COLUMNS_AND_SOURCE) {
      r = insert_columns_and_source(b, 0);
    }
    else if (t == INSERT_STATEMENT) {
      r = insert_statement(b, 0);
    }
    else if (t == INSERTION_TARGET) {
      r = insertion_target(b, 0);
    }
    else if (t == INSTANTIABLE_CLAUSE) {
      r = instantiable_clause(b, 0);
    }
    else if (t == INTERVAL_ABSOLUTE_VALUE_FUNCTION) {
      r = interval_absolute_value_function(b, 0);
    }
    else if (t == INTERVAL_FACTOR) {
      r = interval_factor(b, 0);
    }
    else if (t == INTERVAL_FRACTIONAL_SECONDS_PRECISION) {
      r = interval_fractional_seconds_precision(b, 0);
    }
    else if (t == INTERVAL_LEADING_FIELD_PRECISION) {
      r = interval_leading_field_precision(b, 0);
    }
    else if (t == INTERVAL_LITERAL) {
      r = interval_literal(b, 0);
    }
    else if (t == INTERVAL_PRIMARY) {
      r = interval_primary(b, 0);
    }
    else if (t == INTERVAL_QUALIFIER) {
      r = interval_qualifier(b, 0);
    }
    else if (t == INTERVAL_STRING) {
      r = interval_string(b, 0);
    }
    else if (t == INTERVAL_TERM) {
      r = interval_term(b, 0);
    }
    else if (t == INTERVAL_TERM_1) {
      r = interval_term_1(b, 0);
    }
    else if (t == INTERVAL_TERM_2) {
      r = interval_term_2(b, 0);
    }
    else if (t == INTERVAL_TYPE) {
      r = interval_type(b, 0);
    }
    else if (t == INTERVAL_VALUE_EXPRESSION) {
      r = interval_value_expression(b, 0);
    }
    else if (t == INTERVAL_VALUE_EXPRESSION_1) {
      r = interval_value_expression_1(b, 0);
    }
    else if (t == INTERVAL_VALUE_FUNCTION) {
      r = interval_value_function(b, 0);
    }
    else if (t == INTO_ARGUMENT) {
      r = into_argument(b, 0);
    }
    else if (t == INTO_ARGUMENTS) {
      r = into_arguments(b, 0);
    }
    else if (t == INTO_DESCRIPTOR) {
      r = into_descriptor(b, 0);
    }
    else if (t == INTRODUCER) {
      r = introducer(b, 0);
    }
    else if (t == INVERSE_DISTRIBUTION_FUNCTION) {
      r = inverse_distribution_function(b, 0);
    }
    else if (t == INVERSE_DISTRIBUTION_FUNCTION_ARGUMENT) {
      r = inverse_distribution_function_argument(b, 0);
    }
    else if (t == INVERSE_DISTRIBUTION_FUNCTION_TYPE) {
      r = inverse_distribution_function_type(b, 0);
    }
    else if (t == ISOLATION_LEVEL) {
      r = isolation_level(b, 0);
    }
    else if (t == ITEM_NUMBER) {
      r = item_number(b, 0);
    }
    else if (t == JOIN_COLUMN_LIST) {
      r = join_column_list(b, 0);
    }
    else if (t == JOIN_CONDITION) {
      r = join_condition(b, 0);
    }
    else if (t == JOIN_SPECIFICATION) {
      r = join_specification(b, 0);
    }
    else if (t == JOIN_TYPE) {
      r = join_type(b, 0);
    }
    else if (t == JOINED_TABLE) {
      r = joined_table(b, 0);
    }
    else if (t == KEY_WORD) {
      r = key_word(b, 0);
    }
    else if (t == LANGUAGE_CLAUSE) {
      r = language_clause(b, 0);
    }
    else if (t == LANGUAGE_NAME) {
      r = language_name(b, 0);
    }
    else if (t == LARGE_OBJECT_LENGTH) {
      r = large_object_length(b, 0);
    }
    else if (t == LARGE_OBJECT_LENGTH_TOKEN) {
      r = large_object_length_token(b, 0);
    }
    else if (t == LATERAL_DERIVED_TABLE) {
      r = lateral_derived_table(b, 0);
    }
    else if (t == LEFT_BRACE) {
      r = left_brace(b, 0);
    }
    else if (t == LEFT_BRACKET) {
      r = left_bracket(b, 0);
    }
    else if (t == LEFT_BRACKET_OR_TRIGRAPH) {
      r = left_bracket_or_trigraph(b, 0);
    }
    else if (t == LEFT_BRACKET_TRIGRAPH) {
      r = left_bracket_trigraph(b, 0);
    }
    else if (t == LEFT_PAREN) {
      r = left_paren(b, 0);
    }
    else if (t == LENGTH) {
      r = length(b, 0);
    }
    else if (t == LENGTH_EXPRESSION) {
      r = length_expression(b, 0);
    }
    else if (t == LESS_THAN_OPERATOR) {
      r = less_than_operator(b, 0);
    }
    else if (t == LESS_THAN_OR_EQUALS_OPERATOR) {
      r = less_than_or_equals_operator(b, 0);
    }
    else if (t == LEVEL_OF_ISOLATION) {
      r = level_of_isolation(b, 0);
    }
    else if (t == LEVELS_CLAUSE) {
      r = levels_clause(b, 0);
    }
    else if (t == LIKE_CLAUSE) {
      r = like_clause(b, 0);
    }
    else if (t == LIKE_OPTIONS) {
      r = like_options(b, 0);
    }
    else if (t == LIKE_PREDICATE) {
      r = like_predicate(b, 0);
    }
    else if (t == LIST_OF_ATTRIBUTES) {
      r = list_of_attributes(b, 0);
    }
    else if (t == LITERAL) {
      r = literal(b, 0);
    }
    else if (t == LOCAL_OR_SCHEMA_QUALIFIED_NAME) {
      r = local_or_schema_qualified_name(b, 0);
    }
    else if (t == LOCAL_OR_SCHEMA_QUALIFIER) {
      r = local_or_schema_qualifier(b, 0);
    }
    else if (t == LOCAL_QUALIFIED_NAME) {
      r = local_qualified_name(b, 0);
    }
    else if (t == LOCAL_QUALIFIER) {
      r = local_qualifier(b, 0);
    }
    else if (t == LOCATOR_INDICATION) {
      r = locator_indication(b, 0);
    }
    else if (t == LOCATOR_REFERENCE) {
      r = locator_reference(b, 0);
    }
    else if (t == LOW_VALUE) {
      r = low_value(b, 0);
    }
    else if (t == MAJOR_CATEGORY) {
      r = major_category(b, 0);
    }
    else if (t == MANTISSA) {
      r = mantissa(b, 0);
    }
    else if (t == MAP_CATEGORY) {
      r = map_category(b, 0);
    }
    else if (t == MAP_FUNCTION_SPECIFICATION) {
      r = map_function_specification(b, 0);
    }
    else if (t == MATCH_PREDICATE) {
      r = match_predicate(b, 0);
    }
    else if (t == MATCH_PREDICATE_PART_2) {
      r = match_predicate_part_2(b, 0);
    }
    else if (t == MATCH_TYPE) {
      r = match_type(b, 0);
    }
    else if (t == MAXIMUM_DYNAMIC_RESULT_SETS) {
      r = maximum_dynamic_result_sets(b, 0);
    }
    else if (t == MEMBER) {
      r = member(b, 0);
    }
    else if (t == MEMBER_LIST) {
      r = member_list(b, 0);
    }
    else if (t == MEMBER_NAME) {
      r = member_name(b, 0);
    }
    else if (t == MEMBER_NAME_ALTERNATIVES) {
      r = member_name_alternatives(b, 0);
    }
    else if (t == MEMBER_PREDICATE) {
      r = member_predicate(b, 0);
    }
    else if (t == MEMBER_PREDICATE_PART_2) {
      r = member_predicate_part_2(b, 0);
    }
    else if (t == MERGE_CORRELATION_NAME) {
      r = merge_correlation_name(b, 0);
    }
    else if (t == MERGE_INSERT_SPECIFICATION) {
      r = merge_insert_specification(b, 0);
    }
    else if (t == MERGE_INSERT_VALUE_ELEMENT) {
      r = merge_insert_value_element(b, 0);
    }
    else if (t == MERGE_INSERT_VALUE_LIST) {
      r = merge_insert_value_list(b, 0);
    }
    else if (t == MERGE_OPERATION_SPECIFICATION) {
      r = merge_operation_specification(b, 0);
    }
    else if (t == MERGE_STATEMENT) {
      r = merge_statement(b, 0);
    }
    else if (t == MERGE_UPDATE_SPECIFICATION) {
      r = merge_update_specification(b, 0);
    }
    else if (t == MERGE_WHEN_CLAUSE) {
      r = merge_when_clause(b, 0);
    }
    else if (t == MERGE_WHEN_MATCHED_CLAUSE) {
      r = merge_when_matched_clause(b, 0);
    }
    else if (t == MERGE_WHEN_NOT_MATCHED_CLAUSE) {
      r = merge_when_not_matched_clause(b, 0);
    }
    else if (t == METHOD_CHARACTERISTIC) {
      r = method_characteristic(b, 0);
    }
    else if (t == METHOD_CHARACTERISTICS) {
      r = method_characteristics(b, 0);
    }
    else if (t == METHOD_INVOCATION) {
      r = method_invocation(b, 0);
    }
    else if (t == METHOD_NAME) {
      r = method_name(b, 0);
    }
    else if (t == METHOD_REFERENCE) {
      r = method_reference(b, 0);
    }
    else if (t == METHOD_SELECTION) {
      r = method_selection(b, 0);
    }
    else if (t == METHOD_SPECIFICATION) {
      r = method_specification(b, 0);
    }
    else if (t == METHOD_SPECIFICATION_DESIGNATOR) {
      r = method_specification_designator(b, 0);
    }
    else if (t == METHOD_SPECIFICATION_LIST) {
      r = method_specification_list(b, 0);
    }
    else if (t == MINUS_SIGN) {
      r = minus_sign(b, 0);
    }
    else if (t == MINUTES_VALUE) {
      r = minutes_value(b, 0);
    }
    else if (t == MODULE_AUTHORIZATION_CLAUSE) {
      r = module_authorization_clause(b, 0);
    }
    else if (t == MODULE_AUTHORIZATION_IDENTIFIER) {
      r = module_authorization_identifier(b, 0);
    }
    else if (t == MODULE_CHARACTER_SET_SPECIFICATION) {
      r = module_character_set_specification(b, 0);
    }
    else if (t == MODULE_COLLATION_SPECIFICATION) {
      r = module_collation_specification(b, 0);
    }
    else if (t == MODULE_COLLATIONS) {
      r = module_collations(b, 0);
    }
    else if (t == MODULE_CONTENTS) {
      r = module_contents(b, 0);
    }
    else if (t == MODULE_NAME_CLAUSE) {
      r = module_name_clause(b, 0);
    }
    else if (t == MODULE_PATH_SPECIFICATION) {
      r = module_path_specification(b, 0);
    }
    else if (t == MODULE_TRANSFORM_GROUP_SPECIFICATION) {
      r = module_transform_group_specification(b, 0);
    }
    else if (t == MODULUS_EXPRESSION) {
      r = modulus_expression(b, 0);
    }
    else if (t == MONTHS_VALUE) {
      r = months_value(b, 0);
    }
    else if (t == MULTIPLE_COLUMN_ASSIGNMENT) {
      r = multiple_column_assignment(b, 0);
    }
    else if (t == MULTIPLE_GROUP_SPECIFICATION) {
      r = multiple_group_specification(b, 0);
    }
    else if (t == MULTIPLIER) {
      r = multiplier(b, 0);
    }
    else if (t == MULTISET_ELEMENT) {
      r = multiset_element(b, 0);
    }
    else if (t == MULTISET_ELEMENT_LIST) {
      r = multiset_element_list(b, 0);
    }
    else if (t == MULTISET_ELEMENT_REFERENCE) {
      r = multiset_element_reference(b, 0);
    }
    else if (t == MULTISET_PRIMARY) {
      r = multiset_primary(b, 0);
    }
    else if (t == MULTISET_SET_FUNCTION) {
      r = multiset_set_function(b, 0);
    }
    else if (t == MULTISET_TERM) {
      r = multiset_term(b, 0);
    }
    else if (t == MULTISET_TYPE) {
      r = multiset_type(b, 0);
    }
    else if (t == MULTISET_VALUE_CONSTRUCTOR) {
      r = multiset_value_constructor(b, 0);
    }
    else if (t == MULTISET_VALUE_CONSTRUCTOR_BY_ENUMERATION) {
      r = multiset_value_constructor_by_enumeration(b, 0);
    }
    else if (t == MULTISET_VALUE_CONSTRUCTOR_BY_QUERY) {
      r = multiset_value_constructor_by_query(b, 0);
    }
    else if (t == MULTISET_VALUE_EXPRESSION) {
      r = multiset_value_expression(b, 0);
    }
    else if (t == MULTISET_VALUE_FUNCTION) {
      r = multiset_value_function(b, 0);
    }
    else if (t == MUTATED_SET_CLAUSE) {
      r = mutated_set_clause(b, 0);
    }
    else if (t == MUTATED_TARGET) {
      r = mutated_target(b, 0);
    }
    else if (t == NAMED_COLUMNS_JOIN) {
      r = named_columns_join(b, 0);
    }
    else if (t == NATIONAL_CHARACTER_STRING_LITERAL) {
      r = national_character_string_literal(b, 0);
    }
    else if (t == NATIONAL_CHARACTER_STRING_TYPE) {
      r = national_character_string_type(b, 0);
    }
    else if (t == NATURAL_JOIN) {
      r = natural_join(b, 0);
    }
    else if (t == NATURAL_LOGARITHM) {
      r = natural_logarithm(b, 0);
    }
    else if (t == NESTING_OPTION) {
      r = nesting_option(b, 0);
    }
    else if (t == NEW_INVOCATION) {
      r = new_invocation(b, 0);
    }
    else if (t == NEW_SPECIFICATION) {
      r = new_specification(b, 0);
    }
    else if (t == NEW_VALUES_CORRELATION_NAME) {
      r = new_values_correlation_name(b, 0);
    }
    else if (t == NEW_VALUES_TABLE_ALIAS) {
      r = new_values_table_alias(b, 0);
    }
    else if (t == NEW_WINDOW_NAME) {
      r = new_window_name(b, 0);
    }
    else if (t == NEXT_VALUE_EXPRESSION) {
      r = next_value_expression(b, 0);
    }
    else if (t == NON_CYCLE_MARK_VALUE) {
      r = non_cycle_mark_value(b, 0);
    }
    else if (t == NON_ESCAPED_CHARACTER) {
      r = non_escaped_character(b, 0);
    }
    else if (t == NON_JOIN_QUERY_EXPRESSION) {
      r = non_join_query_expression(b, 0);
    }
    else if (t == NON_JOIN_QUERY_PRIMARY) {
      r = non_join_query_primary(b, 0);
    }
    else if (t == NON_JOIN_QUERY_TERM) {
      r = non_join_query_term(b, 0);
    }
    else if (t == NON_RESERVED_WORD) {
      r = non_reserved_word(b, 0);
    }
    else if (t == NON_SECOND_PRIMARY_DATETIME_FIELD) {
      r = non_second_primary_datetime_field(b, 0);
    }
    else if (t == NONDELIMITER_TOKEN) {
      r = nondelimiter_token(b, 0);
    }
    else if (t == NONDOUBLEQUOTE_CHARACTER) {
      r = nondoublequote_character(b, 0);
    }
    else if (t == NONPARENTHESIZED_VALUE_EXPRESSION_PRIMARY) {
      r = nonparenthesized_value_expression_primary(b, 0);
    }
    else if (t == NONQUOTE_CHARACTER) {
      r = nonquote_character(b, 0);
    }
    else if (t == NORMALIZE_FUNCTION) {
      r = normalize_function(b, 0);
    }
    else if (t == NORMALIZED_PREDICATE) {
      r = normalized_predicate(b, 0);
    }
    else if (t == NOT_EQUALS_OPERATOR) {
      r = not_equals_operator(b, 0);
    }
    else if (t == NULL_ORDERING) {
      r = null_ordering(b, 0);
    }
    else if (t == NULL_PREDICATE) {
      r = null_predicate(b, 0);
    }
    else if (t == NULL_PREDICATE_PART_2) {
      r = null_predicate_part_2(b, 0);
    }
    else if (t == NULL_SPECIFICATION) {
      r = null_specification(b, 0);
    }
    else if (t == NULL_CALL_CLAUSE) {
      r = null_call_clause(b, 0);
    }
    else if (t == NUMBER_OF_CONDITIONS) {
      r = number_of_conditions(b, 0);
    }
    else if (t == NUMERIC_PRIMARY) {
      r = numeric_primary(b, 0);
    }
    else if (t == NUMERIC_TYPE) {
      r = numeric_type(b, 0);
    }
    else if (t == NUMERIC_VALUE_EXPRESSION) {
      r = numeric_value_expression(b, 0);
    }
    else if (t == NUMERIC_VALUE_EXPRESSION_BASE) {
      r = numeric_value_expression_base(b, 0);
    }
    else if (t == NUMERIC_VALUE_EXPRESSION_EXPONENT) {
      r = numeric_value_expression_exponent(b, 0);
    }
    else if (t == NUMERIC_VALUE_FUNCTION) {
      r = numeric_value_function(b, 0);
    }
    else if (t == OBJECT_COLUMN) {
      r = object_column(b, 0);
    }
    else if (t == OBJECT_NAME) {
      r = object_name(b, 0);
    }
    else if (t == OBJECT_PRIVILEGES) {
      r = object_privileges(b, 0);
    }
    else if (t == OCCURRENCES) {
      r = occurrences(b, 0);
    }
    else if (t == OCTET_LENGTH_EXPRESSION) {
      r = octet_length_expression(b, 0);
    }
    else if (t == OCTET_LIKE_PREDICATE) {
      r = octet_like_predicate(b, 0);
    }
    else if (t == OCTET_LIKE_PREDICATE_PART_2) {
      r = octet_like_predicate_part_2(b, 0);
    }
    else if (t == OCTET_PATTERN) {
      r = octet_pattern(b, 0);
    }
    else if (t == OLD_OR_NEW_VALUES_ALIAS) {
      r = old_or_new_values_alias(b, 0);
    }
    else if (t == OLD_OR_NEW_VALUES_ALIAS_LIST) {
      r = old_or_new_values_alias_list(b, 0);
    }
    else if (t == OLD_VALUES_CORRELATION_NAME) {
      r = old_values_correlation_name(b, 0);
    }
    else if (t == OLD_VALUES_TABLE_ALIAS) {
      r = old_values_table_alias(b, 0);
    }
    else if (t == ONLY_SPEC) {
      r = only_spec(b, 0);
    }
    else if (t == OPEN_STATEMENT) {
      r = open_statement(b, 0);
    }
    else if (t == ORDER_BY_CLAUSE) {
      r = order_by_clause(b, 0);
    }
    else if (t == ORDERED_SET_FUNCTION) {
      r = ordered_set_function(b, 0);
    }
    else if (t == ORDERING_CATEGORY) {
      r = ordering_category(b, 0);
    }
    else if (t == ORDERING_FORM) {
      r = ordering_form(b, 0);
    }
    else if (t == ORDERING_SPECIFICATION) {
      r = ordering_specification(b, 0);
    }
    else if (t == ORDINARY_GROUPING_SET) {
      r = ordinary_grouping_set(b, 0);
    }
    else if (t == ORDINARY_GROUPING_SET_LIST) {
      r = ordinary_grouping_set_list(b, 0);
    }
    else if (t == ORIGINAL_METHOD_SPECIFICATION) {
      r = original_method_specification(b, 0);
    }
    else if (t == OUTER_JOIN_TYPE) {
      r = outer_join_type(b, 0);
    }
    else if (t == OUTPUT_USING_CLAUSE) {
      r = output_using_clause(b, 0);
    }
    else if (t == OVERLAPS_PREDICATE) {
      r = overlaps_predicate(b, 0);
    }
    else if (t == OVERLAPS_PREDICATE_PART_1) {
      r = overlaps_predicate_part_1(b, 0);
    }
    else if (t == OVERLAPS_PREDICATE_PART_2) {
      r = overlaps_predicate_part_2(b, 0);
    }
    else if (t == OVERRIDE_CLAUSE) {
      r = override_clause(b, 0);
    }
    else if (t == OVERRIDING_METHOD_SPECIFICATION) {
      r = overriding_method_specification(b, 0);
    }
    else if (t == PAD_CHARACTERISTIC) {
      r = pad_characteristic(b, 0);
    }
    else if (t == PARAMETER_MODE) {
      r = parameter_mode(b, 0);
    }
    else if (t == PARAMETER_STYLE) {
      r = parameter_style(b, 0);
    }
    else if (t == PARAMETER_STYLE_CLAUSE) {
      r = parameter_style_clause(b, 0);
    }
    else if (t == PARAMETER_TYPE) {
      r = parameter_type(b, 0);
    }
    else if (t == PARAMETER_USING_CLAUSE) {
      r = parameter_using_clause(b, 0);
    }
    else if (t == PARENTHESIZED_BOOLEAN_VALUE_EXPRESSION) {
      r = parenthesized_boolean_value_expression(b, 0);
    }
    else if (t == PARENTHESIZED_VALUE_EXPRESSION) {
      r = parenthesized_value_expression(b, 0);
    }
    else if (t == PARTIAL_METHOD_SPECIFICATION) {
      r = partial_method_specification(b, 0);
    }
    else if (t == PATH_COLUMN) {
      r = path_column(b, 0);
    }
    else if (t == PATH_SPECIFICATION) {
      r = path_specification(b, 0);
    }
    else if (t == PATH_RESOLVED_USER_DEFINED_TYPE_NAME) {
      r = path_resolved_user_defined_type_name(b, 0);
    }
    else if (t == PERCENT) {
      r = percent(b, 0);
    }
    else if (t == PERIOD) {
      r = period(b, 0);
    }
    else if (t == PLUS_SIGN) {
      r = plus_sign(b, 0);
    }
    else if (t == POSITION_EXPRESSION) {
      r = position_expression(b, 0);
    }
    else if (t == POWER_FUNCTION) {
      r = power_function(b, 0);
    }
    else if (t == PRECISION) {
      r = precision(b, 0);
    }
    else if (t == PREDEFINED_TYPE) {
      r = predefined_type(b, 0);
    }
    else if (t == PREDICATE) {
      r = predicate(b, 0);
    }
    else if (t == PREPARABLE_SQL_CONTROL_STATEMENT) {
      r = preparable_SQL_control_statement(b, 0);
    }
    else if (t == PREPARABLE_SQL_DATA_STATEMENT) {
      r = preparable_SQL_data_statement(b, 0);
    }
    else if (t == PREPARABLE_SQL_SCHEMA_STATEMENT) {
      r = preparable_SQL_schema_statement(b, 0);
    }
    else if (t == PREPARABLE_SQL_SESSION_STATEMENT) {
      r = preparable_SQL_session_statement(b, 0);
    }
    else if (t == PREPARABLE_SQL_TRANSACTION_STATEMENT) {
      r = preparable_SQL_transaction_statement(b, 0);
    }
    else if (t == PREPARABLE_DYNAMIC_DELETE_STATEMENT_POSITIONED) {
      r = preparable_dynamic_delete_statement_positioned(b, 0);
    }
    else if (t == PREPARABLE_DYNAMIC_UPDATE_STATEMENT_POSITIONED) {
      r = preparable_dynamic_update_statement_positioned(b, 0);
    }
    else if (t == PREPARABLE_IMPLEMENTATION_DEFINED_STATEMENT) {
      r = preparable_implementation_defined_statement(b, 0);
    }
    else if (t == PREPARABLE_STATEMENT) {
      r = preparable_statement(b, 0);
    }
    else if (t == PREPARE_STATEMENT) {
      r = prepare_statement(b, 0);
    }
    else if (t == PRIMARY_DATETIME_FIELD) {
      r = primary_datetime_field(b, 0);
    }
    else if (t == PRIVILEGE_COLUMN_LIST) {
      r = privilege_column_list(b, 0);
    }
    else if (t == PRIVILEGE_METHOD_LIST) {
      r = privilege_method_list(b, 0);
    }
    else if (t == PRIVILEGES) {
      r = privileges(b, 0);
    }
    else if (t == PROCEDURE_NAME) {
      r = procedure_name(b, 0);
    }
    else if (t == QUALIFIED_ASTERISK) {
      r = qualified_asterisk(b, 0);
    }
    else if (t == QUALIFIED_IDENTIFIER) {
      r = qualified_identifier(b, 0);
    }
    else if (t == QUALIFIED_JOIN) {
      r = qualified_join(b, 0);
    }
    else if (t == QUANTIFIED_COMPARISON_PREDICATE) {
      r = quantified_comparison_predicate(b, 0);
    }
    else if (t == QUANTIFIED_COMPARISON_PREDICATE_PART_2) {
      r = quantified_comparison_predicate_part_2(b, 0);
    }
    else if (t == QUANTIFIER) {
      r = quantifier(b, 0);
    }
    else if (t == QUERY_EXPRESSION) {
      r = query_expression(b, 0);
    }
    else if (t == QUERY_EXPRESSION_BODY) {
      r = query_expression_body(b, 0);
    }
    else if (t == QUERY_NAME) {
      r = query_name(b, 0);
    }
    else if (t == QUERY_PRIMARY) {
      r = query_primary(b, 0);
    }
    else if (t == QUERY_SPECIFICATION) {
      r = query_specification(b, 0);
    }
    else if (t == QUERY_TERM) {
      r = query_term(b, 0);
    }
    else if (t == QUESTION_MARK) {
      r = question_mark(b, 0);
    }
    else if (t == QUOTE) {
      r = quote(b, 0);
    }
    else if (t == QUOTE_SYMBOL) {
      r = quote_symbol(b, 0);
    }
    else if (t == RANK_FUNCTION_TYPE) {
      r = rank_function_type(b, 0);
    }
    else if (t == RECURSIVE_SEARCH_ORDER) {
      r = recursive_search_order(b, 0);
    }
    else if (t == REF_CAST_OPTION) {
      r = ref_cast_option(b, 0);
    }
    else if (t == REFERENCE_COLUMN_LIST) {
      r = reference_column_list(b, 0);
    }
    else if (t == REFERENCE_GENERATION) {
      r = reference_generation(b, 0);
    }
    else if (t == REFERENCE_RESOLUTION) {
      r = reference_resolution(b, 0);
    }
    else if (t == REFERENCE_SCOPE_CHECK) {
      r = reference_scope_check(b, 0);
    }
    else if (t == REFERENCE_SCOPE_CHECK_ACTION) {
      r = reference_scope_check_action(b, 0);
    }
    else if (t == REFERENCE_TYPE) {
      r = reference_type(b, 0);
    }
    else if (t == REFERENCE_TYPE_SPECIFICATION) {
      r = reference_type_specification(b, 0);
    }
    else if (t == REFERENCE_VALUE_EXPRESSION) {
      r = reference_value_expression(b, 0);
    }
    else if (t == REFERENCEABLE_VIEW_SPECIFICATION) {
      r = referenceable_view_specification(b, 0);
    }
    else if (t == REFERENCED_TABLE_AND_COLUMNS) {
      r = referenced_table_and_columns(b, 0);
    }
    else if (t == REFERENCED_TYPE) {
      r = referenced_type(b, 0);
    }
    else if (t == REFERENCES_SPECIFICATION) {
      r = references_specification(b, 0);
    }
    else if (t == REFERENCING_COLUMNS) {
      r = referencing_columns(b, 0);
    }
    else if (t == REFERENTIAL_ACTION) {
      r = referential_action(b, 0);
    }
    else if (t == REFERENTIAL_CONSTRAINT_DEFINITION) {
      r = referential_constraint_definition(b, 0);
    }
    else if (t == REFERENTIAL_TRIGGERED_ACTION) {
      r = referential_triggered_action(b, 0);
    }
    else if (t == REGULAR_CHARACTER_SET) {
      r = regular_character_set(b, 0);
    }
    else if (t == REGULAR_CHARACTER_SET_IDENTIFIER) {
      r = regular_character_set_identifier(b, 0);
    }
    else if (t == REGULAR_EXPRESSION) {
      r = regular_expression(b, 0);
    }
    else if (t == REGULAR_EXPRESSION_SUBSTRING_FUNCTION) {
      r = regular_expression_substring_function(b, 0);
    }
    else if (t == REGULAR_FACTOR) {
      r = regular_factor(b, 0);
    }
    else if (t == REGULAR_IDENTIFIER) {
      r = regular_identifier(b, 0);
    }
    else if (t == REGULAR_PRIMARY) {
      r = regular_primary(b, 0);
    }
    else if (t == REGULAR_TERM) {
      r = regular_term(b, 0);
    }
    else if (t == REGULAR_VIEW_SPECIFICATION) {
      r = regular_view_specification(b, 0);
    }
    else if (t == RELATIVE_CATEGORY) {
      r = relative_category(b, 0);
    }
    else if (t == RELATIVE_FUNCTION_SPECIFICATION) {
      r = relative_function_specification(b, 0);
    }
    else if (t == RELEASE_SAVEPOINT_STATEMENT) {
      r = release_savepoint_statement(b, 0);
    }
    else if (t == REPEAT_ARGUMENT) {
      r = repeat_argument(b, 0);
    }
    else if (t == REPEAT_FACTOR) {
      r = repeat_factor(b, 0);
    }
    else if (t == REPEATABLE_CLAUSE) {
      r = repeatable_clause(b, 0);
    }
    else if (t == REPRESENTATION) {
      r = representation(b, 0);
    }
    else if (t == RESERVED_WORD) {
      r = reserved_word(b, 0);
    }
    else if (t == RESULT) {
      r = result(b, 0);
    }
    else if (t == RESULT_CAST) {
      r = result_cast(b, 0);
    }
    else if (t == RESULT_CAST_FROM_TYPE) {
      r = result_cast_from_type(b, 0);
    }
    else if (t == RESULT_EXPRESSION) {
      r = result_expression(b, 0);
    }
    else if (t == RESULT_SET_CURSOR) {
      r = result_set_cursor(b, 0);
    }
    else if (t == RESULT_USING_CLAUSE) {
      r = result_using_clause(b, 0);
    }
    else if (t == RETURN_STATEMENT) {
      r = return_statement(b, 0);
    }
    else if (t == RETURN_VALUE) {
      r = return_value(b, 0);
    }
    else if (t == RETURNS_CLAUSE) {
      r = returns_clause(b, 0);
    }
    else if (t == RETURNS_DATA_TYPE) {
      r = returns_data_type(b, 0);
    }
    else if (t == RETURNS_TABLE_TYPE) {
      r = returns_table_type(b, 0);
    }
    else if (t == RETURNS_TYPE) {
      r = returns_type(b, 0);
    }
    else if (t == REVOKE_OPTION_EXTENSION) {
      r = revoke_option_extension(b, 0);
    }
    else if (t == REVOKE_PRIVILEGE_STATEMENT) {
      r = revoke_privilege_statement(b, 0);
    }
    else if (t == REVOKE_ROLE_STATEMENT) {
      r = revoke_role_statement(b, 0);
    }
    else if (t == REVOKE_STATEMENT) {
      r = revoke_statement(b, 0);
    }
    else if (t == RIGHT_ARROW) {
      r = right_arrow(b, 0);
    }
    else if (t == RIGHT_BRACE) {
      r = right_brace(b, 0);
    }
    else if (t == RIGHT_BRACKET_OR_TRIGRAPH) {
      r = right_bracket_or_trigraph(b, 0);
    }
    else if (t == RIGHT_PAREN) {
      r = right_paren(b, 0);
    }
    else if (t == RIGHTS_CLAUSE) {
      r = rights_clause(b, 0);
    }
    else if (t == ROLE_DEFINITION) {
      r = role_definition(b, 0);
    }
    else if (t == ROLE_GRANTED) {
      r = role_granted(b, 0);
    }
    else if (t == ROLE_NAME) {
      r = role_name(b, 0);
    }
    else if (t == ROLE_REVOKED) {
      r = role_revoked(b, 0);
    }
    else if (t == ROLE_SPECIFICATION) {
      r = role_specification(b, 0);
    }
    else if (t == ROLLBACK_STATEMENT) {
      r = rollback_statement(b, 0);
    }
    else if (t == ROLLUP_LIST) {
      r = rollup_list(b, 0);
    }
    else if (t == ROUTINE_BODY) {
      r = routine_body(b, 0);
    }
    else if (t == ROUTINE_CHARACTERISTIC) {
      r = routine_characteristic(b, 0);
    }
    else if (t == ROUTINE_CHARACTERISTICS) {
      r = routine_characteristics(b, 0);
    }
    else if (t == ROUTINE_INVOCATION) {
      r = routine_invocation(b, 0);
    }
    else if (t == ROUTINE_NAME) {
      r = routine_name(b, 0);
    }
    else if (t == ROUTINE_TYPE) {
      r = routine_type(b, 0);
    }
    else if (t == ROW_SUBQUERY) {
      r = row_subquery(b, 0);
    }
    else if (t == ROW_TYPE) {
      r = row_type(b, 0);
    }
    else if (t == ROW_TYPE_BODY) {
      r = row_type_body(b, 0);
    }
    else if (t == ROW_VALUE_CONSTRUCTOR) {
      r = row_value_constructor(b, 0);
    }
    else if (t == ROW_VALUE_CONSTRUCTOR_ELEMENT) {
      r = row_value_constructor_element(b, 0);
    }
    else if (t == ROW_VALUE_CONSTRUCTOR_ELEMENT_LIST) {
      r = row_value_constructor_element_list(b, 0);
    }
    else if (t == ROW_VALUE_CONSTRUCTOR_PREDICAND) {
      r = row_value_constructor_predicand(b, 0);
    }
    else if (t == ROW_VALUE_EXPRESSION) {
      r = row_value_expression(b, 0);
    }
    else if (t == ROW_VALUE_EXPRESSION_LIST) {
      r = row_value_expression_list(b, 0);
    }
    else if (t == ROW_VALUE_PREDICAND) {
      r = row_value_predicand(b, 0);
    }
    else if (t == ROW_VALUE_PREDICAND_1) {
      r = row_value_predicand_1(b, 0);
    }
    else if (t == ROW_VALUE_PREDICAND_2) {
      r = row_value_predicand_2(b, 0);
    }
    else if (t == ROW_VALUE_PREDICAND_3) {
      r = row_value_predicand_3(b, 0);
    }
    else if (t == ROW_VALUE_PREDICAND_4) {
      r = row_value_predicand_4(b, 0);
    }
    else if (t == ROW_VALUE_SPECIAL_CASE) {
      r = row_value_special_case(b, 0);
    }
    else if (t == SAMPLE_CLAUSE) {
      r = sample_clause(b, 0);
    }
    else if (t == SAMPLE_METHOD) {
      r = sample_method(b, 0);
    }
    else if (t == SAMPLE_PERCENTAGE) {
      r = sample_percentage(b, 0);
    }
    else if (t == SAVEPOINT_CLAUSE) {
      r = savepoint_clause(b, 0);
    }
    else if (t == SAVEPOINT_LEVEL_INDICATION) {
      r = savepoint_level_indication(b, 0);
    }
    else if (t == SAVEPOINT_NAME) {
      r = savepoint_name(b, 0);
    }
    else if (t == SAVEPOINT_SPECIFIER) {
      r = savepoint_specifier(b, 0);
    }
    else if (t == SAVEPOINT_STATEMENT) {
      r = savepoint_statement(b, 0);
    }
    else if (t == SCALAR_SUBQUERY) {
      r = scalar_subquery(b, 0);
    }
    else if (t == SCALE) {
      r = scale(b, 0);
    }
    else if (t == SCHEMA_AUTHORIZATION_IDENTIFIER) {
      r = schema_authorization_identifier(b, 0);
    }
    else if (t == SCHEMA_CHARACTER_SET_OR_PATH) {
      r = schema_character_set_or_path(b, 0);
    }
    else if (t == SCHEMA_CHARACTER_SET_SPECIFICATION) {
      r = schema_character_set_specification(b, 0);
    }
    else if (t == SCHEMA_DEFINITION) {
      r = schema_definition(b, 0);
    }
    else if (t == SCHEMA_ELEMENT) {
      r = schema_element(b, 0);
    }
    else if (t == SCHEMA_FUNCTION) {
      r = schema_function(b, 0);
    }
    else if (t == SCHEMA_NAME) {
      r = schema_name(b, 0);
    }
    else if (t == SCHEMA_NAME_CHARACTERISTIC) {
      r = schema_name_characteristic(b, 0);
    }
    else if (t == SCHEMA_NAME_CLAUSE) {
      r = schema_name_clause(b, 0);
    }
    else if (t == SCHEMA_NAME_LIST) {
      r = schema_name_list(b, 0);
    }
    else if (t == SCHEMA_PATH_SPECIFICATION) {
      r = schema_path_specification(b, 0);
    }
    else if (t == SCHEMA_PROCEDURE) {
      r = schema_procedure(b, 0);
    }
    else if (t == SCHEMA_QUALIFIED_NAME) {
      r = schema_qualified_name(b, 0);
    }
    else if (t == SCHEMA_QUALIFIED_ROUTINE_NAME) {
      r = schema_qualified_routine_name(b, 0);
    }
    else if (t == SCHEMA_QUALIFIED_TYPE_NAME) {
      r = schema_qualified_type_name(b, 0);
    }
    else if (t == SCHEMA_ROUTINE) {
      r = schema_routine(b, 0);
    }
    else if (t == SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME) {
      r = schema_resolved_user_defined_type_name(b, 0);
    }
    else if (t == SCOPE_CLAUSE) {
      r = scope_clause(b, 0);
    }
    else if (t == SCOPE_OPTION) {
      r = scope_option(b, 0);
    }
    else if (t == SEARCH_CLAUSE) {
      r = search_clause(b, 0);
    }
    else if (t == SEARCH_CONDITION) {
      r = search_condition(b, 0);
    }
    else if (t == SEARCH_OR_CYCLE_CLAUSE) {
      r = search_or_cycle_clause(b, 0);
    }
    else if (t == SEARCHED_CASE) {
      r = searched_case(b, 0);
    }
    else if (t == SEARCHED_WHEN_CLAUSE) {
      r = searched_when_clause(b, 0);
    }
    else if (t == SECONDS_FRACTION) {
      r = seconds_fraction(b, 0);
    }
    else if (t == SECONDS_INTEGER_VALUE) {
      r = seconds_integer_value(b, 0);
    }
    else if (t == SECONDS_VALUE) {
      r = seconds_value(b, 0);
    }
    else if (t == SELECT_LIST) {
      r = select_list(b, 0);
    }
    else if (t == SELECT_STATEMENT_SINGLE_ROW) {
      r = select_statement_single_row(b, 0);
    }
    else if (t == SELECT_SUBLIST) {
      r = select_sublist(b, 0);
    }
    else if (t == SELECT_TARGET_LIST) {
      r = select_target_list(b, 0);
    }
    else if (t == SELF_REFERENCING_COLUMN_NAME) {
      r = self_referencing_column_name(b, 0);
    }
    else if (t == SELF_REFERENCING_COLUMN_SPECIFICATION) {
      r = self_referencing_column_specification(b, 0);
    }
    else if (t == SEMICOLON) {
      r = semicolon(b, 0);
    }
    else if (t == SEPARATOR) {
      r = separator(b, 0);
    }
    else if (t == SEQUENCE_COLUMN) {
      r = sequence_column(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_CYCLE_OPTION) {
      r = sequence_generator_cycle_option(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_DATA_TYPE_OPTION) {
      r = sequence_generator_data_type_option(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_DEFINITION) {
      r = sequence_generator_definition(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_INCREMENT) {
      r = sequence_generator_increment(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_INCREMENT_BY_OPTION) {
      r = sequence_generator_increment_by_option(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_MAX_VALUE) {
      r = sequence_generator_max_value(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_MAXVALUE_OPTION) {
      r = sequence_generator_maxvalue_option(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_MIN_VALUE) {
      r = sequence_generator_min_value(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_MINVALUE_OPTION) {
      r = sequence_generator_minvalue_option(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_NAME) {
      r = sequence_generator_name(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_OPTION) {
      r = sequence_generator_option(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_OPTIONS) {
      r = sequence_generator_options(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_RESTART_VALUE) {
      r = sequence_generator_restart_value(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_START_VALUE) {
      r = sequence_generator_start_value(b, 0);
    }
    else if (t == SEQUENCE_GENERATOR_START_WITH_OPTION) {
      r = sequence_generator_start_with_option(b, 0);
    }
    else if (t == SESSION_CHARACTERISTIC) {
      r = session_characteristic(b, 0);
    }
    else if (t == SESSION_CHARACTERISTIC_LIST) {
      r = session_characteristic_list(b, 0);
    }
    else if (t == SET_CATALOG_STATEMENT) {
      r = set_catalog_statement(b, 0);
    }
    else if (t == SET_CLAUSE) {
      r = set_clause(b, 0);
    }
    else if (t == SET_CLAUSE_LIST) {
      r = set_clause_list(b, 0);
    }
    else if (t == SET_COLUMN_DEFAULT_CLAUSE) {
      r = set_column_default_clause(b, 0);
    }
    else if (t == SET_CONNECTION_STATEMENT) {
      r = set_connection_statement(b, 0);
    }
    else if (t == SET_CONSTRAINTS_MODE_STATEMENT) {
      r = set_constraints_mode_statement(b, 0);
    }
    else if (t == SET_DESCRIPTOR_INFORMATION) {
      r = set_descriptor_information(b, 0);
    }
    else if (t == SET_DOMAIN_DEFAULT_CLAUSE) {
      r = set_domain_default_clause(b, 0);
    }
    else if (t == SET_FUNCTION_SPECIFICATION) {
      r = set_function_specification(b, 0);
    }
    else if (t == SET_FUNCTION_TYPE) {
      r = set_function_type(b, 0);
    }
    else if (t == SET_HEADER_INFORMATION) {
      r = set_header_information(b, 0);
    }
    else if (t == SET_ITEM_INFORMATION) {
      r = set_item_information(b, 0);
    }
    else if (t == SET_LOCAL_TIME_ZONE_STATEMENT) {
      r = set_local_time_zone_statement(b, 0);
    }
    else if (t == SET_NAMES_STATEMENT) {
      r = set_names_statement(b, 0);
    }
    else if (t == SET_PATH_STATEMENT) {
      r = set_path_statement(b, 0);
    }
    else if (t == SET_PREDICATE) {
      r = set_predicate(b, 0);
    }
    else if (t == SET_PREDICATE_PART_2) {
      r = set_predicate_part_2(b, 0);
    }
    else if (t == SET_QUANTIFIER) {
      r = set_quantifier(b, 0);
    }
    else if (t == SET_ROLE_STATEMENT) {
      r = set_role_statement(b, 0);
    }
    else if (t == SET_SCHEMA_STATEMENT) {
      r = set_schema_statement(b, 0);
    }
    else if (t == SET_SESSION_CHARACTERISTICS_STATEMENT) {
      r = set_session_characteristics_statement(b, 0);
    }
    else if (t == SET_SESSION_COLLATION_STATEMENT) {
      r = set_session_collation_statement(b, 0);
    }
    else if (t == SET_SESSION_USER_IDENTIFIER_STATEMENT) {
      r = set_session_user_identifier_statement(b, 0);
    }
    else if (t == SET_TARGET) {
      r = set_target(b, 0);
    }
    else if (t == SET_TARGET_LIST) {
      r = set_target_list(b, 0);
    }
    else if (t == SET_TIME_ZONE_VALUE) {
      r = set_time_zone_value(b, 0);
    }
    else if (t == SET_TRANSACTION_STATEMENT) {
      r = set_transaction_statement(b, 0);
    }
    else if (t == SET_TRANSFORM_GROUP_STATEMENT) {
      r = set_transform_group_statement(b, 0);
    }
    else if (t == SIGN) {
      r = sign(b, 0);
    }
    else if (t == SIGNED_INTEGER) {
      r = signed_integer(b, 0);
    }
    else if (t == SIGNED_NUMERIC_LITERAL) {
      r = signed_numeric_literal(b, 0);
    }
    else if (t == SIMILAR_PATTERN) {
      r = similar_pattern(b, 0);
    }
    else if (t == SIMILAR_PREDICATE) {
      r = similar_predicate(b, 0);
    }
    else if (t == SIMILAR_PREDICATE_PART_2) {
      r = similar_predicate_part_2(b, 0);
    }
    else if (t == SIMPLE_LATIN_LETTER) {
      r = simple_Latin_letter(b, 0);
    }
    else if (t == SIMPLE_LATIN_LOWER_CASE_LETTER) {
      r = simple_Latin_lower_case_letter(b, 0);
    }
    else if (t == SIMPLE_LATIN_UPPER_CASE_LETTER) {
      r = simple_Latin_upper_case_letter(b, 0);
    }
    else if (t == SIMPLE_CASE) {
      r = simple_case(b, 0);
    }
    else if (t == SIMPLE_COMMENT) {
      r = simple_comment(b, 0);
    }
    else if (t == SIMPLE_COMMENT_INTRODUCER) {
      r = simple_comment_introducer(b, 0);
    }
    else if (t == SIMPLE_TABLE) {
      r = simple_table(b, 0);
    }
    else if (t == SIMPLE_TARGET_SPECIFICATION) {
      r = simple_target_specification(b, 0);
    }
    else if (t == SIMPLE_TARGET_SPECIFICATION_1) {
      r = simple_target_specification_1(b, 0);
    }
    else if (t == SIMPLE_TARGET_SPECIFICATION_2) {
      r = simple_target_specification_2(b, 0);
    }
    else if (t == SIMPLE_VALUE_SPECIFICATION) {
      r = simple_value_specification(b, 0);
    }
    else if (t == SIMPLE_VALUE_SPECIFICATION_1) {
      r = simple_value_specification_1(b, 0);
    }
    else if (t == SIMPLE_VALUE_SPECIFICATION_2) {
      r = simple_value_specification_2(b, 0);
    }
    else if (t == SIMPLE_WHEN_CLAUSE) {
      r = simple_when_clause(b, 0);
    }
    else if (t == SINGLE_DATETIME_FIELD) {
      r = single_datetime_field(b, 0);
    }
    else if (t == SINGLE_GROUP_SPECIFICATION) {
      r = single_group_specification(b, 0);
    }
    else if (t == SOLIDUS) {
      r = solidus(b, 0);
    }
    else if (t == SOME) {
      r = some(b, 0);
    }
    else if (t == SORT_KEY) {
      r = sort_key(b, 0);
    }
    else if (t == SORT_SPECIFICATION) {
      r = sort_specification(b, 0);
    }
    else if (t == SORT_SPECIFICATION_LIST) {
      r = sort_specification_list(b, 0);
    }
    else if (t == SOURCE_CHARACTER_SET_SPECIFICATION) {
      r = source_character_set_specification(b, 0);
    }
    else if (t == SOURCE_DATA_TYPE) {
      r = source_data_type(b, 0);
    }
    else if (t == SPACE) {
      r = space(b, 0);
    }
    else if (t == SPECIFIC_METHOD_NAME) {
      r = specific_method_name(b, 0);
    }
    else if (t == SPECIFIC_METHOD_SPECIFICATION_DESIGNATOR) {
      r = specific_method_specification_designator(b, 0);
    }
    else if (t == SPECIFIC_NAME) {
      r = specific_name(b, 0);
    }
    else if (t == SPECIFIC_ROUTINE_DESIGNATOR) {
      r = specific_routine_designator(b, 0);
    }
    else if (t == SPECIFIC_TYPE_METHOD) {
      r = specific_type_method(b, 0);
    }
    else if (t == SQUARE_ROOT) {
      r = square_root(b, 0);
    }
    else if (t == STANDARD_CHARACTER_SET_NAME) {
      r = standard_character_set_name(b, 0);
    }
    else if (t == START_FIELD) {
      r = start_field(b, 0);
    }
    else if (t == START_POSITION) {
      r = start_position(b, 0);
    }
    else if (t == START_TRANSACTION_STATEMENT) {
      r = start_transaction_statement(b, 0);
    }
    else if (t == STATE_CATEGORY) {
      r = state_category(b, 0);
    }
    else if (t == STATEMENT_CURSOR) {
      r = statement_cursor(b, 0);
    }
    else if (t == STATEMENT_INFORMATION) {
      r = statement_information(b, 0);
    }
    else if (t == STATEMENT_INFORMATION_ITEM) {
      r = statement_information_item(b, 0);
    }
    else if (t == STATEMENT_INFORMATION_ITEM_NAME) {
      r = statement_information_item_name(b, 0);
    }
    else if (t == STATEMENT_NAME) {
      r = statement_name(b, 0);
    }
    else if (t == STATEMENT_OR_DECLARATION) {
      r = statement_or_declaration(b, 0);
    }
    else if (t == STATIC_METHOD_INVOCATION) {
      r = static_method_invocation(b, 0);
    }
    else if (t == STATIC_METHOD_SELECTION) {
      r = static_method_selection(b, 0);
    }
    else if (t == STATUS_PARAMETER) {
      r = status_parameter(b, 0);
    }
    else if (t == STRING_LENGTH) {
      r = string_length(b, 0);
    }
    else if (t == STRING_POSITION_EXPRESSION) {
      r = string_position_expression(b, 0);
    }
    else if (t == STRING_VALUE_EXPRESSION) {
      r = string_value_expression(b, 0);
    }
    else if (t == STRING_VALUE_FUNCTION) {
      r = string_value_function(b, 0);
    }
    else if (t == SUBMULTISET_PREDICATE) {
      r = submultiset_predicate(b, 0);
    }
    else if (t == SUBMULTISET_PREDICATE_PART_2) {
      r = submultiset_predicate_part_2(b, 0);
    }
    else if (t == SUBQUERY) {
      r = subquery(b, 0);
    }
    else if (t == SUBTABLE_CLAUSE) {
      r = subtable_clause(b, 0);
    }
    else if (t == SUBTYPE_CLAUSE) {
      r = subtype_clause(b, 0);
    }
    else if (t == SUBTYPE_OPERAND) {
      r = subtype_operand(b, 0);
    }
    else if (t == SUBTYPE_TREATMENT) {
      r = subtype_treatment(b, 0);
    }
    else if (t == SUBVIEW_CLAUSE) {
      r = subview_clause(b, 0);
    }
    else if (t == SUPERTABLE_CLAUSE) {
      r = supertable_clause(b, 0);
    }
    else if (t == SUPERTABLE_NAME) {
      r = supertable_name(b, 0);
    }
    else if (t == SUPERTYPE_NAME) {
      r = supertype_name(b, 0);
    }
    else if (t == SYSTEM_DESCRIPTOR_STATEMENT) {
      r = system_descriptor_statement(b, 0);
    }
    else if (t == SYSTEM_GENERATED_REPRESENTATION) {
      r = system_generated_representation(b, 0);
    }
    else if (t == TABLE_COMMIT_ACTION) {
      r = table_commit_action(b, 0);
    }
    else if (t == TABLE_CONSTRAINT) {
      r = table_constraint(b, 0);
    }
    else if (t == TABLE_CONSTRAINT_DEFINITION) {
      r = table_constraint_definition(b, 0);
    }
    else if (t == TABLE_CONTENTS_SOURCE) {
      r = table_contents_source(b, 0);
    }
    else if (t == TABLE_DEFINITION) {
      r = table_definition(b, 0);
    }
    else if (t == TABLE_ELEMENT) {
      r = table_element(b, 0);
    }
    else if (t == TABLE_ELEMENT_LIST) {
      r = table_element_list(b, 0);
    }
    else if (t == TABLE_EXPRESSION) {
      r = table_expression(b, 0);
    }
    else if (t == TABLE_FUNCTION_COLUMN_LIST) {
      r = table_function_column_list(b, 0);
    }
    else if (t == TABLE_FUNCTION_COLUMN_LIST_ELEMENT) {
      r = table_function_column_list_element(b, 0);
    }
    else if (t == TABLE_FUNCTION_DERIVED_TABLE) {
      r = table_function_derived_table(b, 0);
    }
    else if (t == TABLE_NAME) {
      r = table_name(b, 0);
    }
    else if (t == TABLE_OR_QUERY_NAME) {
      r = table_or_query_name(b, 0);
    }
    else if (t == TABLE_PRIMARY) {
      r = table_primary(b, 0);
    }
    else if (t == TABLE_PRIMARY_OR_JOINED_TABLE) {
      r = table_primary_or_joined_table(b, 0);
    }
    else if (t == TABLE_REFERENCE) {
      r = table_reference(b, 0);
    }
    else if (t == TABLE_REFERENCE_LIST) {
      r = table_reference_list(b, 0);
    }
    else if (t == TABLE_ROW_VALUE_EXPRESSION) {
      r = table_row_value_expression(b, 0);
    }
    else if (t == TABLE_SCOPE) {
      r = table_scope(b, 0);
    }
    else if (t == TABLE_SUBQUERY) {
      r = table_subquery(b, 0);
    }
    else if (t == TABLE_VALUE_CONSTRUCTOR) {
      r = table_value_constructor(b, 0);
    }
    else if (t == TABLE_VALUE_CONSTRUCTOR_BY_QUERY) {
      r = table_value_constructor_by_query(b, 0);
    }
    else if (t == TARGET_ARRAY_ELEMENT_SPECIFICATION) {
      r = target_array_element_specification(b, 0);
    }
    else if (t == TARGET_ARRAY_REFERENCE) {
      r = target_array_reference(b, 0);
    }
    else if (t == TARGET_CHARACTER_SET_SPECIFICATION) {
      r = target_character_set_specification(b, 0);
    }
    else if (t == TARGET_DATA_TYPE) {
      r = target_data_type(b, 0);
    }
    else if (t == TARGET_SPECIFICATION) {
      r = target_specification(b, 0);
    }
    else if (t == TARGET_SUBTYPE) {
      r = target_subtype(b, 0);
    }
    else if (t == TARGET_TABLE) {
      r = target_table(b, 0);
    }
    else if (t == TEMPORARY_TABLE_DECLARATION) {
      r = temporary_table_declaration(b, 0);
    }
    else if (t == TERM) {
      r = term(b, 0);
    }
    else if (t == TIME_FRACTIONAL_SECONDS_PRECISION) {
      r = time_fractional_seconds_precision(b, 0);
    }
    else if (t == TIME_INTERVAL) {
      r = time_interval(b, 0);
    }
    else if (t == TIME_LITERAL) {
      r = time_literal(b, 0);
    }
    else if (t == TIME_PRECISION) {
      r = time_precision(b, 0);
    }
    else if (t == TIME_STRING) {
      r = time_string(b, 0);
    }
    else if (t == TIME_VALUE) {
      r = time_value(b, 0);
    }
    else if (t == TIME_ZONE) {
      r = time_zone(b, 0);
    }
    else if (t == TIME_ZONE_FIELD) {
      r = time_zone_field(b, 0);
    }
    else if (t == TIME_ZONE_INTERVAL) {
      r = time_zone_interval(b, 0);
    }
    else if (t == TIME_ZONE_SPECIFIER) {
      r = time_zone_specifier(b, 0);
    }
    else if (t == TIMESTAMP_LITERAL) {
      r = timestamp_literal(b, 0);
    }
    else if (t == TIMESTAMP_PRECISION) {
      r = timestamp_precision(b, 0);
    }
    else if (t == TIMESTAMP_STRING) {
      r = timestamp_string(b, 0);
    }
    else if (t == TO_SQL) {
      r = to_sql(b, 0);
    }
    else if (t == TO_SQL_FUNCTION) {
      r = to_sql_function(b, 0);
    }
    else if (t == TOKEN) {
      r = token(b, 0);
    }
    else if (t == TRANSACTION_ACCESS_MODE) {
      r = transaction_access_mode(b, 0);
    }
    else if (t == TRANSACTION_CHARACTERISTICS) {
      r = transaction_characteristics(b, 0);
    }
    else if (t == TRANSACTION_MODE) {
      r = transaction_mode(b, 0);
    }
    else if (t == TRANSCODING) {
      r = transcoding(b, 0);
    }
    else if (t == TRANSCODING_NAME) {
      r = transcoding_name(b, 0);
    }
    else if (t == TRANSFORM_DEFINITION) {
      r = transform_definition(b, 0);
    }
    else if (t == TRANSFORM_ELEMENT) {
      r = transform_element(b, 0);
    }
    else if (t == TRANSFORM_ELEMENT_LIST) {
      r = transform_element_list(b, 0);
    }
    else if (t == TRANSFORM_GROUP) {
      r = transform_group(b, 0);
    }
    else if (t == TRANSFORM_GROUP_CHARACTERISTIC) {
      r = transform_group_characteristic(b, 0);
    }
    else if (t == TRANSFORM_GROUP_ELEMENT) {
      r = transform_group_element(b, 0);
    }
    else if (t == TRANSFORM_GROUP_SPECIFICATION) {
      r = transform_group_specification(b, 0);
    }
    else if (t == TRANSFORM_KIND) {
      r = transform_kind(b, 0);
    }
    else if (t == TRANSFORMS_TO_BE_DROPPED) {
      r = transforms_to_be_dropped(b, 0);
    }
    else if (t == TRANSLITERATION_DEFINITION) {
      r = transliteration_definition(b, 0);
    }
    else if (t == TRANSLITERATION_NAME) {
      r = transliteration_name(b, 0);
    }
    else if (t == TRANSLITERATION_ROUTINE) {
      r = transliteration_routine(b, 0);
    }
    else if (t == TRANSLITERATION_SOURCE) {
      r = transliteration_source(b, 0);
    }
    else if (t == TRIGGER_ACTION_TIME) {
      r = trigger_action_time(b, 0);
    }
    else if (t == TRIGGER_COLUMN_LIST) {
      r = trigger_column_list(b, 0);
    }
    else if (t == TRIGGER_DEFINITION) {
      r = trigger_definition(b, 0);
    }
    else if (t == TRIGGER_EVENT) {
      r = trigger_event(b, 0);
    }
    else if (t == TRIGGER_NAME) {
      r = trigger_name(b, 0);
    }
    else if (t == TRIGGERED_SQL_STATEMENT) {
      r = triggered_SQL_statement(b, 0);
    }
    else if (t == TRIGGERED_ACTION) {
      r = triggered_action(b, 0);
    }
    else if (t == TRIM_CHARACTER) {
      r = trim_character(b, 0);
    }
    else if (t == TRIM_FUNCTION) {
      r = trim_function(b, 0);
    }
    else if (t == TRIM_OCTET) {
      r = trim_octet(b, 0);
    }
    else if (t == TRIM_OPERANDS) {
      r = trim_operands(b, 0);
    }
    else if (t == TRIM_SOURCE) {
      r = trim_source(b, 0);
    }
    else if (t == TRIM_SPECIFICATION) {
      r = trim_specification(b, 0);
    }
    else if (t == TRUTH_VALUE) {
      r = truth_value(b, 0);
    }
    else if (t == TYPE_LIST) {
      r = type_list(b, 0);
    }
    else if (t == TYPE_PREDICATE) {
      r = type_predicate(b, 0);
    }
    else if (t == TYPE_PREDICATE_PART_2) {
      r = type_predicate_part_2(b, 0);
    }
    else if (t == UNDERSCORE) {
      r = underscore(b, 0);
    }
    else if (t == UNION_JOIN) {
      r = union_join(b, 0);
    }
    else if (t == UNIQUE_COLUMN_LIST) {
      r = unique_column_list(b, 0);
    }
    else if (t == UNIQUE_CONSTRAINT_DEFINITION) {
      r = unique_constraint_definition(b, 0);
    }
    else if (t == UNIQUE_PREDICATE) {
      r = unique_predicate(b, 0);
    }
    else if (t == UNIQUE_SPECIFICATION) {
      r = unique_specification(b, 0);
    }
    else if (t == UNQUOTED_DATE_STRING) {
      r = unquoted_date_string(b, 0);
    }
    else if (t == UNQUOTED_INTERVAL_STRING) {
      r = unquoted_interval_string(b, 0);
    }
    else if (t == UNQUOTED_TIME_STRING) {
      r = unquoted_time_string(b, 0);
    }
    else if (t == UNQUOTED_TIMESTAMP_STRING) {
      r = unquoted_timestamp_string(b, 0);
    }
    else if (t == UNSIGNED_INTEGER) {
      r = unsigned_integer(b, 0);
    }
    else if (t == UNSIGNED_LITERAL) {
      r = unsigned_literal(b, 0);
    }
    else if (t == UNSIGNED_NUMERIC_LITERAL) {
      r = unsigned_numeric_literal(b, 0);
    }
    else if (t == UNSIGNED_VALUE_SPECIFICATION) {
      r = unsigned_value_specification(b, 0);
    }
    else if (t == UPDATABILITY_CLAUSE) {
      r = updatability_clause(b, 0);
    }
    else if (t == UPDATE_RULE) {
      r = update_rule(b, 0);
    }
    else if (t == UPDATE_SOURCE) {
      r = update_source(b, 0);
    }
    else if (t == UPDATE_STATEMENT_POSITIONED) {
      r = update_statement_positioned(b, 0);
    }
    else if (t == UPDATE_STATEMENT_SEARCHED) {
      r = update_statement_searched(b, 0);
    }
    else if (t == UPDATE_TARGET) {
      r = update_target(b, 0);
    }
    else if (t == UPPER_LIMIT) {
      r = upper_limit(b, 0);
    }
    else if (t == USER_IDENTIFIER) {
      r = user_identifier(b, 0);
    }
    else if (t == USER_DEFINED_CAST_DEFINITION) {
      r = user_defined_cast_definition(b, 0);
    }
    else if (t == USER_DEFINED_CHARACTER_SET_NAME) {
      r = user_defined_character_set_name(b, 0);
    }
    else if (t == USER_DEFINED_ORDERING_DEFINITION) {
      r = user_defined_ordering_definition(b, 0);
    }
    else if (t == USER_DEFINED_REPRESENTATION) {
      r = user_defined_representation(b, 0);
    }
    else if (t == USER_DEFINED_TYPE_BODY) {
      r = user_defined_type_body(b, 0);
    }
    else if (t == USER_DEFINED_TYPE_DEFINITION) {
      r = user_defined_type_definition(b, 0);
    }
    else if (t == USER_DEFINED_TYPE_NAME) {
      r = user_defined_type_name(b, 0);
    }
    else if (t == USER_DEFINED_TYPE_OPTION) {
      r = user_defined_type_option(b, 0);
    }
    else if (t == USER_DEFINED_TYPE_OPTION_LIST) {
      r = user_defined_type_option_list(b, 0);
    }
    else if (t == USER_DEFINED_TYPE_SPECIFICATION) {
      r = user_defined_type_specification(b, 0);
    }
    else if (t == USER_DEFINED_TYPE_VALUE_EXPRESSION) {
      r = user_defined_type_value_expression(b, 0);
    }
    else if (t == USING_ARGUMENT) {
      r = using_argument(b, 0);
    }
    else if (t == USING_ARGUMENTS) {
      r = using_arguments(b, 0);
    }
    else if (t == USING_DESCRIPTOR) {
      r = using_descriptor(b, 0);
    }
    else if (t == USING_INPUT_DESCRIPTOR) {
      r = using_input_descriptor(b, 0);
    }
    else if (t == VALUE_EXPRESSION) {
      r = value_expression(b, 0);
    }
    else if (t == VALUE_EXPRESSION_PRIMARY) {
      r = value_expression_primary(b, 0);
    }
    else if (t == VALUE_SPECIFICATION) {
      r = value_specification(b, 0);
    }
    else if (t == VERTICAL_BAR) {
      r = vertical_bar(b, 0);
    }
    else if (t == VIEW_COLUMN_LIST) {
      r = view_column_list(b, 0);
    }
    else if (t == VIEW_COLUMN_OPTION) {
      r = view_column_option(b, 0);
    }
    else if (t == VIEW_DEFINITION) {
      r = view_definition(b, 0);
    }
    else if (t == VIEW_ELEMENT) {
      r = view_element(b, 0);
    }
    else if (t == VIEW_ELEMENT_LIST) {
      r = view_element_list(b, 0);
    }
    else if (t == VIEW_SPECIFICATION) {
      r = view_specification(b, 0);
    }
    else if (t == WHEN_OPERAND) {
      r = when_operand(b, 0);
    }
    else if (t == WHERE_CLAUSE) {
      r = where_clause(b, 0);
    }
    else if (t == WIDTH_BUCKET_BOUND_1) {
      r = width_bucket_bound_1(b, 0);
    }
    else if (t == WIDTH_BUCKET_BOUND_2) {
      r = width_bucket_bound_2(b, 0);
    }
    else if (t == WIDTH_BUCKET_COUNT) {
      r = width_bucket_count(b, 0);
    }
    else if (t == WIDTH_BUCKET_FUNCTION) {
      r = width_bucket_function(b, 0);
    }
    else if (t == WIDTH_BUCKET_OPERAND) {
      r = width_bucket_operand(b, 0);
    }
    else if (t == WINDOW_CLAUSE) {
      r = window_clause(b, 0);
    }
    else if (t == WINDOW_DEFINITION) {
      r = window_definition(b, 0);
    }
    else if (t == WINDOW_DEFINITION_LIST) {
      r = window_definition_list(b, 0);
    }
    else if (t == WINDOW_FRAME_BETWEEN) {
      r = window_frame_between(b, 0);
    }
    else if (t == WINDOW_FRAME_BOUND) {
      r = window_frame_bound(b, 0);
    }
    else if (t == WINDOW_FRAME_BOUND_1) {
      r = window_frame_bound_1(b, 0);
    }
    else if (t == WINDOW_FRAME_BOUND_2) {
      r = window_frame_bound_2(b, 0);
    }
    else if (t == WINDOW_FRAME_CLAUSE) {
      r = window_frame_clause(b, 0);
    }
    else if (t == WINDOW_FRAME_EXCLUSION) {
      r = window_frame_exclusion(b, 0);
    }
    else if (t == WINDOW_FRAME_EXTENT) {
      r = window_frame_extent(b, 0);
    }
    else if (t == WINDOW_FRAME_FOLLOWING) {
      r = window_frame_following(b, 0);
    }
    else if (t == WINDOW_FRAME_PRECEDING) {
      r = window_frame_preceding(b, 0);
    }
    else if (t == WINDOW_FRAME_START) {
      r = window_frame_start(b, 0);
    }
    else if (t == WINDOW_FRAME_UNITS) {
      r = window_frame_units(b, 0);
    }
    else if (t == WINDOW_FUNCTION) {
      r = window_function(b, 0);
    }
    else if (t == WINDOW_FUNCTION_TYPE) {
      r = window_function_type(b, 0);
    }
    else if (t == WINDOW_NAME) {
      r = window_name(b, 0);
    }
    else if (t == WINDOW_NAME_OR_SPECIFICATION) {
      r = window_name_or_specification(b, 0);
    }
    else if (t == WINDOW_ORDER_CLAUSE) {
      r = window_order_clause(b, 0);
    }
    else if (t == WINDOW_PARTITION_CLAUSE) {
      r = window_partition_clause(b, 0);
    }
    else if (t == WINDOW_PARTITION_COLUMN_REFERENCE) {
      r = window_partition_column_reference(b, 0);
    }
    else if (t == WINDOW_PARTITION_COLUMN_REFERENCE_LIST) {
      r = window_partition_column_reference_list(b, 0);
    }
    else if (t == WINDOW_SPECIFICATION) {
      r = window_specification(b, 0);
    }
    else if (t == WINDOW_SPECIFICATION_DETAILS) {
      r = window_specification_details(b, 0);
    }
    else if (t == WITH_CLAUSE) {
      r = with_clause(b, 0);
    }
    else if (t == WITH_COLUMN_LIST) {
      r = with_column_list(b, 0);
    }
    else if (t == WITH_LIST) {
      r = with_list(b, 0);
    }
    else if (t == WITH_LIST_ELEMENT) {
      r = with_list_element(b, 0);
    }
    else if (t == WITH_OR_WITHOUT_DATA) {
      r = with_or_without_data(b, 0);
    }
    else if (t == WITH_OR_WITHOUT_TIME_ZONE) {
      r = with_or_without_time_zone(b, 0);
    }
    else if (t == WITHIN_GROUP_SPECIFICATION) {
      r = within_group_specification(b, 0);
    }
    else if (t == YEAR_MONTH_LITERAL) {
      r = year_month_literal(b, 0);
    }
    else if (t == YEARS_VALUE) {
      r = years_value(b, 0);
    }
    else {
      r = parse_root_(t, b, 0);
    }
    exit_section_(b, 0, m, t, r, true, TRUE_CONDITION);
  }

  protected boolean parse_root_(IElementType t, PsiBuilder b, int l) {
    return SQL_terminal_character(b, l + 1);
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB AS LOCATOR
  public static boolean Ada_BLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_BLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, AS, LOCATOR);
    exit_section_(b, m, ADA_BLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB <left paren> <large object length> <right paren>
  public static boolean Ada_BLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_BLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    exit_section_(b, m, ADA_BLOB_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB AS LOCATOR
  public static boolean Ada_CLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_CLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, AS, LOCATOR);
    exit_section_(b, m, ADA_CLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB <left paren> <large object length> <right paren> [ CHARACTER SET [ IS ] <character set specification> ]
  public static boolean Ada_CLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_CLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && Ada_CLOB_variable_7(b, l + 1);
    exit_section_(b, m, ADA_CLOB_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Ada_CLOB_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_CLOB_variable_7")) return false;
    Ada_CLOB_variable_7_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean Ada_CLOB_variable_7_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_CLOB_variable_7_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && Ada_CLOB_variable_7_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean Ada_CLOB_variable_7_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_CLOB_variable_7_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <reference type>
  public static boolean Ada_REF_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_REF_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _REFERENCE_TYPE_);
    exit_section_(b, m, ADA_REF_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <array type> AS LOCATOR
  public static boolean Ada_array_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_array_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _ARRAY_TYPE_, AS, LOCATOR);
    exit_section_(b, m, ADA_ARRAY_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <colon><equals operator>
  public static boolean Ada_assignment_operator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_assignment_operator")) return false;
    if (!nextTokenIs(b, _COLON_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = colon(b, l + 1);
    r = r && equals_operator(b, l + 1);
    exit_section_(b, m, ADA_ASSIGNMENT_OPERATOR, r);
    return r;
  }

  /* ********************************************************** */
  // <Ada CLOB variable>
  // 	|	<Ada CLOB locator variable>
  // 	|	<Ada BLOB variable>
  // 	|	<Ada BLOB locator variable>
  // 	|	<Ada user-defined type variable>
  // 	|	<Ada user-defined type locator variable>
  // 	|	<Ada REF variable>
  // 	|	<Ada array locator variable>
  // 	|	<Ada multiset locator variable>
  public static boolean Ada_derived_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_derived_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ADA_DERIVED_TYPE_SPECIFICATION, "<ada derived type specification>");
    r = Ada_CLOB_variable(b, l + 1);
    if (!r) r = Ada_CLOB_locator_variable(b, l + 1);
    if (!r) r = Ada_BLOB_variable(b, l + 1);
    if (!r) r = Ada_BLOB_locator_variable(b, l + 1);
    if (!r) r = Ada_user_defined_type_variable(b, l + 1);
    if (!r) r = Ada_user_defined_type_locator_variable(b, l + 1);
    if (!r) r = Ada_REF_variable(b, l + 1);
    if (!r) r = Ada_array_locator_variable(b, l + 1);
    if (!r) r = Ada_multiset_locator_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean Ada_host_identifier(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, ADA_HOST_IDENTIFIER, true);
    return true;
  }

  /* ********************************************************** */
  // <Ada assignment operator> <character representation>...
  public static boolean Ada_initial_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_initial_value")) return false;
    if (!nextTokenIs(b, _ADA_ASSIGNMENT_OPERATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Ada_assignment_operator(b, l + 1);
    r = r && character_representation(b, l + 1);
    exit_section_(b, m, ADA_INITIAL_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <multiset type> AS LOCATOR
  public static boolean Ada_multiset_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_multiset_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _MULTISET_TYPE_, AS, LOCATOR);
    exit_section_(b, m, ADA_MULTISET_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // Interfaces.SQL <period> CHAR
  public static boolean Ada_qualified_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_qualified_type_specification")) return false;
    if (!nextTokenIs(b, INTERFACES_SQL__PERIOD__CHAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, INTERFACES_SQL__PERIOD__CHAR);
    exit_section_(b, m, ADA_QUALIFIED_TYPE_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <Ada qualified type specification>
  // 	|	<Ada unqualified type specification>
  // 	|	<Ada derived type specification>
  public static boolean Ada_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ADA_TYPE_SPECIFICATION, "<ada type specification>");
    r = Ada_qualified_type_specification(b, l + 1);
    if (!r) r = Ada_unqualified_type_specification(b, l + 1);
    if (!r) r = Ada_derived_type_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CHAR <left paren> 1 <double period> <length> <right paren>
  // 	|	SMALLINT
  // 	|	INT
  // 	|	BIGINT
  // 	|	REAL
  // 	|	DOUBLE_PRECISION
  // 	|	BOOLEAN
  // 	|	SQLSTATE_TYPE
  // 	|	INDICATOR_TYPE
  public static boolean Ada_unqualified_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_unqualified_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ADA_UNQUALIFIED_TYPE_SPECIFICATION, "<ada unqualified type specification>");
    r = Ada_unqualified_type_specification_0(b, l + 1);
    if (!r) r = consumeToken(b, SMALLINT);
    if (!r) r = consumeToken(b, INT);
    if (!r) r = consumeToken(b, BIGINT);
    if (!r) r = consumeToken(b, REAL);
    if (!r) r = consumeToken(b, DOUBLE_PRECISION);
    if (!r) r = consumeToken(b, BOOLEAN);
    if (!r) r = consumeToken(b, SQLSTATE_TYPE);
    if (!r) r = consumeToken(b, INDICATOR_TYPE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // CHAR <left paren> 1 <double period> <length> <right paren>
  private static boolean Ada_unqualified_type_specification_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_unqualified_type_specification_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHAR, _LEFT_PAREN_);
    r = r && consumeToken(b, "1");
    r = r && double_period(b, l + 1);
    r = r && length(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
  public static boolean Ada_user_defined_type_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_user_defined_type_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, LOCATOR);
    exit_section_(b, m, ADA_USER_DEFINED_TYPE_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
  public static boolean Ada_user_defined_type_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_user_defined_type_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, _PREDEFINED_TYPE_);
    exit_section_(b, m, ADA_USER_DEFINED_TYPE_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <Ada host identifier> [ { <comma> <Ada host identifier> }... ] <colon> <Ada type specification> [ <Ada initial value> ]
  public static boolean Ada_variable_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_variable_definition")) return false;
    if (!nextTokenIs(b, _ADA_HOST_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Ada_host_identifier(b, l + 1);
    r = r && Ada_variable_definition_1(b, l + 1);
    r = r && colon(b, l + 1);
    r = r && Ada_type_specification(b, l + 1);
    r = r && Ada_variable_definition_4(b, l + 1);
    exit_section_(b, m, ADA_VARIABLE_DEFINITION, r);
    return r;
  }

  // [ { <comma> <Ada host identifier> }... ]
  private static boolean Ada_variable_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_variable_definition_1")) return false;
    Ada_variable_definition_1_0(b, l + 1);
    return true;
  }

  // <comma> <Ada host identifier>
  private static boolean Ada_variable_definition_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_variable_definition_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && Ada_host_identifier(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <Ada initial value> ]
  private static boolean Ada_variable_definition_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Ada_variable_definition_4")) return false;
    Ada_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB AS LOCATOR
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  public static boolean C_BLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, AS, LOCATOR, _C_HOST_IDENTIFIER_);
    r = r && C_BLOB_locator_variable_7(b, l + 1);
    r = r && C_BLOB_locator_variable_8(b, l + 1);
    exit_section_(b, m, C_BLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_BLOB_locator_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_locator_variable_7")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  private static boolean C_BLOB_locator_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_locator_variable_8")) return false;
    C_BLOB_locator_variable_8_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_BLOB_locator_variable_8_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_locator_variable_8_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_BLOB_locator_variable_8_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_BLOB_locator_variable_8_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_locator_variable_8_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB <left paren> <large object length> <right paren>
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  public static boolean C_BLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_, _C_HOST_IDENTIFIER_);
    r = r && C_BLOB_variable_8(b, l + 1);
    r = r && C_BLOB_variable_9(b, l + 1);
    exit_section_(b, m, C_BLOB_VARIABLE, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_BLOB_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_variable_8")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  private static boolean C_BLOB_variable_9(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_variable_9")) return false;
    C_BLOB_variable_9_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_BLOB_variable_9_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_variable_9_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_BLOB_variable_9_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_BLOB_variable_9_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_BLOB_variable_9_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB AS LOCATOR
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  public static boolean C_CLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, AS, LOCATOR, _C_HOST_IDENTIFIER_);
    r = r && C_CLOB_locator_variable_7(b, l + 1);
    r = r && C_CLOB_locator_variable_8(b, l + 1);
    exit_section_(b, m, C_CLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_CLOB_locator_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_locator_variable_7")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  private static boolean C_CLOB_locator_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_locator_variable_8")) return false;
    C_CLOB_locator_variable_8_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_CLOB_locator_variable_8_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_locator_variable_8_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_CLOB_locator_variable_8_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_CLOB_locator_variable_8_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_locator_variable_8_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB <left paren> <large object length> <right paren>
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] }... ]
  public static boolean C_CLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && C_CLOB_variable_7(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_CLOB_variable_9(b, l + 1);
    r = r && C_CLOB_variable_10(b, l + 1);
    exit_section_(b, m, C_CLOB_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean C_CLOB_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_variable_7")) return false;
    C_CLOB_variable_7_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean C_CLOB_variable_7_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_variable_7_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && C_CLOB_variable_7_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean C_CLOB_variable_7_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_variable_7_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ <C initial value> ]
  private static boolean C_CLOB_variable_9(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_variable_9")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] }... ]
  private static boolean C_CLOB_variable_10(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_variable_10")) return false;
    C_CLOB_variable_10_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_CLOB_variable_10_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_variable_10_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_CLOB_variable_10_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_CLOB_variable_10_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_CLOB_variable_10_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // NCHAR VARYING [ CHARACTER SET [ IS ] <character set specification> ]
  // 		<C host identifier> <C array specification> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> <C array specification> [ <C initial value> ] } ... ]
  public static boolean C_NCHAR_VARYING_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_VARYING_variable")) return false;
    if (!nextTokenIs(b, NCHAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NCHAR, VARYING);
    r = r && C_NCHAR_VARYING_variable_2(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_specification(b, l + 1);
    r = r && C_NCHAR_VARYING_variable_5(b, l + 1);
    r = r && C_NCHAR_VARYING_variable_6(b, l + 1);
    exit_section_(b, m, C_NCHAR_VARYING_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean C_NCHAR_VARYING_variable_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_VARYING_variable_2")) return false;
    C_NCHAR_VARYING_variable_2_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean C_NCHAR_VARYING_variable_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_VARYING_variable_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && C_NCHAR_VARYING_variable_2_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean C_NCHAR_VARYING_variable_2_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_VARYING_variable_2_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ <C initial value> ]
  private static boolean C_NCHAR_VARYING_variable_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_VARYING_variable_5")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> <C array specification> [ <C initial value> ] } ... ]
  private static boolean C_NCHAR_VARYING_variable_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_VARYING_variable_6")) return false;
    C_NCHAR_VARYING_variable_6_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> <C array specification> [ <C initial value> ]
  private static boolean C_NCHAR_VARYING_variable_6_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_VARYING_variable_6_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_specification(b, l + 1);
    r = r && C_NCHAR_VARYING_variable_6_0_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_NCHAR_VARYING_variable_6_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_VARYING_variable_6_0_3")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // NCHAR [ CHARACTER SET [ IS ] <character set specification> ]
  // 		<C host identifier> <C array specification> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> <C array specification> [ <C initial value> ] } ... ]
  public static boolean C_NCHAR_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_variable")) return false;
    if (!nextTokenIs(b, NCHAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NCHAR);
    r = r && C_NCHAR_variable_1(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_specification(b, l + 1);
    r = r && C_NCHAR_variable_4(b, l + 1);
    r = r && C_NCHAR_variable_5(b, l + 1);
    exit_section_(b, m, C_NCHAR_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean C_NCHAR_variable_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_variable_1")) return false;
    C_NCHAR_variable_1_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean C_NCHAR_variable_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_variable_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && C_NCHAR_variable_1_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean C_NCHAR_variable_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_variable_1_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ <C initial value> ]
  private static boolean C_NCHAR_variable_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_variable_4")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> <C array specification> [ <C initial value> ] } ... ]
  private static boolean C_NCHAR_variable_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_variable_5")) return false;
    C_NCHAR_variable_5_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> <C array specification> [ <C initial value> ]
  private static boolean C_NCHAR_variable_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_variable_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_specification(b, l + 1);
    r = r && C_NCHAR_variable_5_0_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_NCHAR_variable_5_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCHAR_variable_5_0_3")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS NCLOB <left paren> <large object length> <right paren>
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] }... ]
  public static boolean C_NCLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, NCLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && C_NCLOB_variable_7(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_NCLOB_variable_9(b, l + 1);
    r = r && C_NCLOB_variable_10(b, l + 1);
    exit_section_(b, m, C_NCLOB_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean C_NCLOB_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCLOB_variable_7")) return false;
    C_NCLOB_variable_7_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean C_NCLOB_variable_7_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCLOB_variable_7_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && C_NCLOB_variable_7_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean C_NCLOB_variable_7_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCLOB_variable_7_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ <C initial value> ]
  private static boolean C_NCLOB_variable_9(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCLOB_variable_9")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] }... ]
  private static boolean C_NCLOB_variable_10(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCLOB_variable_10")) return false;
    C_NCLOB_variable_10_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_NCLOB_variable_10_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCLOB_variable_10_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_NCLOB_variable_10_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_NCLOB_variable_10_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_NCLOB_variable_10_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <reference type>
  public static boolean C_REF_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_REF_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _REFERENCE_TYPE_);
    exit_section_(b, m, C_REF_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // VARCHAR [ CHARACTER SET [ IS ] <character set specification> ]
  // 		<C host identifier> <C array specification> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]
  public static boolean C_VARCHAR_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_VARCHAR_variable")) return false;
    if (!nextTokenIs(b, VARCHAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, VARCHAR);
    r = r && C_VARCHAR_variable_1(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_specification(b, l + 1);
    r = r && C_VARCHAR_variable_4(b, l + 1);
    r = r && C_VARCHAR_variable_5(b, l + 1);
    exit_section_(b, m, C_VARCHAR_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean C_VARCHAR_variable_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_VARCHAR_variable_1")) return false;
    C_VARCHAR_variable_1_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean C_VARCHAR_variable_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_VARCHAR_variable_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && C_VARCHAR_variable_1_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean C_VARCHAR_variable_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_VARCHAR_variable_1_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ <C initial value> ]
  private static boolean C_VARCHAR_variable_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_VARCHAR_variable_4")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]
  private static boolean C_VARCHAR_variable_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_VARCHAR_variable_5")) return false;
    C_VARCHAR_variable_5_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> <C array specification> [ <C initial value> ]
  private static boolean C_VARCHAR_variable_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_VARCHAR_variable_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_specification(b, l + 1);
    r = r && C_VARCHAR_variable_5_0_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_VARCHAR_variable_5_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_VARCHAR_variable_5_0_3")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <array type> AS LOCATOR
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  public static boolean C_array_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_array_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _ARRAY_TYPE_, AS, LOCATOR, _C_HOST_IDENTIFIER_);
    r = r && C_array_locator_variable_7(b, l + 1);
    r = r && C_array_locator_variable_8(b, l + 1);
    exit_section_(b, m, C_ARRAY_LOCATOR_VARIABLE, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_array_locator_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_array_locator_variable_7")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  private static boolean C_array_locator_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_array_locator_variable_8")) return false;
    C_array_locator_variable_8_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_array_locator_variable_8_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_array_locator_variable_8_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_locator_variable_8_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_array_locator_variable_8_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_array_locator_variable_8_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <left bracket> <length> <right bracket>
  public static boolean C_array_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_array_specification")) return false;
    if (!nextTokenIs(b, _LEFT_BRACKET_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_bracket(b, l + 1);
    r = r && length(b, l + 1);
    r = r && consumeToken(b, _RIGHT_BRACKET_);
    exit_section_(b, m, C_ARRAY_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // char | unsigned char | unsigned short
  public static boolean C_character_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_type")) return false;
    if (!nextTokenIs(b, "<c character type>", CHAR, UNSIGNED)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, C_CHARACTER_TYPE, "<c character type>");
    r = consumeToken(b, CHAR);
    if (!r) r = parseTokens(b, 0, UNSIGNED, CHAR);
    if (!r) r = parseTokens(b, 0, UNSIGNED, SHORT);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <C character type> [ CHARACTER SET [ IS ] <character set specification> ]
  // 		<C host identifier> <C array specification> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]
  public static boolean C_character_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_variable")) return false;
    if (!nextTokenIs(b, _C_CHARACTER_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = C_character_type(b, l + 1);
    r = r && C_character_variable_1(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_specification(b, l + 1);
    r = r && C_character_variable_4(b, l + 1);
    r = r && C_character_variable_5(b, l + 1);
    exit_section_(b, m, C_CHARACTER_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean C_character_variable_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_variable_1")) return false;
    C_character_variable_1_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean C_character_variable_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_variable_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && C_character_variable_1_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean C_character_variable_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_variable_1_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ <C initial value> ]
  private static boolean C_character_variable_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_variable_4")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]
  private static boolean C_character_variable_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_variable_5")) return false;
    C_character_variable_5_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> <C array specification> [ <C initial value> ]
  private static boolean C_character_variable_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_variable_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_array_specification(b, l + 1);
    r = r && C_character_variable_5_0_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_character_variable_5_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_character_variable_5_0_3")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // const | volatile
  public static boolean C_class_modifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_class_modifier")) return false;
    if (!nextTokenIs(b, "<c class modifier>", CONST, VOLATILE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, C_CLASS_MODIFIER, "<c class modifier>");
    r = consumeToken(b, CONST);
    if (!r) r = consumeToken(b, VOLATILE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <C VARCHAR variable>
  // 	|	<C NCHAR variable>
  // 	|	<C NCHAR VARYING variable>
  // 	|	<C CLOB variable>
  // 	|	<C NCLOB variable>
  // 	|	<C BLOB variable>
  // 	|	<C user-defined type variable>
  // 	|	<C CLOB locator variable>
  // 	|	<C BLOB locator variable>
  // 	|	<C array locator variable>
  // 	|	<C multiset locator variable>
  // 	|	<C user-defined type locator variable>
  // 	|	<C REF variable>
  public static boolean C_derived_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_derived_variable")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, C_DERIVED_VARIABLE, "<c derived variable>");
    r = C_VARCHAR_variable(b, l + 1);
    if (!r) r = C_NCHAR_variable(b, l + 1);
    if (!r) r = C_NCHAR_VARYING_variable(b, l + 1);
    if (!r) r = C_CLOB_variable(b, l + 1);
    if (!r) r = C_NCLOB_variable(b, l + 1);
    if (!r) r = C_BLOB_variable(b, l + 1);
    if (!r) r = C_user_defined_type_variable(b, l + 1);
    if (!r) r = C_CLOB_locator_variable(b, l + 1);
    if (!r) r = C_BLOB_locator_variable(b, l + 1);
    if (!r) r = C_array_locator_variable(b, l + 1);
    if (!r) r = C_multiset_locator_variable(b, l + 1);
    if (!r) r = C_user_defined_type_locator_variable(b, l + 1);
    if (!r) r = C_REF_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean C_host_identifier(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, C_HOST_IDENTIFIER, true);
    return true;
  }

  /* ********************************************************** */
  // <equals operator> <character representation>...
  public static boolean C_initial_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_initial_value")) return false;
    if (!nextTokenIs(b, _EQUALS_OPERATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = equals_operator(b, l + 1);
    r = r && character_representation(b, l + 1);
    exit_section_(b, m, C_INITIAL_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <multiset type> AS LOCATOR
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  public static boolean C_multiset_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_multiset_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _MULTISET_TYPE_, AS, LOCATOR, _C_HOST_IDENTIFIER_);
    r = r && C_multiset_locator_variable_7(b, l + 1);
    r = r && C_multiset_locator_variable_8(b, l + 1);
    exit_section_(b, m, C_MULTISET_LOCATOR_VARIABLE, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_multiset_locator_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_multiset_locator_variable_7")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  private static boolean C_multiset_locator_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_multiset_locator_variable_8")) return false;
    C_multiset_locator_variable_8_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_multiset_locator_variable_8_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_multiset_locator_variable_8_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_multiset_locator_variable_8_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_multiset_locator_variable_8_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_multiset_locator_variable_8_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // { long long | long | short | float | double } <C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] }... ]
  public static boolean C_numeric_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_numeric_variable")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, C_NUMERIC_VARIABLE, "<c numeric variable>");
    r = C_numeric_variable_0(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_numeric_variable_2(b, l + 1);
    r = r && C_numeric_variable_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // long long | long | short | float | double
  private static boolean C_numeric_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_numeric_variable_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, LONG, LONG);
    if (!r) r = consumeToken(b, LONG);
    if (!r) r = consumeToken(b, SHORT);
    if (!r) r = consumeToken(b, FLOAT);
    if (!r) r = consumeToken(b, DOUBLE);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_numeric_variable_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_numeric_variable_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] }... ]
  private static boolean C_numeric_variable_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_numeric_variable_3")) return false;
    C_numeric_variable_3_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_numeric_variable_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_numeric_variable_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_numeric_variable_3_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_numeric_variable_3_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_numeric_variable_3_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // auto | extern | static
  public static boolean C_storage_class(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_storage_class")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, C_STORAGE_CLASS, "<c storage class>");
    r = consumeToken(b, AUTO);
    if (!r) r = consumeToken(b, EXTERN);
    if (!r) r = consumeToken(b, STATIC);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS
  // 		<path-resolved user-defined type name> AS LOCATOR
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] }... ]
  public static boolean C_user_defined_type_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, LOCATOR, _C_HOST_IDENTIFIER_);
    r = r && C_user_defined_type_locator_variable_7(b, l + 1);
    r = r && C_user_defined_type_locator_variable_8(b, l + 1);
    exit_section_(b, m, C_USER_DEFINED_TYPE_LOCATOR_VARIABLE, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_user_defined_type_locator_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_locator_variable_7")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] }... ]
  private static boolean C_user_defined_type_locator_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_locator_variable_8")) return false;
    C_user_defined_type_locator_variable_8_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_user_defined_type_locator_variable_8_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_locator_variable_8_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_user_defined_type_locator_variable_8_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_user_defined_type_locator_variable_8_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_locator_variable_8_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
  // 		<C host identifier> [ <C initial value> ]
  // 		[ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  public static boolean C_user_defined_type_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, _PREDEFINED_TYPE_, _C_HOST_IDENTIFIER_);
    r = r && C_user_defined_type_variable_7(b, l + 1);
    r = r && C_user_defined_type_variable_8(b, l + 1);
    exit_section_(b, m, C_USER_DEFINED_TYPE_VARIABLE, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_user_defined_type_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_variable_7")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  // [ { <comma> <C host identifier> [ <C initial value> ] } ... ]
  private static boolean C_user_defined_type_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_variable_8")) return false;
    C_user_defined_type_variable_8_0(b, l + 1);
    return true;
  }

  // <comma> <C host identifier> [ <C initial value> ]
  private static boolean C_user_defined_type_variable_8_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_variable_8_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && C_host_identifier(b, l + 1);
    r = r && C_user_defined_type_variable_8_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <C initial value> ]
  private static boolean C_user_defined_type_variable_8_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_user_defined_type_variable_8_0_2")) return false;
    C_initial_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // [ <C storage class> ] [ <C class modifier> ] <C variable specification> <semicolon>
  public static boolean C_variable_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_variable_definition")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, C_VARIABLE_DEFINITION, "<c variable definition>");
    r = C_variable_definition_0(b, l + 1);
    r = r && C_variable_definition_1(b, l + 1);
    r = r && C_variable_specification(b, l + 1);
    r = r && semicolon(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <C storage class> ]
  private static boolean C_variable_definition_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_variable_definition_0")) return false;
    C_storage_class(b, l + 1);
    return true;
  }

  // [ <C class modifier> ]
  private static boolean C_variable_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_variable_definition_1")) return false;
    C_class_modifier(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <C numeric variable> | <C character variable> | <C derived variable>
  public static boolean C_variable_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "C_variable_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, C_VARIABLE_SPECIFICATION, "<c variable specification>");
    r = C_numeric_variable(b, l + 1);
    if (!r) r = C_character_variable(b, l + 1);
    if (!r) r = C_derived_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ] SQL TYPE IS BLOB AS LOCATOR
  public static boolean COBOL_BLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_BLOB_locator_variable")) return false;
    if (!nextTokenIs(b, "<cobol blob locator variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_BLOB_LOCATOR_VARIABLE, "<cobol blob locator variable>");
    r = COBOL_BLOB_locator_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, BLOB, AS, LOCATOR);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_BLOB_locator_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_BLOB_locator_variable_0")) return false;
    COBOL_BLOB_locator_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_BLOB_locator_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_BLOB_locator_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_BLOB_locator_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_BLOB_locator_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_BLOB_locator_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ]
  // 		SQL TYPE IS BLOB <left paren> <large object length> <right paren>
  public static boolean COBOL_BLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_BLOB_variable")) return false;
    if (!nextTokenIs(b, "<cobol blob variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_BLOB_VARIABLE, "<cobol blob variable>");
    r = COBOL_BLOB_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, BLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_BLOB_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_BLOB_variable_0")) return false;
    COBOL_BLOB_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_BLOB_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_BLOB_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_BLOB_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_BLOB_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_BLOB_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ] SQL TYPE IS CLOB AS LOCATOR
  public static boolean COBOL_CLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_locator_variable")) return false;
    if (!nextTokenIs(b, "<cobol clob locator variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_CLOB_LOCATOR_VARIABLE, "<cobol clob locator variable>");
    r = COBOL_CLOB_locator_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, CLOB, AS, LOCATOR);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_CLOB_locator_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_locator_variable_0")) return false;
    COBOL_CLOB_locator_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_CLOB_locator_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_locator_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_CLOB_locator_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_CLOB_locator_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_locator_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ]
  // 		SQL TYPE IS CLOB <left paren> <large object length> <right paren>
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  public static boolean COBOL_CLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_variable")) return false;
    if (!nextTokenIs(b, "<cobol clob variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_CLOB_VARIABLE, "<cobol clob variable>");
    r = COBOL_CLOB_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, CLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && COBOL_CLOB_variable_8(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_CLOB_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_variable_0")) return false;
    COBOL_CLOB_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_CLOB_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_CLOB_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_CLOB_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean COBOL_CLOB_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_variable_8")) return false;
    COBOL_CLOB_variable_8_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean COBOL_CLOB_variable_8_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_variable_8_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && COBOL_CLOB_variable_8_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_CLOB_variable_8_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_CLOB_variable_8_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ]
  // 		SQL TYPE IS NCLOB <left paren> <large object length> <right paren>
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  public static boolean COBOL_NCLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_NCLOB_variable")) return false;
    if (!nextTokenIs(b, "<cobol nclob variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_NCLOB_VARIABLE, "<cobol nclob variable>");
    r = COBOL_NCLOB_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, NCLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && COBOL_NCLOB_variable_8(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_NCLOB_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_NCLOB_variable_0")) return false;
    COBOL_NCLOB_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_NCLOB_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_NCLOB_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_NCLOB_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_NCLOB_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_NCLOB_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean COBOL_NCLOB_variable_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_NCLOB_variable_8")) return false;
    COBOL_NCLOB_variable_8_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean COBOL_NCLOB_variable_8_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_NCLOB_variable_8_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && COBOL_NCLOB_variable_8_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_NCLOB_variable_8_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_NCLOB_variable_8_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ] SQL TYPE IS <reference type>
  public static boolean COBOL_REF_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_REF_variable")) return false;
    if (!nextTokenIs(b, "<cobol ref variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_REF_VARIABLE, "<cobol ref variable>");
    r = COBOL_REF_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, _REFERENCE_TYPE_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_REF_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_REF_variable_0")) return false;
    COBOL_REF_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_REF_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_REF_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_REF_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_REF_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_REF_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ] SQL TYPE IS <array type> AS LOCATOR
  public static boolean COBOL_array_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_array_locator_variable")) return false;
    if (!nextTokenIs(b, "<cobol array locator variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_ARRAY_LOCATOR_VARIABLE, "<cobol array locator variable>");
    r = COBOL_array_locator_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, _ARRAY_TYPE_, AS, LOCATOR);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_array_locator_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_array_locator_variable_0")) return false;
    COBOL_array_locator_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_array_locator_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_array_locator_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_array_locator_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_array_locator_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_array_locator_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // { PIC | PICTURE } [ IS ] S<COBOL nines> [ USAGE [ IS ] ] BINARY
  public static boolean COBOL_binary_integer(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_binary_integer")) return false;
    if (!nextTokenIs(b, "<cobol binary integer>", PIC, PICTURE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_BINARY_INTEGER, "<cobol binary integer>");
    r = COBOL_binary_integer_0(b, l + 1);
    r = r && COBOL_binary_integer_1(b, l + 1);
    r = r && consumeTokens(b, 0, S, _COBOL_NINES_);
    r = r && COBOL_binary_integer_4(b, l + 1);
    r = r && consumeToken(b, BINARY);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // PIC | PICTURE
  private static boolean COBOL_binary_integer_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_binary_integer_0")) return false;
    boolean r;
    r = consumeToken(b, PIC);
    if (!r) r = consumeToken(b, PICTURE);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_binary_integer_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_binary_integer_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_binary_integer_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_binary_integer_4")) return false;
    COBOL_binary_integer_4_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_binary_integer_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_binary_integer_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_binary_integer_4_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_binary_integer_4_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_binary_integer_4_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ CHARACTER SET [ IS ] <character set specification> ]
  // 		{ PIC | PICTURE } [ IS ] { X [ <left paren> <length> <right paren> ] }...
  public static boolean COBOL_character_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_character_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_CHARACTER_TYPE, "<cobol character type>");
    r = COBOL_character_type_0(b, l + 1);
    r = r && COBOL_character_type_1(b, l + 1);
    r = r && COBOL_character_type_2(b, l + 1);
    r = r && COBOL_character_type_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean COBOL_character_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_character_type_0")) return false;
    COBOL_character_type_0_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean COBOL_character_type_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_character_type_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && COBOL_character_type_0_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_character_type_0_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_character_type_0_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // PIC | PICTURE
  private static boolean COBOL_character_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_character_type_1")) return false;
    boolean r;
    r = consumeToken(b, PIC);
    if (!r) r = consumeToken(b, PICTURE);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_character_type_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_character_type_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // X [ <left paren> <length> <right paren> ]
  private static boolean COBOL_character_type_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_character_type_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, X);
    r = r && COBOL_character_type_3_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <length> <right paren> ]
  private static boolean COBOL_character_type_3_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_character_type_3_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <COBOL CLOB variable>
  // 	|	<COBOL NCLOB variable>
  // 	|	<COBOL BLOB variable>
  // 	|	<COBOL user-defined type variable>
  // 	|	<COBOL CLOB locator variable>
  // 	|	<COBOL BLOB locator variable>
  // 	|	<COBOL array locator variable>
  // 	|	<COBOL multiset locator variable>
  // 	|	<COBOL user-defined type locator variable>
  // 	|	<COBOL REF variable>
  public static boolean COBOL_derived_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_derived_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_DERIVED_TYPE_SPECIFICATION, "<cobol derived type specification>");
    r = COBOL_CLOB_variable(b, l + 1);
    if (!r) r = COBOL_NCLOB_variable(b, l + 1);
    if (!r) r = COBOL_BLOB_variable(b, l + 1);
    if (!r) r = COBOL_user_defined_type_variable(b, l + 1);
    if (!r) r = COBOL_CLOB_locator_variable(b, l + 1);
    if (!r) r = COBOL_BLOB_locator_variable(b, l + 1);
    if (!r) r = COBOL_array_locator_variable(b, l + 1);
    if (!r) r = COBOL_multiset_locator_variable(b, l + 1);
    if (!r) r = COBOL_user_defined_type_locator_variable(b, l + 1);
    if (!r) r = COBOL_REF_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean COBOL_host_identifier(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, COBOL_HOST_IDENTIFIER, true);
    return true;
  }

  /* ********************************************************** */
  // <COBOL binary integer>
  public static boolean COBOL_integer_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_integer_type")) return false;
    if (!nextTokenIs(b, _COBOL_BINARY_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = COBOL_binary_integer(b, l + 1);
    exit_section_(b, m, COBOL_INTEGER_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ] SQL TYPE IS <multiset type> AS LOCATOR
  public static boolean COBOL_multiset_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_multiset_locator_variable")) return false;
    if (!nextTokenIs(b, "<cobol multiset locator variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_MULTISET_LOCATOR_VARIABLE, "<cobol multiset locator variable>");
    r = COBOL_multiset_locator_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, _MULTISET_TYPE_, AS, LOCATOR);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_multiset_locator_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_multiset_locator_variable_0")) return false;
    COBOL_multiset_locator_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_multiset_locator_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_multiset_locator_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_multiset_locator_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_multiset_locator_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_multiset_locator_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ CHARACTER SET [ IS ] <character set specification> ]
  // 		{ PIC | PICTURE } [ IS ] { N [ <left paren> <length> <right paren> ] }...
  public static boolean COBOL_national_character_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_national_character_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_NATIONAL_CHARACTER_TYPE, "<cobol national character type>");
    r = COBOL_national_character_type_0(b, l + 1);
    r = r && COBOL_national_character_type_1(b, l + 1);
    r = r && COBOL_national_character_type_2(b, l + 1);
    r = r && COBOL_national_character_type_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean COBOL_national_character_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_national_character_type_0")) return false;
    COBOL_national_character_type_0_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean COBOL_national_character_type_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_national_character_type_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && COBOL_national_character_type_0_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_national_character_type_0_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_national_character_type_0_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // PIC | PICTURE
  private static boolean COBOL_national_character_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_national_character_type_1")) return false;
    boolean r;
    r = consumeToken(b, PIC);
    if (!r) r = consumeToken(b, PICTURE);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_national_character_type_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_national_character_type_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // N [ <left paren> <length> <right paren> ]
  private static boolean COBOL_national_character_type_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_national_character_type_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, N);
    r = r && COBOL_national_character_type_3_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <length> <right paren> ]
  private static boolean COBOL_national_character_type_3_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_national_character_type_3_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // 9 [ <left paren> <length> <right paren> ]
  public static boolean COBOL_nines(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_nines")) return false;
    if (!nextTokenIs(b, 9)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "9");
    r = r && COBOL_nines_1(b, l + 1);
    exit_section_(b, m, COBOL_NINES, r);
    return r;
  }

  // [ <left paren> <length> <right paren> ]
  private static boolean COBOL_nines_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_nines_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <COBOL nines> [ V [ <COBOL nines> ] ]
  // 	|	V <COBOL nines>
  public static boolean COBOL_nines_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_nines_specification")) return false;
    if (!nextTokenIs(b, "<cobol nines specification>", V, _COBOL_NINES_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_NINES_SPECIFICATION, "<cobol nines specification>");
    r = COBOL_nines_specification_0(b, l + 1);
    if (!r) r = parseTokens(b, 0, V, _COBOL_NINES_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <COBOL nines> [ V [ <COBOL nines> ] ]
  private static boolean COBOL_nines_specification_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_nines_specification_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = COBOL_nines(b, l + 1);
    r = r && COBOL_nines_specification_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ V [ <COBOL nines> ] ]
  private static boolean COBOL_nines_specification_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_nines_specification_0_1")) return false;
    COBOL_nines_specification_0_1_0(b, l + 1);
    return true;
  }

  // V [ <COBOL nines> ]
  private static boolean COBOL_nines_specification_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_nines_specification_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, V);
    r = r && COBOL_nines_specification_0_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <COBOL nines> ]
  private static boolean COBOL_nines_specification_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_nines_specification_0_1_0_1")) return false;
    COBOL_nines(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // { PIC | PICTURE } [ IS ] S <COBOL nines specification> [ USAGE [ IS ] ] DISPLAY SIGN LEADING SEPARATE
  public static boolean COBOL_numeric_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_numeric_type")) return false;
    if (!nextTokenIs(b, "<cobol numeric type>", PIC, PICTURE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_NUMERIC_TYPE, "<cobol numeric type>");
    r = COBOL_numeric_type_0(b, l + 1);
    r = r && COBOL_numeric_type_1(b, l + 1);
    r = r && consumeTokens(b, 0, S, _COBOL_NINES_SPECIFICATION_);
    r = r && COBOL_numeric_type_4(b, l + 1);
    r = r && consumeTokens(b, 0, DISPLAY, SIGN, LEADING, SEPARATE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // PIC | PICTURE
  private static boolean COBOL_numeric_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_numeric_type_0")) return false;
    boolean r;
    r = consumeToken(b, PIC);
    if (!r) r = consumeToken(b, PICTURE);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_numeric_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_numeric_type_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_numeric_type_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_numeric_type_4")) return false;
    COBOL_numeric_type_4_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_numeric_type_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_numeric_type_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_numeric_type_4_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_numeric_type_4_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_numeric_type_4_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // <COBOL character type>
  // 	|	<COBOL national character type>
  // 	|	<COBOL numeric type>
  // 	|	<COBOL integer type>
  // 	|	<COBOL derived type specification>
  public static boolean COBOL_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_TYPE_SPECIFICATION, "<cobol type specification>");
    r = COBOL_character_type(b, l + 1);
    if (!r) r = COBOL_national_character_type(b, l + 1);
    if (!r) r = COBOL_numeric_type(b, l + 1);
    if (!r) r = COBOL_integer_type(b, l + 1);
    if (!r) r = COBOL_derived_type_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ] SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
  public static boolean COBOL_user_defined_type_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_user_defined_type_locator_variable")) return false;
    if (!nextTokenIs(b, "<cobol user defined type locator variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_USER_DEFINED_TYPE_LOCATOR_VARIABLE, "<cobol user defined type locator variable>");
    r = COBOL_user_defined_type_locator_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, LOCATOR);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_user_defined_type_locator_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_user_defined_type_locator_variable_0")) return false;
    COBOL_user_defined_type_locator_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_user_defined_type_locator_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_user_defined_type_locator_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_user_defined_type_locator_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_user_defined_type_locator_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_user_defined_type_locator_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // [ USAGE [ IS ] ] SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
  public static boolean COBOL_user_defined_type_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_user_defined_type_variable")) return false;
    if (!nextTokenIs(b, "<cobol user defined type variable>", SQL, USAGE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_USER_DEFINED_TYPE_VARIABLE, "<cobol user defined type variable>");
    r = COBOL_user_defined_type_variable_0(b, l + 1);
    r = r && consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, _PREDEFINED_TYPE_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ USAGE [ IS ] ]
  private static boolean COBOL_user_defined_type_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_user_defined_type_variable_0")) return false;
    COBOL_user_defined_type_variable_0_0(b, l + 1);
    return true;
  }

  // USAGE [ IS ]
  private static boolean COBOL_user_defined_type_variable_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_user_defined_type_variable_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USAGE);
    r = r && COBOL_user_defined_type_variable_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean COBOL_user_defined_type_variable_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_user_defined_type_variable_0_0_1")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // { 01 | 77 } <COBOL host identifier> <COBOL type specification>
  // 		[ <character representation>... ] <period>
  public static boolean COBOL_variable_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_variable_definition")) return false;
    if (!nextTokenIs(b, "<cobol variable definition>", 01, 77)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COBOL_VARIABLE_DEFINITION, "<cobol variable definition>");
    r = COBOL_variable_definition_0(b, l + 1);
    r = r && COBOL_host_identifier(b, l + 1);
    r = r && COBOL_type_specification(b, l + 1);
    r = r && COBOL_variable_definition_3(b, l + 1);
    r = r && period(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // 01 | 77
  private static boolean COBOL_variable_definition_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_variable_definition_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "01");
    if (!r) r = consumeToken(b, "77");
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <character representation>... ]
  private static boolean COBOL_variable_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "COBOL_variable_definition_3")) return false;
    consumeToken(b, _CHARACTER_REPRESENTATION____);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB AS LOCATOR
  public static boolean Fortran_BLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_BLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, AS, LOCATOR);
    exit_section_(b, m, FORTRAN_BLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB <left paren> <large object length> <right paren>
  public static boolean Fortran_BLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_BLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    exit_section_(b, m, FORTRAN_BLOB_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB AS LOCATOR
  public static boolean Fortran_CLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_CLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, AS, LOCATOR);
    exit_section_(b, m, FORTRAN_CLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB <left paren> <large object length> <right paren>
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  public static boolean Fortran_CLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_CLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && Fortran_CLOB_variable_7(b, l + 1);
    exit_section_(b, m, FORTRAN_CLOB_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Fortran_CLOB_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_CLOB_variable_7")) return false;
    Fortran_CLOB_variable_7_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean Fortran_CLOB_variable_7_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_CLOB_variable_7_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && Fortran_CLOB_variable_7_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean Fortran_CLOB_variable_7_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_CLOB_variable_7_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <reference type>
  public static boolean Fortran_REF_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_REF_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _REFERENCE_TYPE_);
    exit_section_(b, m, FORTRAN_REF_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <array type> AS LOCATOR
  public static boolean Fortran_array_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_array_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _ARRAY_TYPE_, AS, LOCATOR);
    exit_section_(b, m, FORTRAN_ARRAY_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <Fortran CLOB variable>
  // 	|	<Fortran BLOB variable>
  // 	|	<Fortran user-defined type variable>
  // 	|	<Fortran CLOB locator variable>
  // 	|	<Fortran BLOB locator variable>
  // 	|	<Fortran user-defined type locator variable>
  // 	|	<Fortran array locator variable>
  // 	|	<Fortran multiset locator variable>
  // 	|	<Fortran REF variable>
  public static boolean Fortran_derived_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_derived_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FORTRAN_DERIVED_TYPE_SPECIFICATION, "<fortran derived type specification>");
    r = Fortran_CLOB_variable(b, l + 1);
    if (!r) r = Fortran_BLOB_variable(b, l + 1);
    if (!r) r = Fortran_user_defined_type_variable(b, l + 1);
    if (!r) r = Fortran_CLOB_locator_variable(b, l + 1);
    if (!r) r = Fortran_BLOB_locator_variable(b, l + 1);
    if (!r) r = Fortran_user_defined_type_locator_variable(b, l + 1);
    if (!r) r = Fortran_array_locator_variable(b, l + 1);
    if (!r) r = Fortran_multiset_locator_variable(b, l + 1);
    if (!r) r = Fortran_REF_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean Fortran_host_identifier(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, FORTRAN_HOST_IDENTIFIER, true);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <multiset type> AS LOCATOR
  public static boolean Fortran_multiset_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_multiset_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _MULTISET_TYPE_, AS, LOCATOR);
    exit_section_(b, m, FORTRAN_MULTISET_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // CHARACTER [ <asterisk> <length> ] [ CHARACTER SET [ IS ] <character set specification> ]
  // 	|	CHARACTER KIND = n
  public static boolean Fortran_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_type_specification")) return false;
    if (!nextTokenIs(b, CHARACTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Fortran_type_specification_0(b, l + 1);
    if (!r) r = parseTokens(b, 0, CHARACTER, KIND);
    exit_section_(b, m, FORTRAN_TYPE_SPECIFICATION, r);
    return r;
  }

  // CHARACTER [ <asterisk> <length> ] [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Fortran_type_specification_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_type_specification_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CHARACTER);
    r = r && Fortran_type_specification_0_1(b, l + 1);
    r = r && Fortran_type_specification_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <asterisk> <length> ]
  private static boolean Fortran_type_specification_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_type_specification_0_1")) return false;
    asterisk(b, l + 1);
    return true;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Fortran_type_specification_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_type_specification_0_2")) return false;
    Fortran_type_specification_0_2_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean Fortran_type_specification_0_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_type_specification_0_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && Fortran_type_specification_0_2_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean Fortran_type_specification_0_2_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_type_specification_0_2_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
  public static boolean Fortran_user_defined_type_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_user_defined_type_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, LOCATOR);
    exit_section_(b, m, FORTRAN_USER_DEFINED_TYPE_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
  public static boolean Fortran_user_defined_type_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_user_defined_type_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, _PREDEFINED_TYPE_);
    exit_section_(b, m, FORTRAN_USER_DEFINED_TYPE_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <Fortran type specification> <Fortran host identifier> [ { <comma> <Fortran host identifier> }... ]
  public static boolean Fortran_variable_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_variable_definition")) return false;
    if (!nextTokenIs(b, _FORTRAN_TYPE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Fortran_type_specification(b, l + 1);
    r = r && Fortran_host_identifier(b, l + 1);
    r = r && Fortran_variable_definition_2(b, l + 1);
    exit_section_(b, m, FORTRAN_VARIABLE_DEFINITION, r);
    return r;
  }

  // [ { <comma> <Fortran host identifier> }... ]
  private static boolean Fortran_variable_definition_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_variable_definition_2")) return false;
    Fortran_variable_definition_2_0(b, l + 1);
    return true;
  }

  // <comma> <Fortran host identifier>
  private static boolean Fortran_variable_definition_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Fortran_variable_definition_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && Fortran_host_identifier(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB AS LOCATOR
  public static boolean MUMPS_BLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_BLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, AS, LOCATOR);
    exit_section_(b, m, MUMPS_BLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB <left paren> <large object length> <right paren>
  public static boolean MUMPS_BLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_BLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    exit_section_(b, m, MUMPS_BLOB_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB AS LOCATOR
  public static boolean MUMPS_CLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_CLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, AS, LOCATOR);
    exit_section_(b, m, MUMPS_CLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB <left paren> <large object length> <right paren>
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  public static boolean MUMPS_CLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_CLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && MUMPS_CLOB_variable_7(b, l + 1);
    exit_section_(b, m, MUMPS_CLOB_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean MUMPS_CLOB_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_CLOB_variable_7")) return false;
    MUMPS_CLOB_variable_7_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean MUMPS_CLOB_variable_7_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_CLOB_variable_7_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && MUMPS_CLOB_variable_7_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean MUMPS_CLOB_variable_7_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_CLOB_variable_7_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <reference type>
  public static boolean MUMPS_REF_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_REF_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _REFERENCE_TYPE_);
    exit_section_(b, m, MUMPS_REF_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <array type> AS LOCATOR
  public static boolean MUMPS_array_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_array_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _ARRAY_TYPE_, AS, LOCATOR);
    exit_section_(b, m, MUMPS_ARRAY_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // VARCHAR <MUMPS host identifier> <MUMPS length specification>
  // 		[ { <comma> <MUMPS host identifier> <MUMPS length specification> }... ]
  public static boolean MUMPS_character_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_character_variable")) return false;
    if (!nextTokenIs(b, VARCHAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, VARCHAR, _MUMPS_HOST_IDENTIFIER_, _MUMPS_LENGTH_SPECIFICATION_);
    r = r && MUMPS_character_variable_3(b, l + 1);
    exit_section_(b, m, MUMPS_CHARACTER_VARIABLE, r);
    return r;
  }

  // [ { <comma> <MUMPS host identifier> <MUMPS length specification> }... ]
  private static boolean MUMPS_character_variable_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_character_variable_3")) return false;
    MUMPS_character_variable_3_0(b, l + 1);
    return true;
  }

  // <comma> <MUMPS host identifier> <MUMPS length specification>
  private static boolean MUMPS_character_variable_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_character_variable_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && MUMPS_host_identifier(b, l + 1);
    r = r && MUMPS_length_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <MUMPS CLOB variable>
  // 	|	<MUMPS BLOB variable>
  // 	|	<MUMPS user-defined type variable>
  // 	|	<MUMPS CLOB locator variable>
  // 	|	<MUMPS BLOB locator variable>
  // 	|	<MUMPS user-defined type locator variable>
  // 	|	<MUMPS array locator variable>
  // 	|	<MUMPS multiset locator variable>
  // 	|	<MUMPS REF variable>
  public static boolean MUMPS_derived_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_derived_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MUMPS_DERIVED_TYPE_SPECIFICATION, "<mumps derived type specification>");
    r = MUMPS_CLOB_variable(b, l + 1);
    if (!r) r = MUMPS_BLOB_variable(b, l + 1);
    if (!r) r = MUMPS_user_defined_type_variable(b, l + 1);
    if (!r) r = MUMPS_CLOB_locator_variable(b, l + 1);
    if (!r) r = MUMPS_BLOB_locator_variable(b, l + 1);
    if (!r) r = MUMPS_user_defined_type_locator_variable(b, l + 1);
    if (!r) r = MUMPS_array_locator_variable(b, l + 1);
    if (!r) r = MUMPS_multiset_locator_variable(b, l + 1);
    if (!r) r = MUMPS_REF_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean MUMPS_host_identifier(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, MUMPS_HOST_IDENTIFIER, true);
    return true;
  }

  /* ********************************************************** */
  // <left paren> <length> <right paren>
  public static boolean MUMPS_length_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_length_specification")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && length(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, MUMPS_LENGTH_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <multiset type> AS LOCATOR
  public static boolean MUMPS_multiset_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_multiset_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _MULTISET_TYPE_, AS, LOCATOR);
    exit_section_(b, m, MUMPS_MULTISET_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <MUMPS type specification> <MUMPS host identifier> [ { <comma> <MUMPS host identifier> }... ]
  public static boolean MUMPS_numeric_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_numeric_variable")) return false;
    if (!nextTokenIs(b, _MUMPS_TYPE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = MUMPS_type_specification(b, l + 1);
    r = r && MUMPS_host_identifier(b, l + 1);
    r = r && MUMPS_numeric_variable_2(b, l + 1);
    exit_section_(b, m, MUMPS_NUMERIC_VARIABLE, r);
    return r;
  }

  // [ { <comma> <MUMPS host identifier> }... ]
  private static boolean MUMPS_numeric_variable_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_numeric_variable_2")) return false;
    MUMPS_numeric_variable_2_0(b, l + 1);
    return true;
  }

  // <comma> <MUMPS host identifier>
  private static boolean MUMPS_numeric_variable_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_numeric_variable_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && MUMPS_host_identifier(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // INT
  // 	|	DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  // 	|	REAL
  public static boolean MUMPS_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MUMPS_TYPE_SPECIFICATION, "<mumps type specification>");
    r = consumeToken(b, INT);
    if (!r) r = MUMPS_type_specification_1(b, l + 1);
    if (!r) r = consumeToken(b, REAL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  private static boolean MUMPS_type_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_type_specification_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DEC);
    r = r && MUMPS_type_specification_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  private static boolean MUMPS_type_specification_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_type_specification_1_1")) return false;
    MUMPS_type_specification_1_1_0(b, l + 1);
    return true;
  }

  // <left paren> <precision> [ <comma> <scale> ] <right paren>
  private static boolean MUMPS_type_specification_1_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_type_specification_1_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && precision(b, l + 1);
    r = r && MUMPS_type_specification_1_1_0_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <comma> <scale> ]
  private static boolean MUMPS_type_specification_1_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_type_specification_1_1_0_2")) return false;
    comma(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
  public static boolean MUMPS_user_defined_type_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_user_defined_type_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, LOCATOR);
    exit_section_(b, m, MUMPS_USER_DEFINED_TYPE_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
  public static boolean MUMPS_user_defined_type_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_user_defined_type_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, _PREDEFINED_TYPE_);
    exit_section_(b, m, MUMPS_USER_DEFINED_TYPE_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <MUMPS numeric variable> <semicolon>
  // 	|	<MUMPS character variable> <semicolon>
  // 	|	<MUMPS derived type specification> <semicolon>
  public static boolean MUMPS_variable_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MUMPS_variable_definition")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MUMPS_VARIABLE_DEFINITION, "<mumps variable definition>");
    r = MUMPS_numeric_variable(b, l + 1);
    if (!r) r = MUMPS_character_variable(b, l + 1);
    if (!r) r = MUMPS_derived_type_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB AS LOCATOR
  public static boolean PL_I_BLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_BLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, AS, LOCATOR);
    exit_section_(b, m, PL_I_BLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB <left paren> <large object length> <right paren>
  public static boolean PL_I_BLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_BLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    exit_section_(b, m, PL_I_BLOB_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB AS LOCATOR
  public static boolean PL_I_CLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_CLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, AS, LOCATOR);
    exit_section_(b, m, PL_I_CLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB <left paren> <large object length> <right paren>
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  public static boolean PL_I_CLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_CLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && PL_I_CLOB_variable_7(b, l + 1);
    exit_section_(b, m, PL_I_CLOB_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean PL_I_CLOB_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_CLOB_variable_7")) return false;
    PL_I_CLOB_variable_7_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean PL_I_CLOB_variable_7_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_CLOB_variable_7_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && PL_I_CLOB_variable_7_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean PL_I_CLOB_variable_7_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_CLOB_variable_7_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <reference type>
  public static boolean PL_I_REF_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_REF_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _REFERENCE_TYPE_);
    exit_section_(b, m, PL_I_REF_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <array type> AS LOCATOR
  public static boolean PL_I_array_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_array_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _ARRAY_TYPE_, AS, LOCATOR);
    exit_section_(b, m, PL_I_ARRAY_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <PL/I CLOB variable>
  // 	|	<PL/I BLOB variable>
  // 	|	<PL/I user-defined type variable>
  // 	|	<PL/I CLOB locator variable>
  // 	|	<PL/I BLOB locator variable>
  // 	|	<PL/I user-defined type locator variable>
  // 	|	<PL/I array locator variable>
  // 	|	<PL/I multiset locator variable>
  // 	|	<PL/I REF variable>
  public static boolean PL_I_derived_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_derived_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PL_I_DERIVED_TYPE_SPECIFICATION, "<pl i derived type specification>");
    r = PL_I_CLOB_variable(b, l + 1);
    if (!r) r = PL_I_BLOB_variable(b, l + 1);
    if (!r) r = PL_I_user_defined_type_variable(b, l + 1);
    if (!r) r = PL_I_CLOB_locator_variable(b, l + 1);
    if (!r) r = PL_I_BLOB_locator_variable(b, l + 1);
    if (!r) r = PL_I_user_defined_type_locator_variable(b, l + 1);
    if (!r) r = PL_I_array_locator_variable(b, l + 1);
    if (!r) r = PL_I_multiset_locator_variable(b, l + 1);
    if (!r) r = PL_I_REF_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean PL_I_host_identifier(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, PL_I_HOST_IDENTIFIER, true);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <multiset type> AS LOCATOR
  public static boolean PL_I_multiset_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_multiset_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _MULTISET_TYPE_, AS, LOCATOR);
    exit_section_(b, m, PL_I_MULTISET_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // { BIN | BINARY } FIXED
  // 	|	FIXED { BIN | BINARY }
  public static boolean PL_I_type_fixed_binary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_binary")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PL_I_TYPE_FIXED_BINARY, "<pl i type fixed binary>");
    r = PL_I_type_fixed_binary_0(b, l + 1);
    if (!r) r = PL_I_type_fixed_binary_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // { BIN | BINARY } FIXED
  private static boolean PL_I_type_fixed_binary_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_binary_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = PL_I_type_fixed_binary_0_0(b, l + 1);
    r = r && consumeToken(b, FIXED);
    exit_section_(b, m, null, r);
    return r;
  }

  // BIN | BINARY
  private static boolean PL_I_type_fixed_binary_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_binary_0_0")) return false;
    boolean r;
    r = consumeToken(b, BIN);
    if (!r) r = consumeToken(b, BINARY);
    return r;
  }

  // FIXED { BIN | BINARY }
  private static boolean PL_I_type_fixed_binary_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_binary_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, FIXED);
    r = r && PL_I_type_fixed_binary_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // BIN | BINARY
  private static boolean PL_I_type_fixed_binary_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_binary_1_1")) return false;
    boolean r;
    r = consumeToken(b, BIN);
    if (!r) r = consumeToken(b, BINARY);
    return r;
  }

  /* ********************************************************** */
  // { DEC | DECIMAL } FIXED
  // 	|	FIXED { DEC | DECIMAL }
  public static boolean PL_I_type_fixed_decimal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_decimal")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PL_I_TYPE_FIXED_DECIMAL, "<pl i type fixed decimal>");
    r = PL_I_type_fixed_decimal_0(b, l + 1);
    if (!r) r = PL_I_type_fixed_decimal_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // { DEC | DECIMAL } FIXED
  private static boolean PL_I_type_fixed_decimal_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_decimal_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = PL_I_type_fixed_decimal_0_0(b, l + 1);
    r = r && consumeToken(b, FIXED);
    exit_section_(b, m, null, r);
    return r;
  }

  // DEC | DECIMAL
  private static boolean PL_I_type_fixed_decimal_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_decimal_0_0")) return false;
    boolean r;
    r = consumeToken(b, DEC);
    if (!r) r = consumeToken(b, DECIMAL);
    return r;
  }

  // FIXED { DEC | DECIMAL }
  private static boolean PL_I_type_fixed_decimal_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_decimal_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, FIXED);
    r = r && PL_I_type_fixed_decimal_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // DEC | DECIMAL
  private static boolean PL_I_type_fixed_decimal_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_fixed_decimal_1_1")) return false;
    boolean r;
    r = consumeToken(b, DEC);
    if (!r) r = consumeToken(b, DECIMAL);
    return r;
  }

  /* ********************************************************** */
  // { BIN | BINARY } FLOAT
  // 	|	FLOAT { BIN | BINARY }
  public static boolean PL_I_type_float_binary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_float_binary")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PL_I_TYPE_FLOAT_BINARY, "<pl i type float binary>");
    r = PL_I_type_float_binary_0(b, l + 1);
    if (!r) r = PL_I_type_float_binary_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // { BIN | BINARY } FLOAT
  private static boolean PL_I_type_float_binary_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_float_binary_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = PL_I_type_float_binary_0_0(b, l + 1);
    r = r && consumeToken(b, FLOAT);
    exit_section_(b, m, null, r);
    return r;
  }

  // BIN | BINARY
  private static boolean PL_I_type_float_binary_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_float_binary_0_0")) return false;
    boolean r;
    r = consumeToken(b, BIN);
    if (!r) r = consumeToken(b, BINARY);
    return r;
  }

  // FLOAT { BIN | BINARY }
  private static boolean PL_I_type_float_binary_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_float_binary_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, FLOAT);
    r = r && PL_I_type_float_binary_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // BIN | BINARY
  private static boolean PL_I_type_float_binary_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_float_binary_1_1")) return false;
    boolean r;
    r = consumeToken(b, BIN);
    if (!r) r = consumeToken(b, BINARY);
    return r;
  }

  /* ********************************************************** */
  // { CHAR | CHARACTER } [ VARYING ] <left paren><length><right paren> [ CHARACTER SET [ IS ] <character set specification> ]
  // 	|	<PL/I type fixed decimal> <left paren> <precision> [ <comma> <scale> ] <right paren>
  // 	|	<PL/I type fixed binary> [ <left paren> <precision> <right paren> ]
  // 	|	<PL/I type float binary> <left paren> <precision> <right paren>
  // 	|	<PL/I derived type specification>
  public static boolean PL_I_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PL_I_TYPE_SPECIFICATION, "<pl i type specification>");
    r = PL_I_type_specification_0(b, l + 1);
    if (!r) r = PL_I_type_specification_1(b, l + 1);
    if (!r) r = PL_I_type_specification_2(b, l + 1);
    if (!r) r = PL_I_type_float_binary(b, l + 1);
    if (!r) r = PL_I_derived_type_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // { CHAR | CHARACTER } [ VARYING ] <left paren><length><right paren> [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean PL_I_type_specification_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = PL_I_type_specification_0_0(b, l + 1);
    r = r && PL_I_type_specification_0_1(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && length(b, l + 1);
    r = r && right_paren(b, l + 1);
    r = r && PL_I_type_specification_0_5(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // CHAR | CHARACTER
  private static boolean PL_I_type_specification_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_0_0")) return false;
    boolean r;
    r = consumeToken(b, CHAR);
    if (!r) r = consumeToken(b, CHARACTER);
    return r;
  }

  // [ VARYING ]
  private static boolean PL_I_type_specification_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_0_1")) return false;
    consumeToken(b, VARYING);
    return true;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean PL_I_type_specification_0_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_0_5")) return false;
    PL_I_type_specification_0_5_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean PL_I_type_specification_0_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_0_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && PL_I_type_specification_0_5_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean PL_I_type_specification_0_5_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_0_5_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // <PL/I type fixed decimal> <left paren> <precision> [ <comma> <scale> ] <right paren>
  private static boolean PL_I_type_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = PL_I_type_fixed_decimal(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && precision(b, l + 1);
    r = r && PL_I_type_specification_1_3(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <comma> <scale> ]
  private static boolean PL_I_type_specification_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_1_3")) return false;
    comma(b, l + 1);
    return true;
  }

  // <PL/I type fixed binary> [ <left paren> <precision> <right paren> ]
  private static boolean PL_I_type_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = PL_I_type_fixed_binary(b, l + 1);
    r = r && PL_I_type_specification_2_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <precision> <right paren> ]
  private static boolean PL_I_type_specification_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_type_specification_2_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
  public static boolean PL_I_user_defined_type_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_user_defined_type_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, LOCATOR);
    exit_section_(b, m, PL_I_USER_DEFINED_TYPE_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
  public static boolean PL_I_user_defined_type_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_user_defined_type_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, _PREDEFINED_TYPE_);
    exit_section_(b, m, PL_I_USER_DEFINED_TYPE_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // { DCL | DECLARE } { <PL/I host identifier>
  // 	|	<left paren> <PL/I host identifier> [ { <comma> <PL/I host identifier> }... ] <right paren> }
  // 		<PL/I type specification> [ <character representation>... ] <semicolon>
  public static boolean PL_I_variable_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_variable_definition")) return false;
    if (!nextTokenIs(b, "<pl i variable definition>", DCL, DECLARE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PL_I_VARIABLE_DEFINITION, "<pl i variable definition>");
    r = PL_I_variable_definition_0(b, l + 1);
    r = r && PL_I_variable_definition_1(b, l + 1);
    r = r && PL_I_type_specification(b, l + 1);
    r = r && PL_I_variable_definition_3(b, l + 1);
    r = r && semicolon(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // DCL | DECLARE
  private static boolean PL_I_variable_definition_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_variable_definition_0")) return false;
    boolean r;
    r = consumeToken(b, DCL);
    if (!r) r = consumeToken(b, DECLARE);
    return r;
  }

  // <PL/I host identifier>
  // 	|	<left paren> <PL/I host identifier> [ { <comma> <PL/I host identifier> }... ] <right paren>
  private static boolean PL_I_variable_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_variable_definition_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = PL_I_host_identifier(b, l + 1);
    if (!r) r = PL_I_variable_definition_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // <left paren> <PL/I host identifier> [ { <comma> <PL/I host identifier> }... ] <right paren>
  private static boolean PL_I_variable_definition_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_variable_definition_1_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && PL_I_host_identifier(b, l + 1);
    r = r && PL_I_variable_definition_1_1_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <PL/I host identifier> }... ]
  private static boolean PL_I_variable_definition_1_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_variable_definition_1_1_2")) return false;
    PL_I_variable_definition_1_1_2_0(b, l + 1);
    return true;
  }

  // <comma> <PL/I host identifier>
  private static boolean PL_I_variable_definition_1_1_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_variable_definition_1_1_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && PL_I_host_identifier(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <character representation>... ]
  private static boolean PL_I_variable_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PL_I_variable_definition_3")) return false;
    consumeToken(b, _CHARACTER_REPRESENTATION____);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB AS LOCATOR
  public static boolean Pascal_BLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_BLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, AS, LOCATOR);
    exit_section_(b, m, PASCAL_BLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS BLOB <left paren> <large object length> <right paren>
  public static boolean Pascal_BLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_BLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, BLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    exit_section_(b, m, PASCAL_BLOB_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB AS LOCATOR
  public static boolean Pascal_CLOB_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_CLOB_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, AS, LOCATOR);
    exit_section_(b, m, PASCAL_CLOB_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS CLOB <left paren> <large object length> <right paren>
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  public static boolean Pascal_CLOB_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_CLOB_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, CLOB, _LEFT_PAREN_, _LARGE_OBJECT_LENGTH_, _RIGHT_PAREN_);
    r = r && Pascal_CLOB_variable_7(b, l + 1);
    exit_section_(b, m, PASCAL_CLOB_VARIABLE, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Pascal_CLOB_variable_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_CLOB_variable_7")) return false;
    Pascal_CLOB_variable_7_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean Pascal_CLOB_variable_7_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_CLOB_variable_7_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && Pascal_CLOB_variable_7_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean Pascal_CLOB_variable_7_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_CLOB_variable_7_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <reference type>
  public static boolean Pascal_REF_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_REF_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _REFERENCE_TYPE_);
    exit_section_(b, m, PASCAL_REF_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <array type> AS LOCATOR
  public static boolean Pascal_array_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_array_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _ARRAY_TYPE_, AS, LOCATOR);
    exit_section_(b, m, PASCAL_ARRAY_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <Pascal CLOB variable>
  // 	|	<Pascal BLOB variable>
  // 	|	<Pascal user-defined type variable>
  // 	|	<Pascal CLOB locator variable>
  // 	|	<Pascal BLOB locator variable>
  // 	|	<Pascal user-defined type locator variable>
  // 	|	<Pascal array locator variable>
  // 	|	<Pascal multiset locator variable>
  // 	|	<Pascal REF variable>
  public static boolean Pascal_derived_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_derived_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PASCAL_DERIVED_TYPE_SPECIFICATION, "<pascal derived type specification>");
    r = Pascal_CLOB_variable(b, l + 1);
    if (!r) r = Pascal_BLOB_variable(b, l + 1);
    if (!r) r = Pascal_user_defined_type_variable(b, l + 1);
    if (!r) r = Pascal_CLOB_locator_variable(b, l + 1);
    if (!r) r = Pascal_BLOB_locator_variable(b, l + 1);
    if (!r) r = Pascal_user_defined_type_locator_variable(b, l + 1);
    if (!r) r = Pascal_array_locator_variable(b, l + 1);
    if (!r) r = Pascal_multiset_locator_variable(b, l + 1);
    if (!r) r = Pascal_REF_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean Pascal_host_identifier(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, PASCAL_HOST_IDENTIFIER, true);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <multiset type> AS LOCATOR
  public static boolean Pascal_multiset_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_multiset_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _MULTISET_TYPE_, AS, LOCATOR);
    exit_section_(b, m, PASCAL_MULTISET_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // PACKED ARRAY <left bracket> 1 <double period> <length> <right bracket> OF CHAR
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  // 	|	INTEGER
  // 	|	REAL
  // 	|	CHAR [ CHARACTER SET [ IS ] <character set specification> ]
  // 	|	BOOLEAN
  // 	|	<Pascal derived type specification>
  public static boolean Pascal_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PASCAL_TYPE_SPECIFICATION, "<pascal type specification>");
    r = Pascal_type_specification_0(b, l + 1);
    if (!r) r = consumeToken(b, INTEGER);
    if (!r) r = consumeToken(b, REAL);
    if (!r) r = Pascal_type_specification_3(b, l + 1);
    if (!r) r = consumeToken(b, BOOLEAN);
    if (!r) r = Pascal_derived_type_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // PACKED ARRAY <left bracket> 1 <double period> <length> <right bracket> OF CHAR
  // 		[ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Pascal_type_specification_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, PACKED, ARRAY, _LEFT_BRACKET_);
    r = r && consumeToken(b, "1");
    r = r && double_period(b, l + 1);
    r = r && length(b, l + 1);
    r = r && consumeTokens(b, 0, _RIGHT_BRACKET_, OF, CHAR);
    r = r && Pascal_type_specification_0_9(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Pascal_type_specification_0_9(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification_0_9")) return false;
    Pascal_type_specification_0_9_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean Pascal_type_specification_0_9_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification_0_9_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && Pascal_type_specification_0_9_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean Pascal_type_specification_0_9_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification_0_9_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  // CHAR [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Pascal_type_specification_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CHAR);
    r = r && Pascal_type_specification_3_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ CHARACTER SET [ IS ] <character set specification> ]
  private static boolean Pascal_type_specification_3_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification_3_1")) return false;
    Pascal_type_specification_3_1_0(b, l + 1);
    return true;
  }

  // CHARACTER SET [ IS ] <character set specification>
  private static boolean Pascal_type_specification_3_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification_3_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, SET);
    r = r && Pascal_type_specification_3_1_0_2(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ IS ]
  private static boolean Pascal_type_specification_3_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_type_specification_3_1_0_2")) return false;
    consumeToken(b, IS);
    return true;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS LOCATOR
  public static boolean Pascal_user_defined_type_locator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_user_defined_type_locator_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, LOCATOR);
    exit_section_(b, m, PASCAL_USER_DEFINED_TYPE_LOCATOR_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // SQL TYPE IS <path-resolved user-defined type name> AS <predefined type>
  public static boolean Pascal_user_defined_type_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_user_defined_type_variable")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, TYPE, IS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, AS, _PREDEFINED_TYPE_);
    exit_section_(b, m, PASCAL_USER_DEFINED_TYPE_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <Pascal host identifier> [ { <comma> <Pascal host identifier> }... ] <colon> <Pascal type specification> <semicolon>
  public static boolean Pascal_variable_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_variable_definition")) return false;
    if (!nextTokenIs(b, _PASCAL_HOST_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Pascal_host_identifier(b, l + 1);
    r = r && Pascal_variable_definition_1(b, l + 1);
    r = r && colon(b, l + 1);
    r = r && Pascal_type_specification(b, l + 1);
    r = r && semicolon(b, l + 1);
    exit_section_(b, m, PASCAL_VARIABLE_DEFINITION, r);
    return r;
  }

  // [ { <comma> <Pascal host identifier> }... ]
  private static boolean Pascal_variable_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_variable_definition_1")) return false;
    Pascal_variable_definition_1_0(b, l + 1);
    return true;
  }

  // <comma> <Pascal host identifier>
  private static boolean Pascal_variable_definition_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Pascal_variable_definition_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && Pascal_host_identifier(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  // 	|	<generalized expression>
  // 	|	<target specification>
  public static boolean SQL_argument(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_argument")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_ARGUMENT, "<sql argument>");
    r = value_expression(b, l + 1);
    if (!r) r = generalized_expression(b, l + 1);
    if (!r) r = target_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <left paren> [ <SQL argument> [ { <comma> <SQL argument> }... ] ] <right paren>
  public static boolean SQL_argument_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_argument_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && SQL_argument_list_1(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, SQL_ARGUMENT_LIST, r);
    return r;
  }

  // [ <SQL argument> [ { <comma> <SQL argument> }... ] ]
  private static boolean SQL_argument_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_argument_list_1")) return false;
    SQL_argument_list_1_0(b, l + 1);
    return true;
  }

  // <SQL argument> [ { <comma> <SQL argument> }... ]
  private static boolean SQL_argument_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_argument_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_argument(b, l + 1);
    r = r && SQL_argument_list_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <SQL argument> }... ]
  private static boolean SQL_argument_list_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_argument_list_1_0_1")) return false;
    SQL_argument_list_1_0_1_0(b, l + 1);
    return true;
  }

  // <comma> <SQL argument>
  private static boolean SQL_argument_list_1_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_argument_list_1_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && SQL_argument(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <major category>
  // 	|	SQLSTATE ( <SQLSTATE class value> [ , <SQLSTATE subclass value> ] )
  // 	|	CONSTRAINT <constraint name>
  public static boolean SQL_condition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_condition")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_CONDITION, "<sql condition>");
    r = major_category(b, l + 1);
    if (!r) r = SQL_condition_1(b, l + 1);
    if (!r) r = parseTokens(b, 0, CONSTRAINT, _CONSTRAINT_NAME_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // SQLSTATE ( <SQLSTATE class value> [ , <SQLSTATE subclass value> ] )
  private static boolean SQL_condition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_condition_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, SQLSTATE);
    r = r && SQL_condition_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // <SQLSTATE class value> [ , <SQLSTATE subclass value> ]
  private static boolean SQL_condition_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_condition_1_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQLSTATE_class_value(b, l + 1);
    r = r && SQL_condition_1_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ , <SQLSTATE subclass value> ]
  private static boolean SQL_condition_1_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_condition_1_1_1")) return false;
    consumeToken(b, SQL_CONDITION_1_1_1_0_0);
    return true;
  }

  /* ********************************************************** */
  // <connect statement>
  // 	|	<set connection statement>
  // 	|	<disconnect statement>
  public static boolean SQL_connection_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_connection_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_CONNECTION_STATEMENT, "<sql connection statement>");
    r = connect_statement(b, l + 1);
    if (!r) r = set_connection_statement(b, l + 1);
    if (!r) r = disconnect_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <call statement>
  // 	|	<return statement>
  public static boolean SQL_control_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_control_statement")) return false;
    if (!nextTokenIs(b, "<sql control statement>", _CALL_STATEMENT_, _RETURN_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_CONTROL_STATEMENT, "<sql control statement>");
    r = call_statement(b, l + 1);
    if (!r) r = return_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <delete statement positioned>
  // 	|	<delete statement searched>
  // 	|	<insert statement>
  // 	|	<update statement positioned>
  // 	|	<update statement searched>
  // 	|	<merge statement>
  public static boolean SQL_data_change_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_data_change_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_DATA_CHANGE_STATEMENT, "<sql data change statement>");
    r = delete_statement_positioned(b, l + 1);
    if (!r) r = delete_statement_searched(b, l + 1);
    if (!r) r = insert_statement(b, l + 1);
    if (!r) r = update_statement_positioned(b, l + 1);
    if (!r) r = update_statement_searched(b, l + 1);
    if (!r) r = merge_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <open statement>
  // 	|	<fetch statement>
  // 	|	<close statement>
  // 	|	<select statement single row>
  // 	|	<free locator statement>
  // 	|	<hold locator statement>
  // 	|	<SQL data change statement>
  public static boolean SQL_data_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_data_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_DATA_STATEMENT, "<sql data statement>");
    r = open_statement(b, l + 1);
    if (!r) r = fetch_statement(b, l + 1);
    if (!r) r = close_statement(b, l + 1);
    if (!r) r = select_statement_single_row(b, l + 1);
    if (!r) r = free_locator_statement(b, l + 1);
    if (!r) r = hold_locator_statement(b, l + 1);
    if (!r) r = SQL_data_change_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <statement information> | <condition information>
  public static boolean SQL_diagnostics_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_diagnostics_information")) return false;
    if (!nextTokenIs(b, "<sql diagnostics information>", _CONDITION_INFORMATION_, _STATEMENT_INFORMATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_DIAGNOSTICS_INFORMATION, "<sql diagnostics information>");
    r = statement_information(b, l + 1);
    if (!r) r = condition_information(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <get diagnostics statement>
  public static boolean SQL_diagnostics_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_diagnostics_statement")) return false;
    if (!nextTokenIs(b, _GET_DIAGNOSTICS_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = get_diagnostics_statement(b, l + 1);
    exit_section_(b, m, SQL_DIAGNOSTICS_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <allocate cursor statement>
  // 	|	<dynamic open statement>
  // 	|	<dynamic fetch statement>
  // 	|	<dynamic close statement>
  // 	|	<dynamic delete statement positioned>
  // 	|	<dynamic update statement positioned>
  public static boolean SQL_dynamic_data_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_dynamic_data_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_DYNAMIC_DATA_STATEMENT, "<sql dynamic data statement>");
    r = allocate_cursor_statement(b, l + 1);
    if (!r) r = dynamic_open_statement(b, l + 1);
    if (!r) r = dynamic_fetch_statement(b, l + 1);
    if (!r) r = dynamic_close_statement(b, l + 1);
    if (!r) r = dynamic_delete_statement_positioned(b, l + 1);
    if (!r) r = dynamic_update_statement_positioned(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <system descriptor statement>
  // 	|	<prepare statement>
  // 	|	<deallocate prepared statement>
  // 	|	<describe statement>
  // 	|	<execute statement>
  // 	|	<execute immediate statement>
  // 	|	<SQL dynamic data statement>
  public static boolean SQL_dynamic_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_dynamic_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_DYNAMIC_STATEMENT, "<sql dynamic statement>");
    r = system_descriptor_statement(b, l + 1);
    if (!r) r = prepare_statement(b, l + 1);
    if (!r) r = deallocate_prepared_statement(b, l + 1);
    if (!r) r = describe_statement(b, l + 1);
    if (!r) r = execute_statement(b, l + 1);
    if (!r) r = execute_immediate_statement(b, l + 1);
    if (!r) r = SQL_dynamic_data_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL schema statement>
  // 	|	<SQL data statement>
  // 	|	<SQL control statement>
  // 	|	<SQL transaction statement>
  // 	|	<SQL connection statement>
  // 	|	<SQL session statement>
  // 	|	<SQL diagnostics statement>
  // 	|	<SQL dynamic statement>
  public static boolean SQL_executable_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_executable_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_EXECUTABLE_STATEMENT, "<sql executable statement>");
    r = SQL_schema_statement(b, l + 1);
    if (!r) r = SQL_data_statement(b, l + 1);
    if (!r) r = SQL_control_statement(b, l + 1);
    if (!r) r = SQL_transaction_statement(b, l + 1);
    if (!r) r = SQL_connection_statement(b, l + 1);
    if (!r) r = SQL_session_statement(b, l + 1);
    if (!r) r = SQL_diagnostics_statement(b, l + 1);
    if (!r) r = SQL_dynamic_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <simple Latin letter> | <digit> | <SQL special character>
  public static boolean SQL_language_character(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_language_character")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_LANGUAGE_CHARACTER, "<sql language character>");
    r = simple_Latin_letter(b, l + 1);
    if (!r) r = digit(b, l + 1);
    if (!r) r = SQL_special_character(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL language identifier start> [ { <underscore> | <SQL language identifier part> }... ]
  public static boolean SQL_language_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_language_identifier")) return false;
    if (!nextTokenIs(b, _SQL_LANGUAGE_IDENTIFIER_START_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_language_identifier_start(b, l + 1);
    r = r && SQL_language_identifier_1(b, l + 1);
    exit_section_(b, m, SQL_LANGUAGE_IDENTIFIER, r);
    return r;
  }

  // [ { <underscore> | <SQL language identifier part> }... ]
  private static boolean SQL_language_identifier_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_language_identifier_1")) return false;
    SQL_language_identifier_1_0(b, l + 1);
    return true;
  }

  // <underscore> | <SQL language identifier part>
  private static boolean SQL_language_identifier_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_language_identifier_1_0")) return false;
    boolean r;
    r = underscore(b, l + 1);
    if (!r) r = SQL_language_identifier_part(b, l + 1);
    return r;
  }

  /* ********************************************************** */
  // <simple Latin letter> | <digit>
  public static boolean SQL_language_identifier_part(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_language_identifier_part")) return false;
    if (!nextTokenIs(b, "<sql language identifier part>", _DIGIT_, _SIMPLE_LATIN_LETTER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_LANGUAGE_IDENTIFIER_PART, "<sql language identifier part>");
    r = simple_Latin_letter(b, l + 1);
    if (!r) r = digit(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <simple Latin letter>
  public static boolean SQL_language_identifier_start(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_language_identifier_start")) return false;
    if (!nextTokenIs(b, _SIMPLE_LATIN_LETTER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_Latin_letter(b, l + 1);
    exit_section_(b, m, SQL_LANGUAGE_IDENTIFIER_START, r);
    return r;
  }

  /* ********************************************************** */
  // [ <parameter mode> ] [ <SQL parameter name> ] <parameter type> [ RESULT ]
  public static boolean SQL_parameter_declaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_PARAMETER_DECLARATION, "<sql parameter declaration>");
    r = SQL_parameter_declaration_0(b, l + 1);
    r = r && SQL_parameter_declaration_1(b, l + 1);
    r = r && parameter_type(b, l + 1);
    r = r && SQL_parameter_declaration_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <parameter mode> ]
  private static boolean SQL_parameter_declaration_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration_0")) return false;
    parameter_mode(b, l + 1);
    return true;
  }

  // [ <SQL parameter name> ]
  private static boolean SQL_parameter_declaration_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration_1")) return false;
    SQL_parameter_name(b, l + 1);
    return true;
  }

  // [ RESULT ]
  private static boolean SQL_parameter_declaration_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration_3")) return false;
    consumeToken(b, RESULT);
    return true;
  }

  /* ********************************************************** */
  // <left paren> [ <SQL parameter declaration> [ { <comma> <SQL parameter declaration> }... ] ] <right paren>
  public static boolean SQL_parameter_declaration_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && SQL_parameter_declaration_list_1(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, SQL_PARAMETER_DECLARATION_LIST, r);
    return r;
  }

  // [ <SQL parameter declaration> [ { <comma> <SQL parameter declaration> }... ] ]
  private static boolean SQL_parameter_declaration_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration_list_1")) return false;
    SQL_parameter_declaration_list_1_0(b, l + 1);
    return true;
  }

  // <SQL parameter declaration> [ { <comma> <SQL parameter declaration> }... ]
  private static boolean SQL_parameter_declaration_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_parameter_declaration(b, l + 1);
    r = r && SQL_parameter_declaration_list_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <SQL parameter declaration> }... ]
  private static boolean SQL_parameter_declaration_list_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration_list_1_0_1")) return false;
    SQL_parameter_declaration_list_1_0_1_0(b, l + 1);
    return true;
  }

  // <comma> <SQL parameter declaration>
  private static boolean SQL_parameter_declaration_list_1_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_declaration_list_1_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && SQL_parameter_declaration(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean SQL_parameter_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, SQL_PARAMETER_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <basic identifier chain>
  public static boolean SQL_parameter_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_parameter_reference")) return false;
    if (!nextTokenIs(b, _BASIC_IDENTIFIER_CHAIN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = basic_identifier_chain(b, l + 1);
    exit_section_(b, m, SQL_PARAMETER_REFERENCE, r);
    return r;
  }

  /* ********************************************************** */
  // EXEC SQL | <ampersand>SQL<left paren>
  public static boolean SQL_prefix(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_prefix")) return false;
    if (!nextTokenIs(b, "<sql prefix>", EXEC, _AMPERSAND_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_PREFIX, "<sql prefix>");
    r = parseTokens(b, 0, EXEC, SQL);
    if (!r) r = ampersand(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL executable statement>
  public static boolean SQL_procedure_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_procedure_statement")) return false;
    if (!nextTokenIs(b, _SQL_EXECUTABLE_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_executable_statement(b, l + 1);
    exit_section_(b, m, SQL_PROCEDURE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <SQL procedure statement>
  public static boolean SQL_routine_body(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_routine_body")) return false;
    if (!nextTokenIs(b, _SQL_PROCEDURE_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_procedure_statement(b, l + 1);
    exit_section_(b, m, SQL_ROUTINE_BODY, r);
    return r;
  }

  /* ********************************************************** */
  // [ <rights clause> ] <SQL routine body>
  public static boolean SQL_routine_spec(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_routine_spec")) return false;
    if (!nextTokenIs(b, "<sql routine spec>", _RIGHTS_CLAUSE_, _SQL_ROUTINE_BODY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_ROUTINE_SPEC, "<sql routine spec>");
    r = SQL_routine_spec_0(b, l + 1);
    r = r && SQL_routine_body(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <rights clause> ]
  private static boolean SQL_routine_spec_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_routine_spec_0")) return false;
    rights_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <schema definition>
  // 	|	<table definition>
  // 	|	<view definition>
  // 	|	<SQL-invoked routine>
  // 	|	<grant statement>
  // 	|	<role definition>
  // 	|	<domain definition>
  // 	|	<character set definition>
  // 	|	<collation definition>
  // 	|	<transliteration definition>
  // 	|	<assertion definition>
  // 	|	<trigger definition>
  // 	|	<user-defined type definition>
  // 	|	<user-defined cast definition>
  // 	|	<user-defined ordering definition>
  // 	|	<transform definition>
  // 	|	<sequence generator definition>
  public static boolean SQL_schema_definition_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_schema_definition_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_SCHEMA_DEFINITION_STATEMENT, "<sql schema definition statement>");
    r = schema_definition(b, l + 1);
    if (!r) r = table_definition(b, l + 1);
    if (!r) r = view_definition(b, l + 1);
    if (!r) r = SQL_invoked_routine(b, l + 1);
    if (!r) r = grant_statement(b, l + 1);
    if (!r) r = role_definition(b, l + 1);
    if (!r) r = domain_definition(b, l + 1);
    if (!r) r = character_set_definition(b, l + 1);
    if (!r) r = collation_definition(b, l + 1);
    if (!r) r = transliteration_definition(b, l + 1);
    if (!r) r = assertion_definition(b, l + 1);
    if (!r) r = trigger_definition(b, l + 1);
    if (!r) r = user_defined_type_definition(b, l + 1);
    if (!r) r = user_defined_cast_definition(b, l + 1);
    if (!r) r = user_defined_ordering_definition(b, l + 1);
    if (!r) r = transform_definition(b, l + 1);
    if (!r) r = sequence_generator_definition(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <drop schema statement>
  // 	|	<alter table statement>
  // 	|	<drop table statement>
  // 	|	<drop view statement>
  // 	|	<alter routine statement>
  // 	|	<drop routine statement>
  // 	|	<drop user-defined cast statement>
  // 	|	<revoke statement>
  // 	|	<drop role statement>
  // 	|	<alter domain statement>
  // 	|	<drop domain statement>
  // 	|	<drop character set statement>
  // 	|	<drop collation statement>
  // 	|	<drop transliteration statement>
  // 	|	<drop assertion statement>
  // 	|	<drop trigger statement>
  // 	|	<alter type statement>
  // 	|	<drop data type statement>
  // 	|	<drop user-defined ordering statement>
  // 	|	<alter transform statement>
  // 	|	<drop transform statement> | <alter sequence generator statement>
  // 	|	<drop sequence generator statement>
  public static boolean SQL_schema_manipulation_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_schema_manipulation_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_SCHEMA_MANIPULATION_STATEMENT, "<sql schema manipulation statement>");
    r = drop_schema_statement(b, l + 1);
    if (!r) r = alter_table_statement(b, l + 1);
    if (!r) r = drop_table_statement(b, l + 1);
    if (!r) r = drop_view_statement(b, l + 1);
    if (!r) r = alter_routine_statement(b, l + 1);
    if (!r) r = drop_routine_statement(b, l + 1);
    if (!r) r = drop_user_defined_cast_statement(b, l + 1);
    if (!r) r = revoke_statement(b, l + 1);
    if (!r) r = drop_role_statement(b, l + 1);
    if (!r) r = alter_domain_statement(b, l + 1);
    if (!r) r = drop_domain_statement(b, l + 1);
    if (!r) r = drop_character_set_statement(b, l + 1);
    if (!r) r = drop_collation_statement(b, l + 1);
    if (!r) r = drop_transliteration_statement(b, l + 1);
    if (!r) r = drop_assertion_statement(b, l + 1);
    if (!r) r = drop_trigger_statement(b, l + 1);
    if (!r) r = alter_type_statement(b, l + 1);
    if (!r) r = drop_data_type_statement(b, l + 1);
    if (!r) r = drop_user_defined_ordering_statement(b, l + 1);
    if (!r) r = alter_transform_statement(b, l + 1);
    if (!r) r = drop_transform_statement(b, l + 1);
    if (!r) r = alter_sequence_generator_statement(b, l + 1);
    if (!r) r = drop_sequence_generator_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL schema definition statement>
  // 	|	<SQL schema manipulation statement>
  public static boolean SQL_schema_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_schema_statement")) return false;
    if (!nextTokenIs(b, "<sql schema statement>", _SQL_SCHEMA_DEFINITION_STATEMENT_, _SQL_SCHEMA_MANIPULATION_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_SCHEMA_STATEMENT, "<sql schema statement>");
    r = SQL_schema_definition_statement(b, l + 1);
    if (!r) r = SQL_schema_manipulation_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <set session user identifier statement>
  // 	|	<set role statement>
  // 	|	<set local time zone statement>
  // 	|	<set session characteristics statement>
  // 	|	<set catalog statement>
  // 	|	<set schema statement>
  // 	|	<set names statement>
  // 	|	<set path statement>
  // 	|	<set transform group statement>
  // 	|	<set session collation statement>
  public static boolean SQL_session_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_session_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_SESSION_STATEMENT, "<sql session statement>");
    r = set_session_user_identifier_statement(b, l + 1);
    if (!r) r = set_role_statement(b, l + 1);
    if (!r) r = set_local_time_zone_statement(b, l + 1);
    if (!r) r = set_session_characteristics_statement(b, l + 1);
    if (!r) r = set_catalog_statement(b, l + 1);
    if (!r) r = set_schema_statement(b, l + 1);
    if (!r) r = set_names_statement(b, l + 1);
    if (!r) r = set_path_statement(b, l + 1);
    if (!r) r = set_transform_group_statement(b, l + 1);
    if (!r) r = set_session_collation_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <space>
  // 	|	<double quote>
  // 	|	<percent>
  // 	|	<ampersand>
  // 	|	<quote>
  // 	|	<left paren>
  // 	|	<right paren>
  // 	|	<asterisk>
  // 	|	<plus sign>
  // 	|	<comma>
  // 	|	<minus sign>
  // 	|	<period>
  // 	|	<solidus>
  // 	|	<colon>
  // 	|	<semicolon>
  // 	|	<less than operator>
  // 	|	<equals operator>
  // 	|	<greater than operator>
  // 	|	<question mark>
  // 	|	<left bracket>
  // 	|	<right bracket>
  // 	|	<circumflex>
  // 	|	<underscore>
  // 	|	<vertical bar>
  // 	|	<left brace>
  // 	|	<right brace>
  public static boolean SQL_special_character(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_special_character")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_SPECIAL_CHARACTER, "<sql special character>");
    r = space(b, l + 1);
    if (!r) r = double_quote(b, l + 1);
    if (!r) r = percent(b, l + 1);
    if (!r) r = ampersand(b, l + 1);
    if (!r) r = quote(b, l + 1);
    if (!r) r = left_paren(b, l + 1);
    if (!r) r = right_paren(b, l + 1);
    if (!r) r = asterisk(b, l + 1);
    if (!r) r = plus_sign(b, l + 1);
    if (!r) r = comma(b, l + 1);
    if (!r) r = minus_sign(b, l + 1);
    if (!r) r = period(b, l + 1);
    if (!r) r = solidus(b, l + 1);
    if (!r) r = colon(b, l + 1);
    if (!r) r = semicolon(b, l + 1);
    if (!r) r = less_than_operator(b, l + 1);
    if (!r) r = equals_operator(b, l + 1);
    if (!r) r = greater_than_operator(b, l + 1);
    if (!r) r = question_mark(b, l + 1);
    if (!r) r = left_bracket(b, l + 1);
    if (!r) r = consumeToken(b, _RIGHT_BRACKET_);
    if (!r) r = circumflex(b, l + 1);
    if (!r) r = underscore(b, l + 1);
    if (!r) r = vertical_bar(b, l + 1);
    if (!r) r = left_brace(b, l + 1);
    if (!r) r = right_brace(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <statement name> | <extended statement name>
  public static boolean SQL_statement_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_statement_name")) return false;
    if (!nextTokenIs(b, "<sql statement name>", _EXTENDED_STATEMENT_NAME_, _STATEMENT_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_STATEMENT_NAME, "<sql statement name>");
    r = statement_name(b, l + 1);
    if (!r) r = extended_statement_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean SQL_statement_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_statement_variable")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, SQL_STATEMENT_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <SQL language character>
  static boolean SQL_terminal_character(PsiBuilder b, int l) {
    return SQL_language_character(b, l + 1);
  }

  /* ********************************************************** */
  // END-EXEC | <semicolon> | <right paren>
  public static boolean SQL_terminator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_terminator")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_TERMINATOR, "<sql terminator>");
    r = consumeToken(b, END_EXEC);
    if (!r) r = semicolon(b, l + 1);
    if (!r) r = right_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <start transaction statement>
  // 	|	<set transaction statement>
  // 	|	<set constraints mode statement>
  // 	|	<savepoint statement>
  // 	|	<release savepoint statement>
  // 	|	<commit statement>
  // 	|	<rollback statement>
  public static boolean SQL_transaction_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_transaction_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_TRANSACTION_STATEMENT, "<sql transaction statement>");
    r = start_transaction_statement(b, l + 1);
    if (!r) r = set_transaction_statement(b, l + 1);
    if (!r) r = set_constraints_mode_statement(b, l + 1);
    if (!r) r = savepoint_statement(b, l + 1);
    if (!r) r = release_savepoint_statement(b, l + 1);
    if (!r) r = commit_statement(b, l + 1);
    if (!r) r = rollback_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <module name clause> <language clause> <module authorization clause>
  // 		[ <module path specification> ]
  // 		[ <module transform group specification> ]
  // 		[ <module collation> ]
  // 		[ <temporary table declaration>... ]
  // 		<module contents>...
  public static boolean SQL_client_module_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_client_module_definition")) return false;
    if (!nextTokenIs(b, _MODULE_NAME_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = module_name_clause(b, l + 1);
    r = r && language_clause(b, l + 1);
    r = r && module_authorization_clause(b, l + 1);
    r = r && SQL_client_module_definition_3(b, l + 1);
    r = r && SQL_client_module_definition_4(b, l + 1);
    r = r && SQL_client_module_definition_5(b, l + 1);
    r = r && SQL_client_module_definition_6(b, l + 1);
    r = r && module_contents(b, l + 1);
    exit_section_(b, m, SQL_CLIENT_MODULE_DEFINITION, r);
    return r;
  }

  // [ <module path specification> ]
  private static boolean SQL_client_module_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_client_module_definition_3")) return false;
    module_path_specification(b, l + 1);
    return true;
  }

  // [ <module transform group specification> ]
  private static boolean SQL_client_module_definition_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_client_module_definition_4")) return false;
    module_transform_group_specification(b, l + 1);
    return true;
  }

  // [ <module collation> ]
  private static boolean SQL_client_module_definition_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_client_module_definition_5")) return false;
    consumeToken(b, _MODULE_COLLATION_);
    return true;
  }

  // [ <temporary table declaration>... ]
  private static boolean SQL_client_module_definition_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_client_module_definition_6")) return false;
    consumeToken(b, _TEMPORARY_TABLE_DECLARATION____);
    return true;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean SQL_client_module_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_client_module_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, SQL_CLIENT_MODULE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // NO SQL
  // 	|	CONTAINS SQL
  // 	|	READS SQL DATA
  // 	|	MODIFIES SQL DATA
  public static boolean SQL_data_access_indication(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_data_access_indication")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_DATA_ACCESS_INDICATION, "<sql data access indication>");
    r = parseTokens(b, 0, NO, SQL);
    if (!r) r = parseTokens(b, 0, CONTAINS, SQL);
    if (!r) r = parseTokens(b, 0, READS, SQL, DATA);
    if (!r) r = parseTokens(b, 0, MODIFIES, SQL, DATA);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // { <function specification> | <method specification designator> } <routine body>
  public static boolean SQL_invoked_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_invoked_function")) return false;
    if (!nextTokenIs(b, "<sql invoked function>", _FUNCTION_SPECIFICATION_, _METHOD_SPECIFICATION_DESIGNATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQL_INVOKED_FUNCTION, "<sql invoked function>");
    r = SQL_invoked_function_0(b, l + 1);
    r = r && routine_body(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <function specification> | <method specification designator>
  private static boolean SQL_invoked_function_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_invoked_function_0")) return false;
    boolean r;
    r = function_specification(b, l + 1);
    if (!r) r = method_specification_designator(b, l + 1);
    return r;
  }

  /* ********************************************************** */
  // PROCEDURE <schema qualified routine name> <SQL parameter declaration list> <routine characteristics> <routine body>
  public static boolean SQL_invoked_procedure(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_invoked_procedure")) return false;
    if (!nextTokenIs(b, PROCEDURE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, PROCEDURE, _SCHEMA_QUALIFIED_ROUTINE_NAME_, _SQL_PARAMETER_DECLARATION_LIST_, _ROUTINE_CHARACTERISTICS_, _ROUTINE_BODY_);
    exit_section_(b, m, SQL_INVOKED_PROCEDURE, r);
    return r;
  }

  /* ********************************************************** */
  // <schema routine>
  public static boolean SQL_invoked_routine(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_invoked_routine")) return false;
    if (!nextTokenIs(b, _SCHEMA_ROUTINE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_routine(b, l + 1);
    exit_section_(b, m, SQL_INVOKED_ROUTINE, r);
    return r;
  }

  /* ********************************************************** */
  // PATH <value specification>
  public static boolean SQL_path_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_path_characteristic")) return false;
    if (!nextTokenIs(b, PATH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, PATH, _VALUE_SPECIFICATION_);
    exit_section_(b, m, SQL_PATH_CHARACTERISTIC, r);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean SQL_server_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQL_server_name")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, SQL_SERVER_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <simple Latin upper case letter> | <digit>
  public static boolean SQLSTATE_char(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQLSTATE_char")) return false;
    if (!nextTokenIs(b, "<sqlstate char>", _DIGIT_, _SIMPLE_LATIN_UPPER_CASE_LETTER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SQLSTATE_CHAR, "<sqlstate char>");
    r = simple_Latin_upper_case_letter(b, l + 1);
    if (!r) r = digit(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQLSTATE char><SQLSTATE char> !! See the Syntax Rules.
  public static boolean SQLSTATE_class_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQLSTATE_class_value")) return false;
    if (!nextTokenIs(b, _SQLSTATE_CHAR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQLSTATE_char(b, l + 1);
    r = r && SQLSTATE_char(b, l + 1);
    exit_section_(b, m, SQLSTATE_CLASS_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <SQLSTATE char><SQLSTATE char><SQLSTATE char> !! See the Syntax Rules.
  public static boolean SQLSTATE_subclass_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "SQLSTATE_subclass_value")) return false;
    if (!nextTokenIs(b, _SQLSTATE_CHAR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQLSTATE_char(b, l + 1);
    r = r && SQLSTATE_char(b, l + 1);
    r = r && SQLSTATE_char(b, l + 1);
    exit_section_(b, m, SQLSTATE_SUBCLASS_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <Unicode escape character><hexit><hexit><hexit><hexit>
  // <Unicode escape character><plus sign><hexit><hexit><hexit><hexit><hexit><hexit>
  public static boolean Unicode_4_digit_escape_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_4_digit_escape_value")) return false;
    if (!nextTokenIs(b, _UNICODE_ESCAPE_CHARACTER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, _UNICODE_ESCAPE_CHARACTER_, _HEXIT_, _HEXIT_, _HEXIT_, _HEXIT_, _UNICODE_ESCAPE_CHARACTER_, _PLUS_SIGN_, _HEXIT_, _HEXIT_, _HEXIT_, _HEXIT_, _HEXIT_, _HEXIT_);
    exit_section_(b, m, UNICODE_4_DIGIT_ESCAPE_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <Unicode escape character><Unicode escape character>
  public static boolean Unicode_character_escape_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_character_escape_value")) return false;
    if (!nextTokenIs(b, _UNICODE_ESCAPE_CHARACTER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, _UNICODE_ESCAPE_CHARACTER_, _UNICODE_ESCAPE_CHARACTER_);
    exit_section_(b, m, UNICODE_CHARACTER_ESCAPE_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // [ <introducer><character set specification> ]
  // 		U<ampersand><quote> [ <Unicode representation>... ] <quote>
  // 		[ { <separator> <quote> [ <Unicode representation>... ] <quote> }... ]
  // 		[ ESCAPE <escape character> ]
  public static boolean Unicode_character_string_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_character_string_literal")) return false;
    if (!nextTokenIs(b, "<unicode character string literal>", U, _INTRODUCER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNICODE_CHARACTER_STRING_LITERAL, "<unicode character string literal>");
    r = Unicode_character_string_literal_0(b, l + 1);
    r = r && consumeTokens(b, 0, U, _AMPERSAND_, _QUOTE_);
    r = r && Unicode_character_string_literal_4(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && Unicode_character_string_literal_6(b, l + 1);
    r = r && Unicode_character_string_literal_7(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <introducer><character set specification> ]
  private static boolean Unicode_character_string_literal_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_character_string_literal_0")) return false;
    introducer(b, l + 1);
    return true;
  }

  // [ <Unicode representation>... ]
  private static boolean Unicode_character_string_literal_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_character_string_literal_4")) return false;
    consumeToken(b, _UNICODE_REPRESENTATION____);
    return true;
  }

  // [ { <separator> <quote> [ <Unicode representation>... ] <quote> }... ]
  private static boolean Unicode_character_string_literal_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_character_string_literal_6")) return false;
    Unicode_character_string_literal_6_0(b, l + 1);
    return true;
  }

  // <separator> <quote> [ <Unicode representation>... ] <quote>
  private static boolean Unicode_character_string_literal_6_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_character_string_literal_6_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = separator(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && Unicode_character_string_literal_6_0_2(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <Unicode representation>... ]
  private static boolean Unicode_character_string_literal_6_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_character_string_literal_6_0_2")) return false;
    consumeToken(b, _UNICODE_REPRESENTATION____);
    return true;
  }

  // [ ESCAPE <escape character> ]
  private static boolean Unicode_character_string_literal_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_character_string_literal_7")) return false;
    parseTokens(b, 0, ESCAPE, _ESCAPE_CHARACTER_);
    return true;
  }

  /* ********************************************************** */
  // <Unicode identifier part>...
  public static boolean Unicode_delimiter_body(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_delimiter_body")) return false;
    if (!nextTokenIs(b, _UNICODE_IDENTIFIER_PART____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _UNICODE_IDENTIFIER_PART____);
    exit_section_(b, m, UNICODE_DELIMITER_BODY, r);
    return r;
  }

  /* ********************************************************** */
  // [ UESCAPE <quote> <Unicode escape character> <quote> ]
  public static boolean Unicode_escape_specifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_escape_specifier")) return false;
    Marker m = enter_section_(b, l, _NONE_, UNICODE_ESCAPE_SPECIFIER, "<unicode escape specifier>");
    parseTokens(b, 0, UESCAPE, _QUOTE_, _UNICODE_ESCAPE_CHARACTER_, _QUOTE_);
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  /* ********************************************************** */
  // <Unicode 4 digit escape value>
  // 	|	<Unicode 6 digit escape value>
  // 	|	<Unicode character escape value>
  public static boolean Unicode_escape_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_escape_value")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNICODE_ESCAPE_VALUE, "<unicode escape value>");
    r = Unicode_4_digit_escape_value(b, l + 1);
    if (!r) r = consumeToken(b, _UNICODE_6_DIGIT_ESCAPE_VALUE_);
    if (!r) r = Unicode_character_escape_value(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <delimited identifier part> | <Unicode escape value>
  public static boolean Unicode_identifier_part(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_identifier_part")) return false;
    if (!nextTokenIs(b, "<unicode identifier part>", _DELIMITED_IDENTIFIER_PART_, _UNICODE_ESCAPE_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNICODE_IDENTIFIER_PART, "<unicode identifier part>");
    r = delimited_identifier_part(b, l + 1);
    if (!r) r = Unicode_escape_value(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character representation> | <Unicode escape value>
  public static boolean Unicode_representation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Unicode_representation")) return false;
    if (!nextTokenIs(b, "<unicode representation>", _CHARACTER_REPRESENTATION_, _UNICODE_ESCAPE_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNICODE_REPRESENTATION, "<unicode representation>");
    r = character_representation(b, l + 1);
    if (!r) r = Unicode_escape_value(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ABS <left paren> <numeric value expression> <right paren>
  public static boolean absolute_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "absolute_value_expression")) return false;
    if (!nextTokenIs(b, ABS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ABS, _LEFT_PAREN_, _NUMERIC_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, ABSOLUTE_VALUE_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // SELECT
  // 	|	SELECT <left paren> <privilege column list> <right paren>
  // 	|	SELECT <left paren> <privilege method list> <right paren>
  // 	|	DELETE
  // 	|	INSERT [ <left paren> <privilege column list> <right paren> ]
  // 	|	UPDATE [ <left paren> <privilege column list> <right paren> ]
  // 	|	REFERENCES [ <left paren> <privilege column list> <right paren> ]
  // 	|	USAGE
  // 	|	TRIGGER
  // 	|	UNDER
  // 	|	EXECUTE
  public static boolean action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "action")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ACTION, "<action>");
    r = consumeToken(b, SELECT);
    if (!r) r = parseTokens(b, 0, SELECT, _LEFT_PAREN_, _PRIVILEGE_COLUMN_LIST_, _RIGHT_PAREN_);
    if (!r) r = parseTokens(b, 0, SELECT, _LEFT_PAREN_, _PRIVILEGE_METHOD_LIST_, _RIGHT_PAREN_);
    if (!r) r = consumeToken(b, DELETE);
    if (!r) r = action_4(b, l + 1);
    if (!r) r = action_5(b, l + 1);
    if (!r) r = action_6(b, l + 1);
    if (!r) r = consumeToken(b, USAGE);
    if (!r) r = consumeToken(b, TRIGGER);
    if (!r) r = consumeToken(b, UNDER);
    if (!r) r = consumeToken(b, EXECUTE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // INSERT [ <left paren> <privilege column list> <right paren> ]
  private static boolean action_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "action_4")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, INSERT);
    r = r && action_4_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <privilege column list> <right paren> ]
  private static boolean action_4_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "action_4_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // UPDATE [ <left paren> <privilege column list> <right paren> ]
  private static boolean action_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "action_5")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, UPDATE);
    r = r && action_5_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <privilege column list> <right paren> ]
  private static boolean action_5_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "action_5_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // REFERENCES [ <left paren> <privilege column list> <right paren> ]
  private static boolean action_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "action_6")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, REFERENCES);
    r = r && action_6_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <privilege column list> <right paren> ]
  private static boolean action_6_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "action_6_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <regular identifier> | <delimited identifier>
  public static boolean actual_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "actual_identifier")) return false;
    if (!nextTokenIs(b, "<actual identifier>", _DELIMITED_IDENTIFIER_, _REGULAR_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ACTUAL_IDENTIFIER, "<actual identifier>");
    r = regular_identifier(b, l + 1);
    if (!r) r = delimited_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ADD ATTRIBUTE <attribute definition>
  public static boolean add_attribute_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_attribute_definition")) return false;
    if (!nextTokenIs(b, ADD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ADD, ATTRIBUTE, _ATTRIBUTE_DEFINITION_);
    exit_section_(b, m, ADD_ATTRIBUTE_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // ADD [ COLUMN ] <column definition>
  public static boolean add_column_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_column_definition")) return false;
    if (!nextTokenIs(b, ADD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ADD);
    r = r && add_column_definition_1(b, l + 1);
    r = r && column_definition(b, l + 1);
    exit_section_(b, m, ADD_COLUMN_DEFINITION, r);
    return r;
  }

  // [ COLUMN ]
  private static boolean add_column_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_column_definition_1")) return false;
    consumeToken(b, COLUMN);
    return true;
  }

  /* ********************************************************** */
  // ADD <scope clause>
  public static boolean add_column_scope_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_column_scope_clause")) return false;
    if (!nextTokenIs(b, ADD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ADD, _SCOPE_CLAUSE_);
    exit_section_(b, m, ADD_COLUMN_SCOPE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // ADD <domain constraint>
  public static boolean add_domain_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_domain_constraint_definition")) return false;
    if (!nextTokenIs(b, ADD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ADD, _DOMAIN_CONSTRAINT_);
    exit_section_(b, m, ADD_DOMAIN_CONSTRAINT_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // ADD <original method specification>
  public static boolean add_original_method_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_original_method_specification")) return false;
    if (!nextTokenIs(b, ADD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ADD, _ORIGINAL_METHOD_SPECIFICATION_);
    exit_section_(b, m, ADD_ORIGINAL_METHOD_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // ADD <overriding method specification>
  public static boolean add_overriding_method_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_overriding_method_specification")) return false;
    if (!nextTokenIs(b, ADD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ADD, _OVERRIDING_METHOD_SPECIFICATION_);
    exit_section_(b, m, ADD_OVERRIDING_METHOD_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // ADD <table constraint definition>
  public static boolean add_table_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_table_constraint_definition")) return false;
    if (!nextTokenIs(b, ADD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ADD, _TABLE_CONSTRAINT_DEFINITION_);
    exit_section_(b, m, ADD_TABLE_CONSTRAINT_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // ADD <left paren> <transform element list> <right paren>
  public static boolean add_transform_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "add_transform_element_list")) return false;
    if (!nextTokenIs(b, ADD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ADD, _LEFT_PAREN_, _TRANSFORM_ELEMENT_LIST_, _RIGHT_PAREN_);
    exit_section_(b, m, ADD_TRANSFORM_ELEMENT_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // COUNT <left paren> <asterisk> <right paren> [ <filter clause> ]
  // 	|	<general set function> [ <filter clause> ]
  // 	|	<binary set function> [ <filter clause> ]
  // 	|	<ordered set function> [ <filter clause> ]
  public static boolean aggregate_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, AGGREGATE_FUNCTION, "<aggregate function>");
    r = aggregate_function_0(b, l + 1);
    if (!r) r = aggregate_function_1(b, l + 1);
    if (!r) r = aggregate_function_2(b, l + 1);
    if (!r) r = aggregate_function_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // COUNT <left paren> <asterisk> <right paren> [ <filter clause> ]
  private static boolean aggregate_function_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, COUNT, _LEFT_PAREN_, _ASTERISK_, _RIGHT_PAREN_);
    r = r && aggregate_function_0_4(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <filter clause> ]
  private static boolean aggregate_function_0_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function_0_4")) return false;
    filter_clause(b, l + 1);
    return true;
  }

  // <general set function> [ <filter clause> ]
  private static boolean aggregate_function_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = general_set_function(b, l + 1);
    r = r && aggregate_function_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <filter clause> ]
  private static boolean aggregate_function_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function_1_1")) return false;
    filter_clause(b, l + 1);
    return true;
  }

  // <binary set function> [ <filter clause> ]
  private static boolean aggregate_function_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = binary_set_function(b, l + 1);
    r = r && aggregate_function_2_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <filter clause> ]
  private static boolean aggregate_function_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function_2_1")) return false;
    filter_clause(b, l + 1);
    return true;
  }

  // <ordered set function> [ <filter clause> ]
  private static boolean aggregate_function_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = ordered_set_function(b, l + 1);
    r = r && aggregate_function_3_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <filter clause> ]
  private static boolean aggregate_function_3_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "aggregate_function_3_1")) return false;
    filter_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // ALL
  public static boolean all(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "all")) return false;
    if (!nextTokenIs(b, ALL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ALL);
    exit_section_(b, m, ALL, r);
    return r;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean all_fields_column_name_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "all_fields_column_name_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, ALL_FIELDS_COLUMN_NAME_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary> <period> <asterisk> [ AS <left paren> <all fields column name list> <right paren> ]
  public static boolean all_fields_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "all_fields_reference")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    r = r && period(b, l + 1);
    r = r && asterisk(b, l + 1);
    r = r && all_fields_reference_3(b, l + 1);
    exit_section_(b, m, ALL_FIELDS_REFERENCE, r);
    return r;
  }

  // [ AS <left paren> <all fields column name list> <right paren> ]
  private static boolean all_fields_reference_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "all_fields_reference_3")) return false;
    parseTokens(b, 0, AS, _LEFT_PAREN_, _ALL_FIELDS_COLUMN_NAME_LIST_, _RIGHT_PAREN_);
    return true;
  }

  /* ********************************************************** */
  // ALLOCATE <extended cursor name> <cursor intent>
  public static boolean allocate_cursor_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "allocate_cursor_statement")) return false;
    if (!nextTokenIs(b, ALLOCATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ALLOCATE, _EXTENDED_CURSOR_NAME_, _CURSOR_INTENT_);
    exit_section_(b, m, ALLOCATE_CURSOR_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // ALLOCATE [ SQL ] DESCRIPTOR <descriptor name> [ WITH MAX <occurrences> ]
  public static boolean allocate_descriptor_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "allocate_descriptor_statement")) return false;
    if (!nextTokenIs(b, ALLOCATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ALLOCATE);
    r = r && allocate_descriptor_statement_1(b, l + 1);
    r = r && consumeTokens(b, 0, DESCRIPTOR, _DESCRIPTOR_NAME_);
    r = r && allocate_descriptor_statement_4(b, l + 1);
    exit_section_(b, m, ALLOCATE_DESCRIPTOR_STATEMENT, r);
    return r;
  }

  // [ SQL ]
  private static boolean allocate_descriptor_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "allocate_descriptor_statement_1")) return false;
    consumeToken(b, SQL);
    return true;
  }

  // [ WITH MAX <occurrences> ]
  private static boolean allocate_descriptor_statement_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "allocate_descriptor_statement_4")) return false;
    parseTokens(b, 0, WITH, MAX, _OCCURRENCES_);
    return true;
  }

  /* ********************************************************** */
  // <set column default clause>
  // 	|	<drop column default clause>
  // 	|	<add column scope clause>
  // 	|	<drop column scope clause>
  // 	|	<alter identity column specification>
  public static boolean alter_column_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_column_action")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ALTER_COLUMN_ACTION, "<alter column action>");
    r = set_column_default_clause(b, l + 1);
    if (!r) r = drop_column_default_clause(b, l + 1);
    if (!r) r = add_column_scope_clause(b, l + 1);
    if (!r) r = drop_column_scope_clause(b, l + 1);
    if (!r) r = alter_identity_column_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ALTER [ COLUMN ] <column name> <alter column action>
  public static boolean alter_column_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_column_definition")) return false;
    if (!nextTokenIs(b, ALTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ALTER);
    r = r && alter_column_definition_1(b, l + 1);
    r = r && column_name(b, l + 1);
    r = r && alter_column_action(b, l + 1);
    exit_section_(b, m, ALTER_COLUMN_DEFINITION, r);
    return r;
  }

  // [ COLUMN ]
  private static boolean alter_column_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_column_definition_1")) return false;
    consumeToken(b, COLUMN);
    return true;
  }

  /* ********************************************************** */
  // <set domain default clause>
  // 	|	<drop domain default clause>
  // 	|	<add domain constraint definition>
  // 	|	<drop domain constraint definition>
  public static boolean alter_domain_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_domain_action")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ALTER_DOMAIN_ACTION, "<alter domain action>");
    r = set_domain_default_clause(b, l + 1);
    if (!r) r = drop_domain_default_clause(b, l + 1);
    if (!r) r = add_domain_constraint_definition(b, l + 1);
    if (!r) r = drop_domain_constraint_definition(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ALTER DOMAIN <domain name> <alter domain action>
  public static boolean alter_domain_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_domain_statement")) return false;
    if (!nextTokenIs(b, ALTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ALTER, DOMAIN, _DOMAIN_NAME_, _ALTER_DOMAIN_ACTION_);
    exit_section_(b, m, ALTER_DOMAIN_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <group name> <left paren> <alter transform action list> <right paren>
  public static boolean alter_group(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_group")) return false;
    if (!nextTokenIs(b, _GROUP_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = group_name(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && alter_transform_action_list(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, ALTER_GROUP, r);
    return r;
  }

  /* ********************************************************** */
  // <alter sequence generator restart option>
  // 	|	SET <basic sequence generator option>
  public static boolean alter_identity_column_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_identity_column_option")) return false;
    if (!nextTokenIs(b, "<alter identity column option>", SET, _ALTER_SEQUENCE_GENERATOR_RESTART_OPTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ALTER_IDENTITY_COLUMN_OPTION, "<alter identity column option>");
    r = alter_sequence_generator_restart_option(b, l + 1);
    if (!r) r = parseTokens(b, 0, SET, _BASIC_SEQUENCE_GENERATOR_OPTION_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <alter identity column option>...
  public static boolean alter_identity_column_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_identity_column_specification")) return false;
    if (!nextTokenIs(b, _ALTER_IDENTITY_COLUMN_OPTION____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _ALTER_IDENTITY_COLUMN_OPTION____);
    exit_section_(b, m, ALTER_IDENTITY_COLUMN_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // RESTRICT
  public static boolean alter_routine_behavior(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_routine_behavior")) return false;
    if (!nextTokenIs(b, RESTRICT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, RESTRICT);
    exit_section_(b, m, ALTER_ROUTINE_BEHAVIOR, r);
    return r;
  }

  /* ********************************************************** */
  // <language clause>
  // 	|	<parameter style clause>
  // 	|	<SQL-data access indication>
  // 	|	<null-call clause>
  // 	|	<dynamic result sets characteristic>
  // 	|	NAME <external routine name>
  public static boolean alter_routine_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_routine_characteristic")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ALTER_ROUTINE_CHARACTERISTIC, "<alter routine characteristic>");
    r = language_clause(b, l + 1);
    if (!r) r = parameter_style_clause(b, l + 1);
    if (!r) r = SQL_data_access_indication(b, l + 1);
    if (!r) r = null_call_clause(b, l + 1);
    if (!r) r = dynamic_result_sets_characteristic(b, l + 1);
    if (!r) r = parseTokens(b, 0, NAME, _EXTERNAL_ROUTINE_NAME_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <alter routine characteristic>...
  public static boolean alter_routine_characteristics(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_routine_characteristics")) return false;
    if (!nextTokenIs(b, _ALTER_ROUTINE_CHARACTERISTIC____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _ALTER_ROUTINE_CHARACTERISTIC____);
    exit_section_(b, m, ALTER_ROUTINE_CHARACTERISTICS, r);
    return r;
  }

  /* ********************************************************** */
  // ALTER <specific routine designator> <alter routine characteristics> <alter routine behavior>
  public static boolean alter_routine_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_routine_statement")) return false;
    if (!nextTokenIs(b, ALTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ALTER, _SPECIFIC_ROUTINE_DESIGNATOR_, _ALTER_ROUTINE_CHARACTERISTICS_, _ALTER_ROUTINE_BEHAVIOR_);
    exit_section_(b, m, ALTER_ROUTINE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <alter sequence generator restart option>
  // 	|	<basic sequence generator option>
  public static boolean alter_sequence_generator_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_sequence_generator_option")) return false;
    if (!nextTokenIs(b, "<alter sequence generator option>", _ALTER_SEQUENCE_GENERATOR_RESTART_OPTION_, _BASIC_SEQUENCE_GENERATOR_OPTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ALTER_SEQUENCE_GENERATOR_OPTION, "<alter sequence generator option>");
    r = alter_sequence_generator_restart_option(b, l + 1);
    if (!r) r = basic_sequence_generator_option(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <alter sequence generator option>...
  public static boolean alter_sequence_generator_options(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_sequence_generator_options")) return false;
    if (!nextTokenIs(b, _ALTER_SEQUENCE_GENERATOR_OPTION____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _ALTER_SEQUENCE_GENERATOR_OPTION____);
    exit_section_(b, m, ALTER_SEQUENCE_GENERATOR_OPTIONS, r);
    return r;
  }

  /* ********************************************************** */
  // RESTART WITH <sequence generator restart value>
  public static boolean alter_sequence_generator_restart_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_sequence_generator_restart_option")) return false;
    if (!nextTokenIs(b, RESTART)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, RESTART, WITH, _SEQUENCE_GENERATOR_RESTART_VALUE_);
    exit_section_(b, m, ALTER_SEQUENCE_GENERATOR_RESTART_OPTION, r);
    return r;
  }

  /* ********************************************************** */
  // ALTER SEQUENCE <sequence generator name> <alter sequence generator options>
  public static boolean alter_sequence_generator_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_sequence_generator_statement")) return false;
    if (!nextTokenIs(b, ALTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ALTER, SEQUENCE, _SEQUENCE_GENERATOR_NAME_, _ALTER_SEQUENCE_GENERATOR_OPTIONS_);
    exit_section_(b, m, ALTER_SEQUENCE_GENERATOR_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <add column definition>
  // 	|	<alter column definition>
  // 	|	<drop column definition>
  // 	|	<add table constraint definition>
  // 	|	<drop table constraint definition>
  public static boolean alter_table_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_table_action")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ALTER_TABLE_ACTION, "<alter table action>");
    r = add_column_definition(b, l + 1);
    if (!r) r = alter_column_definition(b, l + 1);
    if (!r) r = drop_column_definition(b, l + 1);
    if (!r) r = add_table_constraint_definition(b, l + 1);
    if (!r) r = drop_table_constraint_definition(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ALTER TABLE <table name> <alter table action>
  public static boolean alter_table_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_table_statement")) return false;
    if (!nextTokenIs(b, ALTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ALTER, TABLE, _TABLE_NAME_, _ALTER_TABLE_ACTION_);
    exit_section_(b, m, ALTER_TABLE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <add transform element list> | <drop transform element list>
  public static boolean alter_transform_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_transform_action")) return false;
    if (!nextTokenIs(b, "<alter transform action>", _ADD_TRANSFORM_ELEMENT_LIST_, _DROP_TRANSFORM_ELEMENT_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ALTER_TRANSFORM_ACTION, "<alter transform action>");
    r = add_transform_element_list(b, l + 1);
    if (!r) r = drop_transform_element_list(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <alter transform action> [ { <comma> <alter transform action> }... ]
  public static boolean alter_transform_action_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_transform_action_list")) return false;
    if (!nextTokenIs(b, _ALTER_TRANSFORM_ACTION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = alter_transform_action(b, l + 1);
    r = r && alter_transform_action_list_1(b, l + 1);
    exit_section_(b, m, ALTER_TRANSFORM_ACTION_LIST, r);
    return r;
  }

  // [ { <comma> <alter transform action> }... ]
  private static boolean alter_transform_action_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_transform_action_list_1")) return false;
    alter_transform_action_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <alter transform action>
  private static boolean alter_transform_action_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_transform_action_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && alter_transform_action(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // ALTER { TRANSFORM | TRANSFORMS } FOR <schema-resolved user-defined type name> <alter group>...
  public static boolean alter_transform_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_transform_statement")) return false;
    if (!nextTokenIs(b, ALTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ALTER);
    r = r && alter_transform_statement_1(b, l + 1);
    r = r && consumeTokens(b, 0, FOR, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_, _ALTER_GROUP_);
    exit_section_(b, m, ALTER_TRANSFORM_STATEMENT, r);
    return r;
  }

  // TRANSFORM | TRANSFORMS
  private static boolean alter_transform_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_transform_statement_1")) return false;
    boolean r;
    r = consumeToken(b, TRANSFORM);
    if (!r) r = consumeToken(b, TRANSFORMS);
    return r;
  }

  /* ********************************************************** */
  // <add attribute definition>
  // 	|	<drop attribute definition>
  // 	|	<add original method specification>
  // 	|	<add overriding method specification>
  // 	|	<drop method specification>
  public static boolean alter_type_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_type_action")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ALTER_TYPE_ACTION, "<alter type action>");
    r = add_attribute_definition(b, l + 1);
    if (!r) r = drop_attribute_definition(b, l + 1);
    if (!r) r = add_original_method_specification(b, l + 1);
    if (!r) r = add_overriding_method_specification(b, l + 1);
    if (!r) r = drop_method_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ALTER TYPE <schema-resolved user-defined type name> <alter type action>
  public static boolean alter_type_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "alter_type_statement")) return false;
    if (!nextTokenIs(b, ALTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ALTER, TYPE, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_, _ALTER_TYPE_ACTION_);
    exit_section_(b, m, ALTER_TYPE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // &
  public static boolean ampersand(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, AMPERSAND, true);
    return true;
  }

  /* ********************************************************** */
  // <mantissa> E <exponent>
  public static boolean approximate_numeric_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "approximate_numeric_literal")) return false;
    if (!nextTokenIs(b, _MANTISSA_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = mantissa(b, l + 1);
    r = r && consumeTokens(b, 0, E, _EXPONENT_);
    exit_section_(b, m, APPROXIMATE_NUMERIC_LITERAL, r);
    return r;
  }

  /* ********************************************************** */
  // FLOAT [ <left paren> <precision> <right paren> ]
  // 	|	REAL
  // 	|	DOUBLE PRECISION
  public static boolean approximate_numeric_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "approximate_numeric_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, APPROXIMATE_NUMERIC_TYPE, "<approximate numeric type>");
    r = approximate_numeric_type_0(b, l + 1);
    if (!r) r = consumeToken(b, REAL);
    if (!r) r = parseTokens(b, 0, DOUBLE, PRECISION);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // FLOAT [ <left paren> <precision> <right paren> ]
  private static boolean approximate_numeric_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "approximate_numeric_type_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, FLOAT);
    r = r && approximate_numeric_type_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <precision> <right paren> ]
  private static boolean approximate_numeric_type_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "approximate_numeric_type_0_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <array value expression 1> <concatenation operator> <array factor>
  public static boolean array_concatenation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_concatenation")) return false;
    if (!nextTokenIs(b, _ARRAY_VALUE_EXPRESSION_1_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = array_value_expression_1(b, l + 1);
    r = r && concatenation_operator(b, l + 1);
    r = r && array_factor(b, l + 1);
    exit_section_(b, m, ARRAY_CONCATENATION, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  public static boolean array_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_element")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    exit_section_(b, m, ARRAY_ELEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <array element> [ { <comma> <array element> }... ]
  public static boolean array_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_element_list")) return false;
    if (!nextTokenIs(b, _ARRAY_ELEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = array_element(b, l + 1);
    r = r && array_element_list_1(b, l + 1);
    exit_section_(b, m, ARRAY_ELEMENT_LIST, r);
    return r;
  }

  // [ { <comma> <array element> }... ]
  private static boolean array_element_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_element_list_1")) return false;
    array_element_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <array element>
  private static boolean array_element_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_element_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && array_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <array value expression> <left bracket or trigraph> <numeric value expression> <right bracket or trigraph>
  public static boolean array_element_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_element_reference")) return false;
    if (!nextTokenIs(b, _ARRAY_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = array_value_expression(b, l + 1);
    r = r && left_bracket_or_trigraph(b, l + 1);
    r = r && numeric_value_expression(b, l + 1);
    r = r && right_bracket_or_trigraph(b, l + 1);
    exit_section_(b, m, ARRAY_ELEMENT_REFERENCE, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary>
  public static boolean array_factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_factor")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    exit_section_(b, m, ARRAY_FACTOR, r);
    return r;
  }

  /* ********************************************************** */
  // <data type> ARRAY [ <left bracket or trigraph> <unsigned integer> <right bracket or trigraph> ]
  public static boolean array_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_type")) return false;
    if (!nextTokenIs(b, _DATA_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    r = r && consumeToken(b, ARRAY);
    r = r && array_type_2(b, l + 1);
    exit_section_(b, m, ARRAY_TYPE, r);
    return r;
  }

  // [ <left bracket or trigraph> <unsigned integer> <right bracket or trigraph> ]
  private static boolean array_type_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_type_2")) return false;
    left_bracket_or_trigraph(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <array value constructor by enumeration>
  // 	|	<array value constructor by query>
  public static boolean array_value_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_value_constructor")) return false;
    if (!nextTokenIs(b, "<array value constructor>", _ARRAY_VALUE_CONSTRUCTOR_BY_ENUMERATION_, _ARRAY_VALUE_CONSTRUCTOR_BY_QUERY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ARRAY_VALUE_CONSTRUCTOR, "<array value constructor>");
    r = array_value_constructor_by_enumeration(b, l + 1);
    if (!r) r = array_value_constructor_by_query(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ARRAY <left bracket or trigraph> <array element list> <right bracket or trigraph>
  public static boolean array_value_constructor_by_enumeration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_value_constructor_by_enumeration")) return false;
    if (!nextTokenIs(b, ARRAY)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ARRAY, _LEFT_BRACKET_OR_TRIGRAPH_, _ARRAY_ELEMENT_LIST_, _RIGHT_BRACKET_OR_TRIGRAPH_);
    exit_section_(b, m, ARRAY_VALUE_CONSTRUCTOR_BY_ENUMERATION, r);
    return r;
  }

  /* ********************************************************** */
  // ARRAY <left paren> <query expression> [ <order by clause> ] <right paren>
  public static boolean array_value_constructor_by_query(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_value_constructor_by_query")) return false;
    if (!nextTokenIs(b, ARRAY)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ARRAY, _LEFT_PAREN_, _QUERY_EXPRESSION_);
    r = r && array_value_constructor_by_query_3(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, ARRAY_VALUE_CONSTRUCTOR_BY_QUERY, r);
    return r;
  }

  // [ <order by clause> ]
  private static boolean array_value_constructor_by_query_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_value_constructor_by_query_3")) return false;
    order_by_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <array concatenation> | <array factor>
  public static boolean array_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_value_expression")) return false;
    if (!nextTokenIs(b, "<array value expression>", _ARRAY_CONCATENATION_, _ARRAY_FACTOR_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ARRAY_VALUE_EXPRESSION, "<array value expression>");
    r = array_concatenation(b, l + 1);
    if (!r) r = array_factor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <array value expression>
  public static boolean array_value_expression_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "array_value_expression_1")) return false;
    if (!nextTokenIs(b, _ARRAY_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = array_value_expression(b, l + 1);
    exit_section_(b, m, ARRAY_VALUE_EXPRESSION_1, r);
    return r;
  }

  /* ********************************************************** */
  // [ AS ] <column name>
  public static boolean as_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "as_clause")) return false;
    if (!nextTokenIs(b, "<as clause>", AS, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, AS_CLAUSE, "<as clause>");
    r = as_clause_0(b, l + 1);
    r = r && column_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ AS ]
  private static boolean as_clause_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "as_clause_0")) return false;
    consumeToken(b, AS);
    return true;
  }

  /* ********************************************************** */
  // [ <left paren> <column name list> <right paren> ] AS <subquery> <with or without data>
  public static boolean as_subquery_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "as_subquery_clause")) return false;
    if (!nextTokenIs(b, "<as subquery clause>", AS, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, AS_SUBQUERY_CLAUSE, "<as subquery clause>");
    r = as_subquery_clause_0(b, l + 1);
    r = r && consumeTokens(b, 0, AS, _SUBQUERY_, _WITH_OR_WITHOUT_DATA_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <left paren> <column name list> <right paren> ]
  private static boolean as_subquery_clause_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "as_subquery_clause_0")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // CREATE ASSERTION <constraint name> CHECK <left paren> <search condition> <right paren> [ <constraint characteristics> ]
  public static boolean assertion_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "assertion_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, ASSERTION, _CONSTRAINT_NAME_, CHECK, _LEFT_PAREN_, _SEARCH_CONDITION_, _RIGHT_PAREN_);
    r = r && assertion_definition_7(b, l + 1);
    exit_section_(b, m, ASSERTION_DEFINITION, r);
    return r;
  }

  // [ <constraint characteristics> ]
  private static boolean assertion_definition_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "assertion_definition_7")) return false;
    constraint_characteristics(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <contextually typed row value expression>
  public static boolean assigned_row(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "assigned_row")) return false;
    if (!nextTokenIs(b, _CONTEXTUALLY_TYPED_ROW_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = contextually_typed_row_value_expression(b, l + 1);
    exit_section_(b, m, ASSIGNED_ROW, r);
    return r;
  }

  /* ********************************************************** */
  // *
  public static boolean asterisk(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, ASTERISK, true);
    return true;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean asterisked_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "asterisked_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, ASTERISKED_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // <asterisked identifier> [ { <period> <asterisked identifier> }... ]
  public static boolean asterisked_identifier_chain(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "asterisked_identifier_chain")) return false;
    if (!nextTokenIs(b, _ASTERISKED_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = asterisked_identifier(b, l + 1);
    r = r && asterisked_identifier_chain_1(b, l + 1);
    exit_section_(b, m, ASTERISKED_IDENTIFIER_CHAIN, r);
    return r;
  }

  // [ { <period> <asterisked identifier> }... ]
  private static boolean asterisked_identifier_chain_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "asterisked_identifier_chain_1")) return false;
    asterisked_identifier_chain_1_0(b, l + 1);
    return true;
  }

  // <period> <asterisked identifier>
  private static boolean asterisked_identifier_chain_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "asterisked_identifier_chain_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = period(b, l + 1);
    r = r && asterisked_identifier(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <default clause>
  public static boolean attribute_default(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attribute_default")) return false;
    if (!nextTokenIs(b, _DEFAULT_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = default_clause(b, l + 1);
    exit_section_(b, m, ATTRIBUTE_DEFAULT, r);
    return r;
  }

  /* ********************************************************** */
  // <attribute name> <data type> [ <reference scope check> ] [ <attribute default> ] [ <collate clause> ]
  public static boolean attribute_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attribute_definition")) return false;
    if (!nextTokenIs(b, _ATTRIBUTE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = attribute_name(b, l + 1);
    r = r && data_type(b, l + 1);
    r = r && attribute_definition_2(b, l + 1);
    r = r && attribute_definition_3(b, l + 1);
    r = r && attribute_definition_4(b, l + 1);
    exit_section_(b, m, ATTRIBUTE_DEFINITION, r);
    return r;
  }

  // [ <reference scope check> ]
  private static boolean attribute_definition_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attribute_definition_2")) return false;
    reference_scope_check(b, l + 1);
    return true;
  }

  // [ <attribute default> ]
  private static boolean attribute_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attribute_definition_3")) return false;
    attribute_default(b, l + 1);
    return true;
  }

  // [ <collate clause> ]
  private static boolean attribute_definition_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attribute_definition_4")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean attribute_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attribute_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, ATTRIBUTE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary> <dereference operator> <qualified identifier>
  // 		[ <SQL argument list> ]
  public static boolean attribute_or_method_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attribute_or_method_reference")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    r = r && dereference_operator(b, l + 1);
    r = r && qualified_identifier(b, l + 1);
    r = r && attribute_or_method_reference_3(b, l + 1);
    exit_section_(b, m, ATTRIBUTE_OR_METHOD_REFERENCE, r);
    return r;
  }

  // [ <SQL argument list> ]
  private static boolean attribute_or_method_reference_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attribute_or_method_reference_3")) return false;
    SQL_argument_list(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // ATTRIBUTES <attributes variable>
  public static boolean attributes_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attributes_specification")) return false;
    if (!nextTokenIs(b, ATTRIBUTES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ATTRIBUTES, _ATTRIBUTES_VARIABLE_);
    exit_section_(b, m, ATTRIBUTES_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean attributes_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "attributes_variable")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, ATTRIBUTES_VARIABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <role name> | <user identifier>
  public static boolean authorization_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "authorization_identifier")) return false;
    if (!nextTokenIs(b, "<authorization identifier>", _ROLE_NAME_, _USER_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, AUTHORIZATION_IDENTIFIER, "<authorization identifier>");
    r = role_name(b, l + 1);
    if (!r) r = user_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier chain>
  public static boolean basic_identifier_chain(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "basic_identifier_chain")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_CHAIN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier_chain(b, l + 1);
    exit_section_(b, m, BASIC_IDENTIFIER_CHAIN, r);
    return r;
  }

  /* ********************************************************** */
  // <sequence generator increment by option>
  // 	|	<sequence generator maxvalue option>
  // 	|	<sequence generator minvalue option>
  // 	|	<sequence generator cycle option>
  public static boolean basic_sequence_generator_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "basic_sequence_generator_option")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BASIC_SEQUENCE_GENERATOR_OPTION, "<basic sequence generator option>");
    r = sequence_generator_increment_by_option(b, l + 1);
    if (!r) r = sequence_generator_maxvalue_option(b, l + 1);
    if (!r) r = sequence_generator_minvalue_option(b, l + 1);
    if (!r) r = sequence_generator_cycle_option(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <between predicate part 2>
  public static boolean between_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "between_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && between_predicate_part_2(b, l + 1);
    exit_section_(b, m, BETWEEN_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // [ NOT ] BETWEEN [ ASYMMETRIC | SYMMETRIC ] <row value predicand> AND <row value predicand>
  public static boolean between_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "between_predicate_part_2")) return false;
    if (!nextTokenIs(b, "<between predicate part 2>", BETWEEN, NOT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BETWEEN_PREDICATE_PART_2, "<between predicate part 2>");
    r = between_predicate_part_2_0(b, l + 1);
    r = r && consumeToken(b, BETWEEN);
    r = r && between_predicate_part_2_2(b, l + 1);
    r = r && row_value_predicand(b, l + 1);
    r = r && consumeTokens(b, 0, AND, _ROW_VALUE_PREDICAND_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ NOT ]
  private static boolean between_predicate_part_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "between_predicate_part_2_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ ASYMMETRIC | SYMMETRIC ]
  private static boolean between_predicate_part_2_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "between_predicate_part_2_2")) return false;
    between_predicate_part_2_2_0(b, l + 1);
    return true;
  }

  // ASYMMETRIC | SYMMETRIC
  private static boolean between_predicate_part_2_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "between_predicate_part_2_2_0")) return false;
    boolean r;
    r = consumeToken(b, ASYMMETRIC);
    if (!r) r = consumeToken(b, SYMMETRIC);
    return r;
  }

  /* ********************************************************** */
  // BINARY LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  // 	|	BLOB [ <left paren> <large object length> <right paren> ]
  public static boolean binary_large_object_string_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_large_object_string_type")) return false;
    if (!nextTokenIs(b, "<binary large object string type>", BINARY, BLOB)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BINARY_LARGE_OBJECT_STRING_TYPE, "<binary large object string type>");
    r = binary_large_object_string_type_0(b, l + 1);
    if (!r) r = binary_large_object_string_type_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // BINARY LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  private static boolean binary_large_object_string_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_large_object_string_type_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, BINARY, LARGE, OBJECT);
    r = r && binary_large_object_string_type_0_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <large object length> <right paren> ]
  private static boolean binary_large_object_string_type_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_large_object_string_type_0_3")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // BLOB [ <left paren> <large object length> <right paren> ]
  private static boolean binary_large_object_string_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_large_object_string_type_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, BLOB);
    r = r && binary_large_object_string_type_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <large object length> <right paren> ]
  private static boolean binary_large_object_string_type_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_large_object_string_type_1_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <binary set function type> <left paren> <dependent variable expression> <comma> <independent variable expression> <right paren>
  public static boolean binary_set_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_set_function")) return false;
    if (!nextTokenIs(b, _BINARY_SET_FUNCTION_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = binary_set_function_type(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && dependent_variable_expression(b, l + 1);
    r = r && comma(b, l + 1);
    r = r && independent_variable_expression(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, BINARY_SET_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // COVAR_POP | COVAR_SAMP | CORR | REGR_SLOPE
  // 	|	REGR_INTERCEPT | REGR_COUNT | REGR_R2 | REGR_AVGX | REGR_AVGY
  // 	|	REGR_SXX | REGR_SYY | REGR_SXY
  public static boolean binary_set_function_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_set_function_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BINARY_SET_FUNCTION_TYPE, "<binary set function type>");
    r = consumeToken(b, COVAR_POP);
    if (!r) r = consumeToken(b, COVAR_SAMP);
    if (!r) r = consumeToken(b, CORR);
    if (!r) r = consumeToken(b, REGR_SLOPE);
    if (!r) r = consumeToken(b, REGR_INTERCEPT);
    if (!r) r = consumeToken(b, REGR_COUNT);
    if (!r) r = consumeToken(b, REGR_R2);
    if (!r) r = consumeToken(b, REGR_AVGX);
    if (!r) r = consumeToken(b, REGR_AVGY);
    if (!r) r = consumeToken(b, REGR_SXX);
    if (!r) r = consumeToken(b, REGR_SYY);
    if (!r) r = consumeToken(b, REGR_SXY);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // X <quote> [ { <hexit><hexit> }... ] <quote>
  // 		[ { <separator> <quote> [ { <hexit><hexit> }... ] <quote> }... ]
  // 		[ ESCAPE <escape character> ]
  public static boolean binary_string_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_string_literal")) return false;
    if (!nextTokenIs(b, X)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, X, _QUOTE_);
    r = r && binary_string_literal_2(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && binary_string_literal_4(b, l + 1);
    r = r && binary_string_literal_5(b, l + 1);
    exit_section_(b, m, BINARY_STRING_LITERAL, r);
    return r;
  }

  // [ { <hexit><hexit> }... ]
  private static boolean binary_string_literal_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_string_literal_2")) return false;
    binary_string_literal_2_0(b, l + 1);
    return true;
  }

  // <hexit><hexit>
  private static boolean binary_string_literal_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_string_literal_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = hexit(b, l + 1);
    r = r && hexit(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <separator> <quote> [ { <hexit><hexit> }... ] <quote> }... ]
  private static boolean binary_string_literal_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_string_literal_4")) return false;
    binary_string_literal_4_0(b, l + 1);
    return true;
  }

  // <separator> <quote> [ { <hexit><hexit> }... ] <quote>
  private static boolean binary_string_literal_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_string_literal_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = separator(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && binary_string_literal_4_0_2(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <hexit><hexit> }... ]
  private static boolean binary_string_literal_4_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_string_literal_4_0_2")) return false;
    binary_string_literal_4_0_2_0(b, l + 1);
    return true;
  }

  // <hexit><hexit>
  private static boolean binary_string_literal_4_0_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_string_literal_4_0_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = hexit(b, l + 1);
    r = r && hexit(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ESCAPE <escape character> ]
  private static boolean binary_string_literal_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "binary_string_literal_5")) return false;
    parseTokens(b, 0, ESCAPE, _ESCAPE_CHARACTER_);
    return true;
  }

  /* ********************************************************** */
  // <blob value expression> <concatenation operator> <blob factor>
  public static boolean blob_concatenation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_concatenation")) return false;
    if (!nextTokenIs(b, _BLOB_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = blob_value_expression(b, l + 1);
    r = r && concatenation_operator(b, l + 1);
    r = r && blob_factor(b, l + 1);
    exit_section_(b, m, BLOB_CONCATENATION, r);
    return r;
  }

  /* ********************************************************** */
  // <blob primary>
  public static boolean blob_factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_factor")) return false;
    if (!nextTokenIs(b, _BLOB_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = blob_primary(b, l + 1);
    exit_section_(b, m, BLOB_FACTOR, r);
    return r;
  }

  /* ********************************************************** */
  // OVERLAY <left paren> <blob value expression> PLACING <blob value expression>
  // 		FROM <start position> [ FOR <string length> ] <right paren>
  public static boolean blob_overlay_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_overlay_function")) return false;
    if (!nextTokenIs(b, OVERLAY)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OVERLAY, _LEFT_PAREN_, _BLOB_VALUE_EXPRESSION_, PLACING, _BLOB_VALUE_EXPRESSION_, FROM, _START_POSITION_);
    r = r && blob_overlay_function_7(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, BLOB_OVERLAY_FUNCTION, r);
    return r;
  }

  // [ FOR <string length> ]
  private static boolean blob_overlay_function_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_overlay_function_7")) return false;
    parseTokens(b, 0, FOR, _STRING_LENGTH_);
    return true;
  }

  /* ********************************************************** */
  // POSITION <left paren> <blob value expression> IN <blob value expression> <right paren>
  public static boolean blob_position_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_position_expression")) return false;
    if (!nextTokenIs(b, POSITION)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, POSITION, _LEFT_PAREN_, _BLOB_VALUE_EXPRESSION_, IN, _BLOB_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, BLOB_POSITION_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary> | <string value function>
  public static boolean blob_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_primary")) return false;
    if (!nextTokenIs(b, "<blob primary>", _STRING_VALUE_FUNCTION_, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BLOB_PRIMARY, "<blob primary>");
    r = value_expression_primary(b, l + 1);
    if (!r) r = string_value_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SUBSTRING <left paren> <blob value expression> FROM <start position> [ FOR <string length> ] <right paren>
  public static boolean blob_substring_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_substring_function")) return false;
    if (!nextTokenIs(b, SUBSTRING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SUBSTRING, _LEFT_PAREN_, _BLOB_VALUE_EXPRESSION_, FROM, _START_POSITION_);
    r = r && blob_substring_function_5(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, BLOB_SUBSTRING_FUNCTION, r);
    return r;
  }

  // [ FOR <string length> ]
  private static boolean blob_substring_function_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_substring_function_5")) return false;
    parseTokens(b, 0, FOR, _STRING_LENGTH_);
    return true;
  }

  /* ********************************************************** */
  // TRIM <left paren> <blob trim operands> <right paren>
  public static boolean blob_trim_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_trim_function")) return false;
    if (!nextTokenIs(b, TRIM)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TRIM, _LEFT_PAREN_, _BLOB_TRIM_OPERANDS_, _RIGHT_PAREN_);
    exit_section_(b, m, BLOB_TRIM_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // [ [ <trim specification> ] [ <trim octet> ] FROM ] <blob trim source>
  public static boolean blob_trim_operands(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_trim_operands")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BLOB_TRIM_OPERANDS, "<blob trim operands>");
    r = blob_trim_operands_0(b, l + 1);
    r = r && blob_trim_source(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ [ <trim specification> ] [ <trim octet> ] FROM ]
  private static boolean blob_trim_operands_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_trim_operands_0")) return false;
    blob_trim_operands_0_0(b, l + 1);
    return true;
  }

  // [ <trim specification> ] [ <trim octet> ] FROM
  private static boolean blob_trim_operands_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_trim_operands_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = blob_trim_operands_0_0_0(b, l + 1);
    r = r && blob_trim_operands_0_0_1(b, l + 1);
    r = r && consumeToken(b, FROM);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <trim specification> ]
  private static boolean blob_trim_operands_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_trim_operands_0_0_0")) return false;
    trim_specification(b, l + 1);
    return true;
  }

  // [ <trim octet> ]
  private static boolean blob_trim_operands_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_trim_operands_0_0_1")) return false;
    trim_octet(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <blob value expression>
  public static boolean blob_trim_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_trim_source")) return false;
    if (!nextTokenIs(b, _BLOB_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = blob_value_expression(b, l + 1);
    exit_section_(b, m, BLOB_TRIM_SOURCE, r);
    return r;
  }

  /* ********************************************************** */
  // <blob concatenation> | <blob factor>
  public static boolean blob_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_value_expression")) return false;
    if (!nextTokenIs(b, "<blob value expression>", _BLOB_CONCATENATION_, _BLOB_FACTOR_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BLOB_VALUE_EXPRESSION, "<blob value expression>");
    r = blob_concatenation(b, l + 1);
    if (!r) r = blob_factor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <blob substring function>
  // 	|	<blob trim function>
  // 	|	<blob overlay function>
  public static boolean blob_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "blob_value_function")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BLOB_VALUE_FUNCTION, "<blob value function>");
    r = blob_substring_function(b, l + 1);
    if (!r) r = blob_trim_function(b, l + 1);
    if (!r) r = blob_overlay_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ NOT ] <boolean test>
  public static boolean boolean_factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_factor")) return false;
    if (!nextTokenIs(b, "<boolean factor>", NOT, _BOOLEAN_TEST_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BOOLEAN_FACTOR, "<boolean factor>");
    r = boolean_factor_0(b, l + 1);
    r = r && boolean_test(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ NOT ]
  private static boolean boolean_factor_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_factor_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  /* ********************************************************** */
  // TRUE | FALSE | UNKNOWN
  public static boolean boolean_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_literal")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BOOLEAN_LITERAL, "<boolean literal>");
    r = consumeToken(b, TRUE);
    if (!r) r = consumeToken(b, FALSE);
    if (!r) r = consumeToken(b, UNKNOWN);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <parenthesized boolean value expression>
  // 	|	<nonparenthesized value expression primary>
  public static boolean boolean_predicand(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_predicand")) return false;
    if (!nextTokenIs(b, "<boolean predicand>", _NONPARENTHESIZED_VALUE_EXPRESSION_PRIMARY_, _PARENTHESIZED_BOOLEAN_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BOOLEAN_PREDICAND, "<boolean predicand>");
    r = parenthesized_boolean_value_expression(b, l + 1);
    if (!r) r = nonparenthesized_value_expression_primary(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <predicate> | <boolean predicand>
  public static boolean boolean_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_primary")) return false;
    if (!nextTokenIs(b, "<boolean primary>", _BOOLEAN_PREDICAND_, _PREDICATE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BOOLEAN_PRIMARY, "<boolean primary>");
    r = predicate(b, l + 1);
    if (!r) r = boolean_predicand(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <boolean factor>
  // 	|	<boolean term> AND <boolean factor>
  public static boolean boolean_term(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_term")) return false;
    if (!nextTokenIs(b, "<boolean term>", _BOOLEAN_FACTOR_, _BOOLEAN_TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BOOLEAN_TERM, "<boolean term>");
    r = boolean_factor(b, l + 1);
    if (!r) r = boolean_term(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <boolean primary> [ IS [ NOT ] <truth value> ]
  public static boolean boolean_test(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_test")) return false;
    if (!nextTokenIs(b, _BOOLEAN_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = boolean_primary(b, l + 1);
    r = r && boolean_test_1(b, l + 1);
    exit_section_(b, m, BOOLEAN_TEST, r);
    return r;
  }

  // [ IS [ NOT ] <truth value> ]
  private static boolean boolean_test_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_test_1")) return false;
    boolean_test_1_0(b, l + 1);
    return true;
  }

  // IS [ NOT ] <truth value>
  private static boolean boolean_test_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_test_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, IS);
    r = r && boolean_test_1_0_1(b, l + 1);
    r = r && truth_value(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ NOT ]
  private static boolean boolean_test_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_test_1_0_1")) return false;
    consumeToken(b, NOT);
    return true;
  }

  /* ********************************************************** */
  // BOOLEAN
  public static boolean boolean_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_type")) return false;
    if (!nextTokenIs(b, BOOLEAN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, BOOLEAN);
    exit_section_(b, m, BOOLEAN_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // <boolean term>
  // 	|	<boolean value expression> OR <boolean term>
  public static boolean boolean_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "boolean_value_expression")) return false;
    if (!nextTokenIs(b, "<boolean value expression>", _BOOLEAN_TERM_, _BOOLEAN_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, BOOLEAN_VALUE_EXPRESSION, "<boolean value expression>");
    r = boolean_term(b, l + 1);
    if (!r) r = boolean_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <bracketed comment introducer> <bracketed comment contents> <bracketed comment terminator>
  public static boolean bracketed_comment(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "bracketed_comment")) return false;
    if (!nextTokenIs(b, _BRACKETED_COMMENT_INTRODUCER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = bracketed_comment_introducer(b, l + 1);
    r = r && bracketed_comment_contents(b, l + 1);
    r = r && bracketed_comment_terminator(b, l + 1);
    exit_section_(b, m, BRACKETED_COMMENT, r);
    return r;
  }

  /* ********************************************************** */
  // [ { <comment character> | <separator> }... ]
  public static boolean bracketed_comment_contents(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "bracketed_comment_contents")) return false;
    Marker m = enter_section_(b, l, _NONE_, BRACKETED_COMMENT_CONTENTS, "<bracketed comment contents>");
    bracketed_comment_contents_0(b, l + 1);
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  // <comment character> | <separator>
  private static boolean bracketed_comment_contents_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "bracketed_comment_contents_0")) return false;
    boolean r;
    r = comment_character(b, l + 1);
    if (!r) r = separator(b, l + 1);
    return r;
  }

  /* ********************************************************** */
  // <slash> <asterisk>
  public static boolean bracketed_comment_introducer(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "bracketed_comment_introducer")) return false;
    if (!nextTokenIs(b, _SLASH_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, _SLASH_, _ASTERISK_);
    exit_section_(b, m, BRACKETED_COMMENT_INTRODUCER, r);
    return r;
  }

  /* ********************************************************** */
  // <asterisk> <slash>
  public static boolean bracketed_comment_terminator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "bracketed_comment_terminator")) return false;
    if (!nextTokenIs(b, _ASTERISK_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = asterisk(b, l + 1);
    r = r && consumeToken(b, _SLASH_);
    exit_section_(b, m, BRACKETED_COMMENT_TERMINATOR, r);
    return r;
  }

  /* ********************************************************** */
  // CALL <routine invocation>
  public static boolean call_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "call_statement")) return false;
    if (!nextTokenIs(b, CALL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CALL, _ROUTINE_INVOCATION_);
    exit_section_(b, m, CALL_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // CARDINALITY <left paren> <collection value expression> <right paren>
  public static boolean cardinality_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cardinality_expression")) return false;
    if (!nextTokenIs(b, CARDINALITY)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CARDINALITY, _LEFT_PAREN_, _COLLECTION_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, CARDINALITY_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // NULLIF <left paren> <value expression> <comma> <value expression> <right paren>
  // 	|	COALESCE <left paren> <value expression> { <comma> <value expression> }... <right paren>
  public static boolean case_abbreviation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "case_abbreviation")) return false;
    if (!nextTokenIs(b, "<case abbreviation>", COALESCE, NULLIF)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CASE_ABBREVIATION, "<case abbreviation>");
    r = parseTokens(b, 0, NULLIF, _LEFT_PAREN_, _VALUE_EXPRESSION_, _COMMA_, _VALUE_EXPRESSION_, _RIGHT_PAREN_);
    if (!r) r = case_abbreviation_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // COALESCE <left paren> <value expression> { <comma> <value expression> }... <right paren>
  private static boolean case_abbreviation_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "case_abbreviation_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, COALESCE, _LEFT_PAREN_, _VALUE_EXPRESSION_);
    r = r && case_abbreviation_1_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // <comma> <value expression>
  private static boolean case_abbreviation_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "case_abbreviation_1_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && value_expression(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <case abbreviation> | <case specification>
  public static boolean case_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "case_expression")) return false;
    if (!nextTokenIs(b, "<case expression>", _CASE_ABBREVIATION_, _CASE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CASE_EXPRESSION, "<case expression>");
    r = case_abbreviation(b, l + 1);
    if (!r) r = case_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> | <overlaps predicate part>
  public static boolean case_operand(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "case_operand")) return false;
    if (!nextTokenIs(b, "<case operand>", _OVERLAPS_PREDICATE_PART_, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CASE_OPERAND, "<case operand>");
    r = row_value_predicand(b, l + 1);
    if (!r) r = consumeToken(b, _OVERLAPS_PREDICATE_PART_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <simple case> | <searched case>
  public static boolean case_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "case_specification")) return false;
    if (!nextTokenIs(b, "<case specification>", _SEARCHED_CASE_, _SIMPLE_CASE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CASE_SPECIFICATION, "<case specification>");
    r = simple_case(b, l + 1);
    if (!r) r = searched_case(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <specific routine designator>
  public static boolean cast_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_function")) return false;
    if (!nextTokenIs(b, _SPECIFIC_ROUTINE_DESIGNATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = specific_routine_designator(b, l + 1);
    exit_section_(b, m, CAST_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression> | <implicitly typed value specification>
  public static boolean cast_operand(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_operand")) return false;
    if (!nextTokenIs(b, "<cast operand>", _IMPLICITLY_TYPED_VALUE_SPECIFICATION_, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CAST_OPERAND, "<cast operand>");
    r = value_expression(b, l + 1);
    if (!r) r = implicitly_typed_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <cast to distinct> ] [ <cast to source> ]
  public static boolean cast_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_option")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CAST_OPTION, "<cast option>");
    r = cast_option_0(b, l + 1);
    r = r && cast_option_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <cast to distinct> ]
  private static boolean cast_option_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_option_0")) return false;
    cast_to_distinct(b, l + 1);
    return true;
  }

  // [ <cast to source> ]
  private static boolean cast_option_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_option_1")) return false;
    cast_to_source(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // CAST <left paren> <cast operand> AS <cast target> <right paren>
  public static boolean cast_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_specification")) return false;
    if (!nextTokenIs(b, CAST)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CAST, _LEFT_PAREN_, _CAST_OPERAND_, AS, _CAST_TARGET_, _RIGHT_PAREN_);
    exit_section_(b, m, CAST_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <domain name> | <data type>
  public static boolean cast_target(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_target")) return false;
    if (!nextTokenIs(b, "<cast target>", _DATA_TYPE_, _DOMAIN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CAST_TARGET, "<cast target>");
    r = domain_name(b, l + 1);
    if (!r) r = data_type(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CAST <left paren> SOURCE AS DISTINCT <right paren>
  // 		WITH <cast to distinct identifier>
  public static boolean cast_to_distinct(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_to_distinct")) return false;
    if (!nextTokenIs(b, CAST)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CAST, _LEFT_PAREN_, SOURCE, AS, DISTINCT, _RIGHT_PAREN_, WITH, _CAST_TO_DISTINCT_IDENTIFIER_);
    exit_section_(b, m, CAST_TO_DISTINCT, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean cast_to_distinct_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_to_distinct_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, CAST_TO_DISTINCT_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // CAST <left paren> SOURCE AS REF <right paren> WITH <cast to ref identifier>
  public static boolean cast_to_ref(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_to_ref")) return false;
    if (!nextTokenIs(b, CAST)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CAST, _LEFT_PAREN_, SOURCE, AS, REF, _RIGHT_PAREN_, WITH, _CAST_TO_REF_IDENTIFIER_);
    exit_section_(b, m, CAST_TO_REF, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean cast_to_ref_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_to_ref_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, CAST_TO_REF_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // CAST <left paren> DISTINCT AS SOURCE <right paren>
  // 		WITH <cast to source identifier>
  public static boolean cast_to_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_to_source")) return false;
    if (!nextTokenIs(b, CAST)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CAST, _LEFT_PAREN_, DISTINCT, AS, SOURCE, _RIGHT_PAREN_, WITH, _CAST_TO_SOURCE_IDENTIFIER_);
    exit_section_(b, m, CAST_TO_SOURCE, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean cast_to_source_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_to_source_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, CAST_TO_SOURCE_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // CAST <left paren> REF AS SOURCE <right paren> WITH <cast to type identifier>
  public static boolean cast_to_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_to_type")) return false;
    if (!nextTokenIs(b, CAST)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CAST, _LEFT_PAREN_, REF, AS, SOURCE, _RIGHT_PAREN_, WITH, _CAST_TO_TYPE_IDENTIFIER_);
    exit_section_(b, m, CAST_TO_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean cast_to_type_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cast_to_type_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, CAST_TO_TYPE_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean catalog_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "catalog_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, CATALOG_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // CATALOG <value specification>
  public static boolean catalog_name_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "catalog_name_characteristic")) return false;
    if (!nextTokenIs(b, CATALOG)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CATALOG, _VALUE_SPECIFICATION_);
    exit_section_(b, m, CATALOG_NAME_CHARACTERISTIC, r);
    return r;
  }

  /* ********************************************************** */
  // { CEIL | CEILING } <left paren> <numeric value expression> <right paren>
  public static boolean ceiling_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ceiling_function")) return false;
    if (!nextTokenIs(b, "<ceiling function>", CEIL, CEILING)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CEILING_FUNCTION, "<ceiling function>");
    r = ceiling_function_0(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && numeric_value_expression(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // CEIL | CEILING
  private static boolean ceiling_function_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ceiling_function_0")) return false;
    boolean r;
    r = consumeToken(b, CEIL);
    if (!r) r = consumeToken(b, CEILING);
    return r;
  }

  /* ********************************************************** */
  // { CHAR_LENGTH | CHARACTER_LENGTH } <left paren> <string value expression> [ USING <char length units> ] <right paren>
  public static boolean char_length_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "char_length_expression")) return false;
    if (!nextTokenIs(b, "<char length expression>", CHARACTER_LENGTH, CHAR_LENGTH)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHAR_LENGTH_EXPRESSION, "<char length expression>");
    r = char_length_expression_0(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && string_value_expression(b, l + 1);
    r = r && char_length_expression_3(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // CHAR_LENGTH | CHARACTER_LENGTH
  private static boolean char_length_expression_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "char_length_expression_0")) return false;
    boolean r;
    r = consumeToken(b, CHAR_LENGTH);
    if (!r) r = consumeToken(b, CHARACTER_LENGTH);
    return r;
  }

  // [ USING <char length units> ]
  private static boolean char_length_expression_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "char_length_expression_3")) return false;
    parseTokens(b, 0, USING, _CHAR_LENGTH_UNITS_);
    return true;
  }

  /* ********************************************************** */
  // CHARACTERS | CODE_UNITS | OCTETS
  public static boolean char_length_units(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "char_length_units")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHAR_LENGTH_UNITS, "<char length units>");
    r = consumeToken(b, CHARACTERS);
    if (!r) r = consumeToken(b, CODE_UNITS);
    if (!r) r = consumeToken(b, OCTETS);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character specifier>
  // 	|	<character specifier> <minus sign> <character specifier>
  // 	|	<left bracket> <colon> <regular character set identifier> <colon> <right bracket>
  public static boolean character_enumeration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_enumeration")) return false;
    if (!nextTokenIs(b, "<character enumeration>", _CHARACTER_SPECIFIER_, _LEFT_BRACKET_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_ENUMERATION, "<character enumeration>");
    r = character_specifier(b, l + 1);
    if (!r) r = character_specifier(b, l + 1);
    if (!r) r = left_bracket(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character enumeration>
  public static boolean character_enumeration_exclude(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_enumeration_exclude")) return false;
    if (!nextTokenIs(b, _CHARACTER_ENUMERATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_enumeration(b, l + 1);
    exit_section_(b, m, CHARACTER_ENUMERATION_EXCLUDE, r);
    return r;
  }

  /* ********************************************************** */
  // <character enumeration>
  public static boolean character_enumeration_include(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_enumeration_include")) return false;
    if (!nextTokenIs(b, _CHARACTER_ENUMERATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_enumeration(b, l + 1);
    exit_section_(b, m, CHARACTER_ENUMERATION_INCLUDE, r);
    return r;
  }

  /* ********************************************************** */
  // <character primary> [ <collate clause> ]
  public static boolean character_factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_factor")) return false;
    if (!nextTokenIs(b, _CHARACTER_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_primary(b, l + 1);
    r = r && character_factor_1(b, l + 1);
    exit_section_(b, m, CHARACTER_FACTOR, r);
    return r;
  }

  // [ <collate clause> ]
  private static boolean character_factor_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_factor_1")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <row value predicand> <character like predicate part 2>
  public static boolean character_like_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_like_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && character_like_predicate_part_2(b, l + 1);
    exit_section_(b, m, CHARACTER_LIKE_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // [ NOT ] LIKE <character pattern> [ ESCAPE <escape character> ]
  public static boolean character_like_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_like_predicate_part_2")) return false;
    if (!nextTokenIs(b, "<character like predicate part 2>", LIKE, NOT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_LIKE_PREDICATE_PART_2, "<character like predicate part 2>");
    r = character_like_predicate_part_2_0(b, l + 1);
    r = r && consumeTokens(b, 0, LIKE, _CHARACTER_PATTERN_);
    r = r && character_like_predicate_part_2_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ NOT ]
  private static boolean character_like_predicate_part_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_like_predicate_part_2_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ ESCAPE <escape character> ]
  private static boolean character_like_predicate_part_2_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_like_predicate_part_2_3")) return false;
    parseTokens(b, 0, ESCAPE, _ESCAPE_CHARACTER_);
    return true;
  }

  /* ********************************************************** */
  // OVERLAY <left paren> <character value expression> PLACING <character value expression>
  // 		FROM <start position> [ FOR <string length> ] [ USING <char length units> ] <right paren>
  public static boolean character_overlay_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_overlay_function")) return false;
    if (!nextTokenIs(b, OVERLAY)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OVERLAY, _LEFT_PAREN_, _CHARACTER_VALUE_EXPRESSION_, PLACING, _CHARACTER_VALUE_EXPRESSION_, FROM, _START_POSITION_);
    r = r && character_overlay_function_7(b, l + 1);
    r = r && character_overlay_function_8(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, CHARACTER_OVERLAY_FUNCTION, r);
    return r;
  }

  // [ FOR <string length> ]
  private static boolean character_overlay_function_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_overlay_function_7")) return false;
    parseTokens(b, 0, FOR, _STRING_LENGTH_);
    return true;
  }

  // [ USING <char length units> ]
  private static boolean character_overlay_function_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_overlay_function_8")) return false;
    parseTokens(b, 0, USING, _CHAR_LENGTH_UNITS_);
    return true;
  }

  /* ********************************************************** */
  // <character value expression>
  public static boolean character_pattern(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_pattern")) return false;
    if (!nextTokenIs(b, _CHARACTER_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_value_expression(b, l + 1);
    exit_section_(b, m, CHARACTER_PATTERN, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary> | <string value function>
  public static boolean character_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_primary")) return false;
    if (!nextTokenIs(b, "<character primary>", _STRING_VALUE_FUNCTION_, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_PRIMARY, "<character primary>");
    r = value_expression_primary(b, l + 1);
    if (!r) r = string_value_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <nonquote character> | <quote symbol>
  public static boolean character_representation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_representation")) return false;
    if (!nextTokenIs(b, "<character representation>", _NONQUOTE_CHARACTER_, _QUOTE_SYMBOL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_REPRESENTATION, "<character representation>");
    r = nonquote_character(b, l + 1);
    if (!r) r = quote_symbol(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CREATE CHARACTER SET <character set name> [ AS ] <character set source> [ <collate clause> ]
  public static boolean character_set_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, CHARACTER, SET, _CHARACTER_SET_NAME_);
    r = r && character_set_definition_4(b, l + 1);
    r = r && character_set_source(b, l + 1);
    r = r && character_set_definition_6(b, l + 1);
    exit_section_(b, m, CHARACTER_SET_DEFINITION, r);
    return r;
  }

  // [ AS ]
  private static boolean character_set_definition_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_definition_4")) return false;
    consumeToken(b, AS);
    return true;
  }

  // [ <collate clause> ]
  private static boolean character_set_definition_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_definition_6")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // [ <schema name> <period> ] <SQL language identifier>
  public static boolean character_set_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_name")) return false;
    if (!nextTokenIs(b, "<character set name>", _SCHEMA_NAME_, _SQL_LANGUAGE_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_SET_NAME, "<character set name>");
    r = character_set_name_0(b, l + 1);
    r = r && SQL_language_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <schema name> <period> ]
  private static boolean character_set_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_name_0")) return false;
    schema_name(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // NAMES <value specification>
  public static boolean character_set_name_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_name_characteristic")) return false;
    if (!nextTokenIs(b, NAMES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NAMES, _VALUE_SPECIFICATION_);
    exit_section_(b, m, CHARACTER_SET_NAME_CHARACTERISTIC, r);
    return r;
  }

  /* ********************************************************** */
  // GET <character set specification>
  public static boolean character_set_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_source")) return false;
    if (!nextTokenIs(b, GET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, GET, _CHARACTER_SET_SPECIFICATION_);
    exit_section_(b, m, CHARACTER_SET_SOURCE, r);
    return r;
  }

  /* ********************************************************** */
  // <standard character set name>
  // 	|	<implementation-defined character set name>
  // 	|	<user-defined character set name>
  public static boolean character_set_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_SET_SPECIFICATION, "<character set specification>");
    r = standard_character_set_name(b, l + 1);
    if (!r) r = implementation_defined_character_set_name(b, l + 1);
    if (!r) r = user_defined_character_set_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character set specification> [ { <comma> <character set specification> }... ]
  public static boolean character_set_specification_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_specification_list")) return false;
    if (!nextTokenIs(b, _CHARACTER_SET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_set_specification(b, l + 1);
    r = r && character_set_specification_list_1(b, l + 1);
    exit_section_(b, m, CHARACTER_SET_SPECIFICATION_LIST, r);
    return r;
  }

  // [ { <comma> <character set specification> }... ]
  private static boolean character_set_specification_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_specification_list_1")) return false;
    character_set_specification_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <character set specification>
  private static boolean character_set_specification_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_set_specification_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && character_set_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <non-escaped character> | <escaped character>
  public static boolean character_specifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_specifier")) return false;
    if (!nextTokenIs(b, "<character specifier>", _ESCAPED_CHARACTER_, _NON_ESCAPED_CHARACTER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_SPECIFIER, "<character specifier>");
    r = non_escaped_character(b, l + 1);
    if (!r) r = escaped_character(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <introducer><character set specification> ]
  // 		<quote> [ <character representation>... ] <quote>
  // 		[ { <separator> <quote> [ <character representation>... ] <quote> }... ]
  public static boolean character_string_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_literal")) return false;
    if (!nextTokenIs(b, "<character string literal>", _INTRODUCER_, _QUOTE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_STRING_LITERAL, "<character string literal>");
    r = character_string_literal_0(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && character_string_literal_2(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && character_string_literal_4(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <introducer><character set specification> ]
  private static boolean character_string_literal_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_literal_0")) return false;
    introducer(b, l + 1);
    return true;
  }

  // [ <character representation>... ]
  private static boolean character_string_literal_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_literal_2")) return false;
    consumeToken(b, _CHARACTER_REPRESENTATION____);
    return true;
  }

  // [ { <separator> <quote> [ <character representation>... ] <quote> }... ]
  private static boolean character_string_literal_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_literal_4")) return false;
    character_string_literal_4_0(b, l + 1);
    return true;
  }

  // <separator> <quote> [ <character representation>... ] <quote>
  private static boolean character_string_literal_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_literal_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = separator(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && character_string_literal_4_0_2(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <character representation>... ]
  private static boolean character_string_literal_4_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_literal_4_0_2")) return false;
    consumeToken(b, _CHARACTER_REPRESENTATION____);
    return true;
  }

  /* ********************************************************** */
  // CHARACTER [ <left paren> <length> <right paren> ]
  // 	|	CHAR [ <left paren> <length> <right paren> ]
  // 	|	CHARACTER VARYING <left paren> <length> <right paren>
  // 	|	CHAR VARYING <left paren> <length> <right paren>
  // 	|	VARCHAR <left paren> <length> <right paren>
  // 	|	CHARACTER LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  // 	|	CHAR LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  // 	|	CLOB [ <left paren> <large object length> <right paren> ]
  public static boolean character_string_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_STRING_TYPE, "<character string type>");
    r = character_string_type_0(b, l + 1);
    if (!r) r = character_string_type_1(b, l + 1);
    if (!r) r = parseTokens(b, 0, CHARACTER, VARYING, _LEFT_PAREN_, _LENGTH_, _RIGHT_PAREN_);
    if (!r) r = parseTokens(b, 0, CHAR, VARYING, _LEFT_PAREN_, _LENGTH_, _RIGHT_PAREN_);
    if (!r) r = parseTokens(b, 0, VARCHAR, _LEFT_PAREN_, _LENGTH_, _RIGHT_PAREN_);
    if (!r) r = character_string_type_5(b, l + 1);
    if (!r) r = character_string_type_6(b, l + 1);
    if (!r) r = character_string_type_7(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // CHARACTER [ <left paren> <length> <right paren> ]
  private static boolean character_string_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CHARACTER);
    r = r && character_string_type_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <length> <right paren> ]
  private static boolean character_string_type_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_0_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // CHAR [ <left paren> <length> <right paren> ]
  private static boolean character_string_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CHAR);
    r = r && character_string_type_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <length> <right paren> ]
  private static boolean character_string_type_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_1_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // CHARACTER LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  private static boolean character_string_type_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_5")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHARACTER, LARGE, OBJECT);
    r = r && character_string_type_5_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <large object length> <right paren> ]
  private static boolean character_string_type_5_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_5_3")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // CHAR LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  private static boolean character_string_type_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_6")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHAR, LARGE, OBJECT);
    r = r && character_string_type_6_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <large object length> <right paren> ]
  private static boolean character_string_type_6_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_6_3")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // CLOB [ <left paren> <large object length> <right paren> ]
  private static boolean character_string_type_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_7")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CLOB);
    r = r && character_string_type_7_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <large object length> <right paren> ]
  private static boolean character_string_type_7_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_string_type_7_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SUBSTRING <left paren> <character value expression> FROM <start position>
  // 		[ FOR <string length> ] [ USING <char length units> ] <right paren>
  public static boolean character_substring_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_substring_function")) return false;
    if (!nextTokenIs(b, SUBSTRING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SUBSTRING, _LEFT_PAREN_, _CHARACTER_VALUE_EXPRESSION_, FROM, _START_POSITION_);
    r = r && character_substring_function_5(b, l + 1);
    r = r && character_substring_function_6(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, CHARACTER_SUBSTRING_FUNCTION, r);
    return r;
  }

  // [ FOR <string length> ]
  private static boolean character_substring_function_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_substring_function_5")) return false;
    parseTokens(b, 0, FOR, _STRING_LENGTH_);
    return true;
  }

  // [ USING <char length units> ]
  private static boolean character_substring_function_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_substring_function_6")) return false;
    parseTokens(b, 0, USING, _CHAR_LENGTH_UNITS_);
    return true;
  }

  /* ********************************************************** */
  // TRANSLATE <left paren> <character value expression> USING <transliteration name> <right paren>
  public static boolean character_transliteration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_transliteration")) return false;
    if (!nextTokenIs(b, TRANSLATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TRANSLATE, _LEFT_PAREN_, _CHARACTER_VALUE_EXPRESSION_, USING, _TRANSLITERATION_NAME_, _RIGHT_PAREN_);
    exit_section_(b, m, CHARACTER_TRANSLITERATION, r);
    return r;
  }

  /* ********************************************************** */
  // <concatenation> | <character factor>
  public static boolean character_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_value_expression")) return false;
    if (!nextTokenIs(b, "<character value expression>", _CHARACTER_FACTOR_, _CONCATENATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_VALUE_EXPRESSION, "<character value expression>");
    r = concatenation(b, l + 1);
    if (!r) r = character_factor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character substring function>
  // 	|	<regular expression substring function>
  // 	|	<fold>
  // 	|	<transcoding>
  // 	|	<character transliteration>
  // 	|	<trim function>
  // 	|	<character overlay function>
  // 	|	<normalize function>
  // 	|	<specific type method>
  public static boolean character_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "character_value_function")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CHARACTER_VALUE_FUNCTION, "<character value function>");
    r = character_substring_function(b, l + 1);
    if (!r) r = regular_expression_substring_function(b, l + 1);
    if (!r) r = fold(b, l + 1);
    if (!r) r = transcoding(b, l + 1);
    if (!r) r = character_transliteration(b, l + 1);
    if (!r) r = trim_function(b, l + 1);
    if (!r) r = character_overlay_function(b, l + 1);
    if (!r) r = normalize_function(b, l + 1);
    if (!r) r = specific_type_method(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CHECK <left paren> <search condition> <right paren>
  public static boolean check_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "check_constraint_definition")) return false;
    if (!nextTokenIs(b, CHECK)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CHECK, _LEFT_PAREN_, _SEARCH_CONDITION_, _RIGHT_PAREN_);
    exit_section_(b, m, CHECK_CONSTRAINT_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // ^
  public static boolean circumflex(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, CIRCUMFLEX, true);
    return true;
  }

  /* ********************************************************** */
  // CLOSE <cursor name>
  public static boolean close_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "close_statement")) return false;
    if (!nextTokenIs(b, CLOSE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CLOSE, _CURSOR_NAME_);
    exit_section_(b, m, CLOSE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // COLLATE <collation name>
  public static boolean collate_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collate_clause")) return false;
    if (!nextTokenIs(b, COLLATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, COLLATE, _COLLATION_NAME_);
    exit_section_(b, m, COLLATE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE COLLATION <collation name> FOR <character set specification>
  // 		FROM <existing collation name> [ <pad characteristic> ]
  public static boolean collation_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collation_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, COLLATION, _COLLATION_NAME_, FOR, _CHARACTER_SET_SPECIFICATION_, FROM, _EXISTING_COLLATION_NAME_);
    r = r && collation_definition_7(b, l + 1);
    exit_section_(b, m, COLLATION_DEFINITION, r);
    return r;
  }

  // [ <pad characteristic> ]
  private static boolean collation_definition_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collation_definition_7")) return false;
    pad_characteristic(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean collation_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collation_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, COLLATION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <value specification>
  public static boolean collation_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collation_specification")) return false;
    if (!nextTokenIs(b, _VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_specification(b, l + 1);
    exit_section_(b, m, COLLATION_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // UNNEST <left paren> <collection value expression> <right paren> [ WITH ORDINALITY ]
  public static boolean collection_derived_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collection_derived_table")) return false;
    if (!nextTokenIs(b, UNNEST)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UNNEST, _LEFT_PAREN_, _COLLECTION_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    r = r && collection_derived_table_4(b, l + 1);
    exit_section_(b, m, COLLECTION_DERIVED_TABLE, r);
    return r;
  }

  // [ WITH ORDINALITY ]
  private static boolean collection_derived_table_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collection_derived_table_4")) return false;
    parseTokens(b, 0, WITH, ORDINALITY);
    return true;
  }

  /* ********************************************************** */
  // <array type> | <multiset type>
  public static boolean collection_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collection_type")) return false;
    if (!nextTokenIs(b, "<collection type>", _ARRAY_TYPE_, _MULTISET_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COLLECTION_TYPE, "<collection type>");
    r = array_type(b, l + 1);
    if (!r) r = multiset_type(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <array value constructor> | <multiset value constructor>
  public static boolean collection_value_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collection_value_constructor")) return false;
    if (!nextTokenIs(b, "<collection value constructor>", _ARRAY_VALUE_CONSTRUCTOR_, _MULTISET_VALUE_CONSTRUCTOR_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COLLECTION_VALUE_CONSTRUCTOR, "<collection value constructor>");
    r = array_value_constructor(b, l + 1);
    if (!r) r = multiset_value_constructor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <array value expression> | <multiset value expression>
  public static boolean collection_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "collection_value_expression")) return false;
    if (!nextTokenIs(b, "<collection value expression>", _ARRAY_VALUE_EXPRESSION_, _MULTISET_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COLLECTION_VALUE_EXPRESSION, "<collection value expression>");
    r = array_value_expression(b, l + 1);
    if (!r) r = multiset_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // :
  public static boolean colon(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, COLON, true);
    return true;
  }

  /* ********************************************************** */
  // NOT NULL
  // 	|	<unique specification>
  // 	|	<references specification>
  // 	|	<check constraint definition>
  public static boolean column_constraint(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_constraint")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COLUMN_CONSTRAINT, "<column constraint>");
    r = parseTokens(b, 0, NOT, NULL);
    if (!r) r = unique_specification(b, l + 1);
    if (!r) r = references_specification(b, l + 1);
    if (!r) r = check_constraint_definition(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <constraint name definition> ] <column constraint> [ <constraint characteristics> ]
  public static boolean column_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_constraint_definition")) return false;
    if (!nextTokenIs(b, "<column constraint definition>", _COLUMN_CONSTRAINT_, _CONSTRAINT_NAME_DEFINITION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COLUMN_CONSTRAINT_DEFINITION, "<column constraint definition>");
    r = column_constraint_definition_0(b, l + 1);
    r = r && column_constraint(b, l + 1);
    r = r && column_constraint_definition_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <constraint name definition> ]
  private static boolean column_constraint_definition_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_constraint_definition_0")) return false;
    constraint_name_definition(b, l + 1);
    return true;
  }

  // [ <constraint characteristics> ]
  private static boolean column_constraint_definition_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_constraint_definition_2")) return false;
    constraint_characteristics(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // INCLUDING DEFAULTS | EXCLUDING DEFAULTS
  public static boolean column_default_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_default_option")) return false;
    if (!nextTokenIs(b, "<column default option>", EXCLUDING, INCLUDING)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COLUMN_DEFAULT_OPTION, "<column default option>");
    r = parseTokens(b, 0, INCLUDING, DEFAULTS);
    if (!r) r = parseTokens(b, 0, EXCLUDING, DEFAULTS);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <column name> [ <data type> | <domain name> ] [ <reference scope check> ]
  // 		[ <default clause> | <identity column specification> | <generation clause> ]
  // 		[ <column constraint definition>... ] [ <collate clause> ]
  public static boolean column_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_definition")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    r = r && column_definition_1(b, l + 1);
    r = r && column_definition_2(b, l + 1);
    r = r && column_definition_3(b, l + 1);
    r = r && column_definition_4(b, l + 1);
    r = r && column_definition_5(b, l + 1);
    exit_section_(b, m, COLUMN_DEFINITION, r);
    return r;
  }

  // [ <data type> | <domain name> ]
  private static boolean column_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_definition_1")) return false;
    column_definition_1_0(b, l + 1);
    return true;
  }

  // <data type> | <domain name>
  private static boolean column_definition_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_definition_1_0")) return false;
    boolean r;
    r = data_type(b, l + 1);
    if (!r) r = domain_name(b, l + 1);
    return r;
  }

  // [ <reference scope check> ]
  private static boolean column_definition_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_definition_2")) return false;
    reference_scope_check(b, l + 1);
    return true;
  }

  // [ <default clause> | <identity column specification> | <generation clause> ]
  private static boolean column_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_definition_3")) return false;
    column_definition_3_0(b, l + 1);
    return true;
  }

  // <default clause> | <identity column specification> | <generation clause>
  private static boolean column_definition_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_definition_3_0")) return false;
    boolean r;
    r = default_clause(b, l + 1);
    if (!r) r = identity_column_specification(b, l + 1);
    if (!r) r = generation_clause(b, l + 1);
    return r;
  }

  // [ <column constraint definition>... ]
  private static boolean column_definition_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_definition_4")) return false;
    consumeToken(b, _COLUMN_CONSTRAINT_DEFINITION____);
    return true;
  }

  // [ <collate clause> ]
  private static boolean column_definition_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_definition_5")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean column_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, COLUMN_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <column name> [ { <comma> <column name> }... ]
  public static boolean column_name_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_name_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    r = r && column_name_list_1(b, l + 1);
    exit_section_(b, m, COLUMN_NAME_LIST, r);
    return r;
  }

  // [ { <comma> <column name> }... ]
  private static boolean column_name_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_name_list_1")) return false;
    column_name_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <column name>
  private static boolean column_name_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_name_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && column_name(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // [ <scope clause> ] [ <default clause> ] [ <column constraint definition>... ]
  public static boolean column_option_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_option_list")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COLUMN_OPTION_LIST, "<column option list>");
    r = column_option_list_0(b, l + 1);
    r = r && column_option_list_1(b, l + 1);
    r = r && column_option_list_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <scope clause> ]
  private static boolean column_option_list_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_option_list_0")) return false;
    scope_clause(b, l + 1);
    return true;
  }

  // [ <default clause> ]
  private static boolean column_option_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_option_list_1")) return false;
    default_clause(b, l + 1);
    return true;
  }

  // [ <column constraint definition>... ]
  private static boolean column_option_list_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_option_list_2")) return false;
    consumeToken(b, _COLUMN_CONSTRAINT_DEFINITION____);
    return true;
  }

  /* ********************************************************** */
  // <column name> WITH OPTIONS <column option list>
  public static boolean column_options(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_options")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    r = r && consumeTokens(b, 0, WITH, OPTIONS, _COLUMN_OPTION_LIST_);
    exit_section_(b, m, COLUMN_OPTIONS, r);
    return r;
  }

  /* ********************************************************** */
  // <basic identifier chain>
  // 	|	MODULE <period> <qualified identifier> <period> <column name>
  public static boolean column_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "column_reference")) return false;
    if (!nextTokenIs(b, "<column reference>", MODULE, _BASIC_IDENTIFIER_CHAIN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COLUMN_REFERENCE, "<column reference>");
    r = basic_identifier_chain(b, l + 1);
    if (!r) r = parseTokens(b, 0, MODULE, _PERIOD_, _QUALIFIED_IDENTIFIER_, _PERIOD_, _COLUMN_NAME_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ,
  public static boolean comma(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, COMMA, true);
    return true;
  }

  /* ********************************************************** */
  // <simple comment> | <bracketed comment>
  public static boolean comment(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "comment")) return false;
    if (!nextTokenIs(b, "<comment>", _BRACKETED_COMMENT_, _SIMPLE_COMMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COMMENT, "<comment>");
    r = simple_comment(b, l + 1);
    if (!r) r = bracketed_comment(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <nonquote character> | <quote>
  public static boolean comment_character(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "comment_character")) return false;
    if (!nextTokenIs(b, "<comment character>", _NONQUOTE_CHARACTER_, _QUOTE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COMMENT_CHARACTER, "<comment character>");
    r = nonquote_character(b, l + 1);
    if (!r) r = quote(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // COMMIT [ WORK ] [ AND [ NO ] CHAIN ]
  public static boolean commit_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "commit_statement")) return false;
    if (!nextTokenIs(b, COMMIT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, COMMIT);
    r = r && commit_statement_1(b, l + 1);
    r = r && commit_statement_2(b, l + 1);
    exit_section_(b, m, COMMIT_STATEMENT, r);
    return r;
  }

  // [ WORK ]
  private static boolean commit_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "commit_statement_1")) return false;
    consumeToken(b, WORK);
    return true;
  }

  // [ AND [ NO ] CHAIN ]
  private static boolean commit_statement_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "commit_statement_2")) return false;
    commit_statement_2_0(b, l + 1);
    return true;
  }

  // AND [ NO ] CHAIN
  private static boolean commit_statement_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "commit_statement_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, AND);
    r = r && commit_statement_2_0_1(b, l + 1);
    r = r && consumeToken(b, CHAIN);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ NO ]
  private static boolean commit_statement_2_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "commit_statement_2_0_1")) return false;
    consumeToken(b, NO);
    return true;
  }

  /* ********************************************************** */
  // <sequence generator start with option> | <basic sequence generator option>
  public static boolean common_sequence_generator_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "common_sequence_generator_option")) return false;
    if (!nextTokenIs(b, "<common sequence generator option>", _BASIC_SEQUENCE_GENERATOR_OPTION_, _SEQUENCE_GENERATOR_START_WITH_OPTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COMMON_SEQUENCE_GENERATOR_OPTION, "<common sequence generator option>");
    r = sequence_generator_start_with_option(b, l + 1);
    if (!r) r = basic_sequence_generator_option(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <common sequence generator option> ...
  public static boolean common_sequence_generator_options(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "common_sequence_generator_options")) return false;
    if (!nextTokenIs(b, _COMMON_SEQUENCE_GENERATOR_OPTION_____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _COMMON_SEQUENCE_GENERATOR_OPTION_____);
    exit_section_(b, m, COMMON_SEQUENCE_GENERATOR_OPTIONS, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  // 	|	<string value expression>
  // 	|	<datetime value expression>
  // 	|	<interval value expression>
  // 	|	<user-defined type value expression>
  // 	|	<reference value expression>
  // 	|	<collection value expression>
  public static boolean common_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "common_value_expression")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COMMON_VALUE_EXPRESSION, "<common value expression>");
    r = numeric_value_expression(b, l + 1);
    if (!r) r = string_value_expression(b, l + 1);
    if (!r) r = datetime_value_expression(b, l + 1);
    if (!r) r = interval_value_expression(b, l + 1);
    if (!r) r = user_defined_type_value_expression(b, l + 1);
    if (!r) r = reference_value_expression(b, l + 1);
    if (!r) r = collection_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <equals operator>
  // 	|	<not equals operator>
  // 	|	<less than operator>
  // 	|	<greater than operator>
  // 	|	<less than or equals operator>
  // 	|	<greater than or equals operator>
  public static boolean comp_op(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "comp_op")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COMP_OP, "<comp op>");
    r = equals_operator(b, l + 1);
    if (!r) r = not_equals_operator(b, l + 1);
    if (!r) r = less_than_operator(b, l + 1);
    if (!r) r = greater_than_operator(b, l + 1);
    if (!r) r = less_than_or_equals_operator(b, l + 1);
    if (!r) r = greater_than_or_equals_operator(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <comparison predicate part 2>
  public static boolean comparison_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "comparison_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && comparison_predicate_part_2(b, l + 1);
    exit_section_(b, m, COMPARISON_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // <comp op> <row value predicand>
  public static boolean comparison_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "comparison_predicate_part_2")) return false;
    if (!nextTokenIs(b, _COMP_OP_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comp_op(b, l + 1);
    r = r && row_value_predicand(b, l + 1);
    exit_section_(b, m, COMPARISON_PREDICATE_PART_2, r);
    return r;
  }

  /* ********************************************************** */
  // AVG | MAX | MIN | SUM
  // 	|	EVERY | ANY | SOME
  // 	|	COUNT
  // 	|	STDDEV_POP | STDDEV_SAMP | VAR_SAMP | VAR_POP
  // 	|	COLLECT | FUSION | INTERSECTION
  public static boolean computational_operation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "computational_operation")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, COMPUTATIONAL_OPERATION, "<computational operation>");
    r = consumeToken(b, AVG);
    if (!r) r = consumeToken(b, MAX);
    if (!r) r = consumeToken(b, MIN);
    if (!r) r = consumeToken(b, SUM);
    if (!r) r = consumeToken(b, EVERY);
    if (!r) r = consumeToken(b, ANY);
    if (!r) r = consumeToken(b, SOME);
    if (!r) r = consumeToken(b, COUNT);
    if (!r) r = consumeToken(b, STDDEV_POP);
    if (!r) r = consumeToken(b, STDDEV_SAMP);
    if (!r) r = consumeToken(b, VAR_SAMP);
    if (!r) r = consumeToken(b, VAR_POP);
    if (!r) r = consumeToken(b, COLLECT);
    if (!r) r = consumeToken(b, FUSION);
    if (!r) r = consumeToken(b, INTERSECTION);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character value expression> <concatenation operator> <character factor>
  public static boolean concatenation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "concatenation")) return false;
    if (!nextTokenIs(b, _CHARACTER_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_value_expression(b, l + 1);
    r = r && concatenation_operator(b, l + 1);
    r = r && character_factor(b, l + 1);
    exit_section_(b, m, CONCATENATION, r);
    return r;
  }

  /* ********************************************************** */
  // <vertical bar> <vertical bar>
  public static boolean concatenation_operator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "concatenation_operator")) return false;
    if (!nextTokenIs(b, _VERTICAL_BAR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = vertical_bar(b, l + 1);
    r = r && vertical_bar(b, l + 1);
    exit_section_(b, m, CONCATENATION_OPERATOR, r);
    return r;
  }

  /* ********************************************************** */
  // <SQL condition>
  public static boolean condition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition")) return false;
    if (!nextTokenIs(b, _SQL_CONDITION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_condition(b, l + 1);
    exit_section_(b, m, CONDITION, r);
    return r;
  }

  /* ********************************************************** */
  // CONTINUE | <go to>
  public static boolean condition_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition_action")) return false;
    if (!nextTokenIs(b, "<condition action>", CONTINUE, _GO_TO_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONDITION_ACTION, "<condition action>");
    r = consumeToken(b, CONTINUE);
    if (!r) r = go_to(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // { EXCEPTION | CONDITION } <condition number> <condition information item> [ { <comma> <condition information item> }... ]
  public static boolean condition_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition_information")) return false;
    if (!nextTokenIs(b, "<condition information>", CONDITION, EXCEPTION)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONDITION_INFORMATION, "<condition information>");
    r = condition_information_0(b, l + 1);
    r = r && condition_number(b, l + 1);
    r = r && condition_information_item(b, l + 1);
    r = r && condition_information_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // EXCEPTION | CONDITION
  private static boolean condition_information_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition_information_0")) return false;
    boolean r;
    r = consumeToken(b, EXCEPTION);
    if (!r) r = consumeToken(b, CONDITION);
    return r;
  }

  // [ { <comma> <condition information item> }... ]
  private static boolean condition_information_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition_information_3")) return false;
    condition_information_3_0(b, l + 1);
    return true;
  }

  // <comma> <condition information item>
  private static boolean condition_information_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition_information_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && condition_information_item(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <simple target specification> <equals operator> <condition information item name>
  public static boolean condition_information_item(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition_information_item")) return false;
    if (!nextTokenIs(b, _SIMPLE_TARGET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_target_specification(b, l + 1);
    r = r && equals_operator(b, l + 1);
    r = r && condition_information_item_name(b, l + 1);
    exit_section_(b, m, CONDITION_INFORMATION_ITEM, r);
    return r;
  }

  /* ********************************************************** */
  // CATALOG_NAME
  // 	|	CLASS_ORIGIN
  // 	|	COLUMN_NAME
  // 	|	CONDITION_NUMBER
  // 	|	CONNECTION_NAME
  // 	|	CONSTRAINT_CATALOG
  // 	|	CONSTRAINT_NAME
  // 	|	CONSTRAINT_SCHEMA
  // 	|	CURSOR_NAME
  // 	|	MESSAGE_LENGTH
  // 	|	MESSAGE_OCTET_LENGTH
  // 	|	MESSAGE_TEXT
  // 	|	PARAMETER_MODE
  // 	|	PARAMETER_NAME
  // 	|	PARAMETER_ORDINAL_POSITION
  // 	|	RETURNED_SQLSTATE
  // 	|	ROUTINE_CATALOG
  // 	|	ROUTINE_NAME
  // 	|	ROUTINE_SCHEMA
  // 	|	SCHEMA_NAME
  // 	|	SERVER_NAME
  // 	|	SPECIFIC_NAME
  // 	|	SUBCLASS_ORIGIN
  // 	|	TABLE_NAME
  // 	|	TRIGGER_CATALOG
  // 	|	TRIGGER_NAME
  // 	|	TRIGGER_SCHEMA
  public static boolean condition_information_item_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition_information_item_name")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONDITION_INFORMATION_ITEM_NAME, "<condition information item name>");
    r = consumeToken(b, CATALOG_NAME);
    if (!r) r = consumeToken(b, CLASS_ORIGIN);
    if (!r) r = consumeToken(b, COLUMN_NAME);
    if (!r) r = consumeToken(b, CONDITION_NUMBER);
    if (!r) r = consumeToken(b, CONNECTION_NAME);
    if (!r) r = consumeToken(b, CONSTRAINT_CATALOG);
    if (!r) r = consumeToken(b, CONSTRAINT_NAME);
    if (!r) r = consumeToken(b, CONSTRAINT_SCHEMA);
    if (!r) r = consumeToken(b, CURSOR_NAME);
    if (!r) r = consumeToken(b, MESSAGE_LENGTH);
    if (!r) r = consumeToken(b, MESSAGE_OCTET_LENGTH);
    if (!r) r = consumeToken(b, MESSAGE_TEXT);
    if (!r) r = consumeToken(b, PARAMETER_MODE);
    if (!r) r = consumeToken(b, PARAMETER_NAME);
    if (!r) r = consumeToken(b, PARAMETER_ORDINAL_POSITION);
    if (!r) r = consumeToken(b, RETURNED_SQLSTATE);
    if (!r) r = consumeToken(b, ROUTINE_CATALOG);
    if (!r) r = consumeToken(b, ROUTINE_NAME);
    if (!r) r = consumeToken(b, ROUTINE_SCHEMA);
    if (!r) r = consumeToken(b, SCHEMA_NAME);
    if (!r) r = consumeToken(b, SERVER_NAME);
    if (!r) r = consumeToken(b, SPECIFIC_NAME);
    if (!r) r = consumeToken(b, SUBCLASS_ORIGIN);
    if (!r) r = consumeToken(b, TABLE_NAME);
    if (!r) r = consumeToken(b, TRIGGER_CATALOG);
    if (!r) r = consumeToken(b, TRIGGER_NAME);
    if (!r) r = consumeToken(b, TRIGGER_SCHEMA);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean condition_number(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "condition_number")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, CONDITION_NUMBER, r);
    return r;
  }

  /* ********************************************************** */
  // CONNECT TO <connection target>
  public static boolean connect_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "connect_statement")) return false;
    if (!nextTokenIs(b, CONNECT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CONNECT, TO, _CONNECTION_TARGET_);
    exit_section_(b, m, CONNECT_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean connection_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "connection_name")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, CONNECTION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // DEFAULT | <connection name>
  public static boolean connection_object(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "connection_object")) return false;
    if (!nextTokenIs(b, "<connection object>", DEFAULT, _CONNECTION_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONNECTION_OBJECT, "<connection object>");
    r = consumeToken(b, DEFAULT);
    if (!r) r = connection_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL-server name> [ AS <connection name> ] [ USER <connection user name> ]
  // 	|	DEFAULT
  public static boolean connection_target(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "connection_target")) return false;
    if (!nextTokenIs(b, "<connection target>", DEFAULT, _SQL_SERVER_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONNECTION_TARGET, "<connection target>");
    r = connection_target_0(b, l + 1);
    if (!r) r = consumeToken(b, DEFAULT);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <SQL-server name> [ AS <connection name> ] [ USER <connection user name> ]
  private static boolean connection_target_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "connection_target_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_server_name(b, l + 1);
    r = r && connection_target_0_1(b, l + 1);
    r = r && connection_target_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS <connection name> ]
  private static boolean connection_target_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "connection_target_0_1")) return false;
    parseTokens(b, 0, AS, _CONNECTION_NAME_);
    return true;
  }

  // [ USER <connection user name> ]
  private static boolean connection_target_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "connection_target_0_2")) return false;
    parseTokens(b, 0, USER, _CONNECTION_USER_NAME_);
    return true;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean connection_user_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "connection_user_name")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, CONNECTION_USER_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <constraint check time> [ [ NOT ] DEFERRABLE ]
  // 	|	[ NOT ] DEFERRABLE [ <constraint check time> ]
  public static boolean constraint_characteristics(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_characteristics")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONSTRAINT_CHARACTERISTICS, "<constraint characteristics>");
    r = constraint_characteristics_0(b, l + 1);
    if (!r) r = constraint_characteristics_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <constraint check time> [ [ NOT ] DEFERRABLE ]
  private static boolean constraint_characteristics_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_characteristics_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = constraint_check_time(b, l + 1);
    r = r && constraint_characteristics_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ [ NOT ] DEFERRABLE ]
  private static boolean constraint_characteristics_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_characteristics_0_1")) return false;
    constraint_characteristics_0_1_0(b, l + 1);
    return true;
  }

  // [ NOT ] DEFERRABLE
  private static boolean constraint_characteristics_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_characteristics_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = constraint_characteristics_0_1_0_0(b, l + 1);
    r = r && consumeToken(b, DEFERRABLE);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ NOT ]
  private static boolean constraint_characteristics_0_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_characteristics_0_1_0_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ NOT ] DEFERRABLE [ <constraint check time> ]
  private static boolean constraint_characteristics_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_characteristics_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = constraint_characteristics_1_0(b, l + 1);
    r = r && consumeToken(b, DEFERRABLE);
    r = r && constraint_characteristics_1_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ NOT ]
  private static boolean constraint_characteristics_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_characteristics_1_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ <constraint check time> ]
  private static boolean constraint_characteristics_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_characteristics_1_2")) return false;
    constraint_check_time(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // INITIALLY DEFERRED | INITIALLY IMMEDIATE
  public static boolean constraint_check_time(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_check_time")) return false;
    if (!nextTokenIs(b, INITIALLY)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, INITIALLY, DEFERRED);
    if (!r) r = parseTokens(b, 0, INITIALLY, IMMEDIATE);
    exit_section_(b, m, CONSTRAINT_CHECK_TIME, r);
    return r;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean constraint_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, CONSTRAINT_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // CONSTRAINT <constraint name>
  public static boolean constraint_name_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_name_definition")) return false;
    if (!nextTokenIs(b, CONSTRAINT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CONSTRAINT, _CONSTRAINT_NAME_);
    exit_section_(b, m, CONSTRAINT_NAME_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // ALL | <constraint name> [ { <comma> <constraint name> }... ]
  public static boolean constraint_name_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_name_list")) return false;
    if (!nextTokenIs(b, "<constraint name list>", ALL, _CONSTRAINT_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONSTRAINT_NAME_LIST, "<constraint name list>");
    r = consumeToken(b, ALL);
    if (!r) r = constraint_name_list_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <constraint name> [ { <comma> <constraint name> }... ]
  private static boolean constraint_name_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_name_list_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = constraint_name(b, l + 1);
    r = r && constraint_name_list_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <constraint name> }... ]
  private static boolean constraint_name_list_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_name_list_1_1")) return false;
    constraint_name_list_1_1_0(b, l + 1);
    return true;
  }

  // <comma> <constraint name>
  private static boolean constraint_name_list_1_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constraint_name_list_1_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && constraint_name(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <routine invocation>
  public static boolean constructor_method_selection(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "constructor_method_selection")) return false;
    if (!nextTokenIs(b, _ROUTINE_INVOCATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = routine_invocation(b, l + 1);
    exit_section_(b, m, CONSTRUCTOR_METHOD_SELECTION, r);
    return r;
  }

  /* ********************************************************** */
  // <common value expression>
  // 	|	<boolean value expression>
  // 	|	<contextually typed value specification>
  // 	|	<left paren> <contextually typed row value constructor element> <comma> <contextually typed row value constructor element list> <right paren>
  // 	|	ROW <left paren> <contextually typed row value constructor element list> <right paren>
  public static boolean contextually_typed_row_value_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_constructor")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR, "<contextually typed row value constructor>");
    r = common_value_expression(b, l + 1);
    if (!r) r = boolean_value_expression(b, l + 1);
    if (!r) r = contextually_typed_value_specification(b, l + 1);
    if (!r) r = left_paren(b, l + 1);
    if (!r) r = parseTokens(b, 0, ROW, _LEFT_PAREN_, _CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR_ELEMENT_LIST_, _RIGHT_PAREN_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  // 	|	<contextually typed value specification>
  public static boolean contextually_typed_row_value_constructor_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_constructor_element")) return false;
    if (!nextTokenIs(b, "<contextually typed row value constructor element>", _CONTEXTUALLY_TYPED_VALUE_SPECIFICATION_, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR_ELEMENT, "<contextually typed row value constructor element>");
    r = value_expression(b, l + 1);
    if (!r) r = contextually_typed_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <contextually typed row value constructor element>
  // 		[ { <comma> <contextually typed row value constructor element> }... ]
  public static boolean contextually_typed_row_value_constructor_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_constructor_element_list")) return false;
    if (!nextTokenIs(b, _CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR_ELEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = contextually_typed_row_value_constructor_element(b, l + 1);
    r = r && contextually_typed_row_value_constructor_element_list_1(b, l + 1);
    exit_section_(b, m, CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR_ELEMENT_LIST, r);
    return r;
  }

  // [ { <comma> <contextually typed row value constructor element> }... ]
  private static boolean contextually_typed_row_value_constructor_element_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_constructor_element_list_1")) return false;
    contextually_typed_row_value_constructor_element_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <contextually typed row value constructor element>
  private static boolean contextually_typed_row_value_constructor_element_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_constructor_element_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && contextually_typed_row_value_constructor_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <row value special case>
  // 	|	<contextually typed row value constructor>
  public static boolean contextually_typed_row_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_expression")) return false;
    if (!nextTokenIs(b, "<contextually typed row value expression>", _CONTEXTUALLY_TYPED_ROW_VALUE_CONSTRUCTOR_, _ROW_VALUE_SPECIAL_CASE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONTEXTUALLY_TYPED_ROW_VALUE_EXPRESSION, "<contextually typed row value expression>");
    r = row_value_special_case(b, l + 1);
    if (!r) r = contextually_typed_row_value_constructor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <contextually typed row value expression> [ { <comma> <contextually typed row value expression> }... ]
  public static boolean contextually_typed_row_value_expression_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_expression_list")) return false;
    if (!nextTokenIs(b, _CONTEXTUALLY_TYPED_ROW_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = contextually_typed_row_value_expression(b, l + 1);
    r = r && contextually_typed_row_value_expression_list_1(b, l + 1);
    exit_section_(b, m, CONTEXTUALLY_TYPED_ROW_VALUE_EXPRESSION_LIST, r);
    return r;
  }

  // [ { <comma> <contextually typed row value expression> }... ]
  private static boolean contextually_typed_row_value_expression_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_expression_list_1")) return false;
    contextually_typed_row_value_expression_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <contextually typed row value expression>
  private static boolean contextually_typed_row_value_expression_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_row_value_expression_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && contextually_typed_row_value_expression(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // VALUES <contextually typed row value expression list>
  public static boolean contextually_typed_table_value_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_table_value_constructor")) return false;
    if (!nextTokenIs(b, VALUES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, VALUES, _CONTEXTUALLY_TYPED_ROW_VALUE_EXPRESSION_LIST_);
    exit_section_(b, m, CONTEXTUALLY_TYPED_TABLE_VALUE_CONSTRUCTOR, r);
    return r;
  }

  /* ********************************************************** */
  // <implicitly typed value specification> | <default specification>
  public static boolean contextually_typed_value_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "contextually_typed_value_specification")) return false;
    if (!nextTokenIs(b, "<contextually typed value specification>", _DEFAULT_SPECIFICATION_, _IMPLICITLY_TYPED_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CONTEXTUALLY_TYPED_VALUE_SPECIFICATION, "<contextually typed value specification>");
    r = implicitly_typed_value_specification(b, l + 1);
    if (!r) r = default_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean correlation_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "correlation_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, CORRELATION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean corresponding_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "corresponding_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, CORRESPONDING_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // CORRESPONDING [ BY <left paren> <corresponding column list> <right paren> ]
  public static boolean corresponding_spec(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "corresponding_spec")) return false;
    if (!nextTokenIs(b, CORRESPONDING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CORRESPONDING);
    r = r && corresponding_spec_1(b, l + 1);
    exit_section_(b, m, CORRESPONDING_SPEC, r);
    return r;
  }

  // [ BY <left paren> <corresponding column list> <right paren> ]
  private static boolean corresponding_spec_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "corresponding_spec_1")) return false;
    parseTokens(b, 0, BY, _LEFT_PAREN_, _CORRESPONDING_COLUMN_LIST_, _RIGHT_PAREN_);
    return true;
  }

  /* ********************************************************** */
  // <table reference> CROSS JOIN <table primary>
  public static boolean cross_join(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cross_join")) return false;
    if (!nextTokenIs(b, _TABLE_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_reference(b, l + 1);
    r = r && consumeTokens(b, 0, CROSS, JOIN, _TABLE_PRIMARY_);
    exit_section_(b, m, CROSS_JOIN, r);
    return r;
  }

  /* ********************************************************** */
  // CUBE <left paren> <ordinary grouping set list> <right paren>
  public static boolean cube_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cube_list")) return false;
    if (!nextTokenIs(b, CUBE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CUBE, _LEFT_PAREN_, _ORDINARY_GROUPING_SET_LIST_, _RIGHT_PAREN_);
    exit_section_(b, m, CUBE_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // CURRENT_COLLATION <left paren> <string value expression> <right paren>
  public static boolean current_collation_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_collation_specification")) return false;
    if (!nextTokenIs(b, CURRENT_COLLATION)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CURRENT_COLLATION, _LEFT_PAREN_, _STRING_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, CURRENT_COLLATION_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // CURRENT_DATE
  public static boolean current_date_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_date_value_function")) return false;
    if (!nextTokenIs(b, CURRENT_DATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CURRENT_DATE);
    exit_section_(b, m, CURRENT_DATE_VALUE_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // LOCALTIME [ <left paren> <time precision> <right paren> ]
  public static boolean current_local_time_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_local_time_value_function")) return false;
    if (!nextTokenIs(b, LOCALTIME)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LOCALTIME);
    r = r && current_local_time_value_function_1(b, l + 1);
    exit_section_(b, m, CURRENT_LOCAL_TIME_VALUE_FUNCTION, r);
    return r;
  }

  // [ <left paren> <time precision> <right paren> ]
  private static boolean current_local_time_value_function_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_local_time_value_function_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // LOCALTIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
  public static boolean current_local_timestamp_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_local_timestamp_value_function")) return false;
    if (!nextTokenIs(b, LOCALTIMESTAMP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LOCALTIMESTAMP);
    r = r && current_local_timestamp_value_function_1(b, l + 1);
    exit_section_(b, m, CURRENT_LOCAL_TIMESTAMP_VALUE_FUNCTION, r);
    return r;
  }

  // [ <left paren> <timestamp precision> <right paren> ]
  private static boolean current_local_timestamp_value_function_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_local_timestamp_value_function_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // CURRENT_TIME [ <left paren> <time precision> <right paren> ]
  public static boolean current_time_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_time_value_function")) return false;
    if (!nextTokenIs(b, CURRENT_TIME)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CURRENT_TIME);
    r = r && current_time_value_function_1(b, l + 1);
    exit_section_(b, m, CURRENT_TIME_VALUE_FUNCTION, r);
    return r;
  }

  // [ <left paren> <time precision> <right paren> ]
  private static boolean current_time_value_function_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_time_value_function_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // CURRENT_TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
  public static boolean current_timestamp_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_timestamp_value_function")) return false;
    if (!nextTokenIs(b, CURRENT_TIMESTAMP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CURRENT_TIMESTAMP);
    r = r && current_timestamp_value_function_1(b, l + 1);
    exit_section_(b, m, CURRENT_TIMESTAMP_VALUE_FUNCTION, r);
    return r;
  }

  // [ <left paren> <timestamp precision> <right paren> ]
  private static boolean current_timestamp_value_function_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "current_timestamp_value_function_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <cursor sensitivity>
  // 	|	<cursor scrollability>
  // 	|	<cursor holdability>
  // 	|	<cursor returnability>
  public static boolean cursor_attribute(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_attribute")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CURSOR_ATTRIBUTE, "<cursor attribute>");
    r = cursor_sensitivity(b, l + 1);
    if (!r) r = cursor_scrollability(b, l + 1);
    if (!r) r = cursor_holdability(b, l + 1);
    if (!r) r = cursor_returnability(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <cursor attribute>...
  public static boolean cursor_attributes(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_attributes")) return false;
    if (!nextTokenIs(b, _CURSOR_ATTRIBUTE____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _CURSOR_ATTRIBUTE____);
    exit_section_(b, m, CURSOR_ATTRIBUTES, r);
    return r;
  }

  /* ********************************************************** */
  // WITH HOLD | WITHOUT HOLD
  public static boolean cursor_holdability(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_holdability")) return false;
    if (!nextTokenIs(b, "<cursor holdability>", WITH, WITHOUT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CURSOR_HOLDABILITY, "<cursor holdability>");
    r = parseTokens(b, 0, WITH, HOLD);
    if (!r) r = parseTokens(b, 0, WITHOUT, HOLD);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <statement cursor> | <result set cursor>
  public static boolean cursor_intent(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_intent")) return false;
    if (!nextTokenIs(b, "<cursor intent>", _RESULT_SET_CURSOR_, _STATEMENT_CURSOR_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CURSOR_INTENT, "<cursor intent>");
    r = statement_cursor(b, l + 1);
    if (!r) r = result_set_cursor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <local qualified name>
  public static boolean cursor_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_name")) return false;
    if (!nextTokenIs(b, _LOCAL_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = local_qualified_name(b, l + 1);
    exit_section_(b, m, CURSOR_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // WITH RETURN | WITHOUT RETURN
  public static boolean cursor_returnability(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_returnability")) return false;
    if (!nextTokenIs(b, "<cursor returnability>", WITH, WITHOUT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CURSOR_RETURNABILITY, "<cursor returnability>");
    r = parseTokens(b, 0, WITH, RETURN);
    if (!r) r = parseTokens(b, 0, WITHOUT, RETURN);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SCROLL | NO SCROLL
  public static boolean cursor_scrollability(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_scrollability")) return false;
    if (!nextTokenIs(b, "<cursor scrollability>", NO, SCROLL)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CURSOR_SCROLLABILITY, "<cursor scrollability>");
    r = consumeToken(b, SCROLL);
    if (!r) r = parseTokens(b, 0, NO, SCROLL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SENSITIVE | INSENSITIVE | ASENSITIVE
  public static boolean cursor_sensitivity(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_sensitivity")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CURSOR_SENSITIVITY, "<cursor sensitivity>");
    r = consumeToken(b, SENSITIVE);
    if (!r) r = consumeToken(b, INSENSITIVE);
    if (!r) r = consumeToken(b, ASENSITIVE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <query expression> [ <order by clause> ] [ <updatability clause> ]
  public static boolean cursor_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_specification")) return false;
    if (!nextTokenIs(b, _QUERY_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = query_expression(b, l + 1);
    r = r && cursor_specification_1(b, l + 1);
    r = r && cursor_specification_2(b, l + 1);
    exit_section_(b, m, CURSOR_SPECIFICATION, r);
    return r;
  }

  // [ <order by clause> ]
  private static boolean cursor_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_specification_1")) return false;
    order_by_clause(b, l + 1);
    return true;
  }

  // [ <updatability clause> ]
  private static boolean cursor_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cursor_specification_2")) return false;
    updatability_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // CYCLE <cycle column list>
  // 		SET <cycle mark column> TO <cycle mark value>
  // 		DEFAULT <non-cycle mark value>
  // 		USING <path column>
  public static boolean cycle_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cycle_clause")) return false;
    if (!nextTokenIs(b, CYCLE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CYCLE, _CYCLE_COLUMN_LIST_, SET, _CYCLE_MARK_COLUMN_, TO, _CYCLE_MARK_VALUE_, DEFAULT, _NON_CYCLE_MARK_VALUE_, USING, _PATH_COLUMN_);
    exit_section_(b, m, CYCLE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <column name>
  public static boolean cycle_column(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cycle_column")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    exit_section_(b, m, CYCLE_COLUMN, r);
    return r;
  }

  /* ********************************************************** */
  // <cycle column> [ { <comma> <cycle column> }... ]
  public static boolean cycle_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cycle_column_list")) return false;
    if (!nextTokenIs(b, _CYCLE_COLUMN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = cycle_column(b, l + 1);
    r = r && cycle_column_list_1(b, l + 1);
    exit_section_(b, m, CYCLE_COLUMN_LIST, r);
    return r;
  }

  // [ { <comma> <cycle column> }... ]
  private static boolean cycle_column_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cycle_column_list_1")) return false;
    cycle_column_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <cycle column>
  private static boolean cycle_column_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cycle_column_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && cycle_column(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <column name>
  public static boolean cycle_mark_column(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cycle_mark_column")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    exit_section_(b, m, CYCLE_MARK_COLUMN, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  public static boolean cycle_mark_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "cycle_mark_value")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    exit_section_(b, m, CYCLE_MARK_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <predefined type>
  // 	|	<row type>
  // 	|	<path-resolved user-defined type name>
  // 	|	<reference type>
  // 	|	<collection type>
  public static boolean data_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "data_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DATA_TYPE, "<data type>");
    r = predefined_type(b, l + 1);
    if (!r) r = row_type(b, l + 1);
    if (!r) r = path_resolved_user_defined_type_name(b, l + 1);
    if (!r) r = reference_type(b, l + 1);
    if (!r) r = collection_type(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <left paren> [ <data type> [ { <comma> <data type> }... ] ] <right paren>
  public static boolean data_type_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "data_type_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && data_type_list_1(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, DATA_TYPE_LIST, r);
    return r;
  }

  // [ <data type> [ { <comma> <data type> }... ] ]
  private static boolean data_type_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "data_type_list_1")) return false;
    data_type_list_1_0(b, l + 1);
    return true;
  }

  // <data type> [ { <comma> <data type> }... ]
  private static boolean data_type_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "data_type_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    r = r && data_type_list_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <data type> }... ]
  private static boolean data_type_list_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "data_type_list_1_0_1")) return false;
    data_type_list_1_0_1_0(b, l + 1);
    return true;
  }

  // <comma> <data type>
  private static boolean data_type_list_1_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "data_type_list_1_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && data_type(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // DATE <date string>
  public static boolean date_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "date_literal")) return false;
    if (!nextTokenIs(b, DATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DATE, _DATE_STRING_);
    exit_section_(b, m, DATE_LITERAL, r);
    return r;
  }

  /* ********************************************************** */
  // <quote> <unquoted date string> <quote>
  public static boolean date_string(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "date_string")) return false;
    if (!nextTokenIs(b, _QUOTE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = quote(b, l + 1);
    r = r && unquoted_date_string(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, DATE_STRING, r);
    return r;
  }

  /* ********************************************************** */
  // <years value> <minus sign> <months value> <minus sign> <days value>
  public static boolean date_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "date_value")) return false;
    if (!nextTokenIs(b, _YEARS_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = years_value(b, l + 1);
    r = r && minus_sign(b, l + 1);
    r = r && months_value(b, l + 1);
    r = r && minus_sign(b, l + 1);
    r = r && days_value(b, l + 1);
    exit_section_(b, m, DATE_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <datetime primary> [ <time zone> ]
  public static boolean datetime_factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_factor")) return false;
    if (!nextTokenIs(b, _DATETIME_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = datetime_primary(b, l + 1);
    r = r && datetime_factor_1(b, l + 1);
    exit_section_(b, m, DATETIME_FACTOR, r);
    return r;
  }

  // [ <time zone> ]
  private static boolean datetime_factor_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_factor_1")) return false;
    time_zone(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <date literal> | <time literal> | <timestamp literal>
  public static boolean datetime_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_literal")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DATETIME_LITERAL, "<datetime literal>");
    r = date_literal(b, l + 1);
    if (!r) r = time_literal(b, l + 1);
    if (!r) r = timestamp_literal(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary> | <datetime value function>
  public static boolean datetime_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_primary")) return false;
    if (!nextTokenIs(b, "<datetime primary>", _DATETIME_VALUE_FUNCTION_, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DATETIME_PRIMARY, "<datetime primary>");
    r = value_expression_primary(b, l + 1);
    if (!r) r = datetime_value_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <datetime factor>
  public static boolean datetime_term(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_term")) return false;
    if (!nextTokenIs(b, _DATETIME_FACTOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = datetime_factor(b, l + 1);
    exit_section_(b, m, DATETIME_TERM, r);
    return r;
  }

  /* ********************************************************** */
  // DATE
  // 	|	TIME [ <left paren> <time precision> <right paren> ] [ <with or without time zone> ]
  // 	|	TIMESTAMP [ <left paren> <timestamp precision> <right paren> ] [ <with or without time zone> ]
  public static boolean datetime_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DATETIME_TYPE, "<datetime type>");
    r = consumeToken(b, DATE);
    if (!r) r = datetime_type_1(b, l + 1);
    if (!r) r = datetime_type_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // TIME [ <left paren> <time precision> <right paren> ] [ <with or without time zone> ]
  private static boolean datetime_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_type_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, TIME);
    r = r && datetime_type_1_1(b, l + 1);
    r = r && datetime_type_1_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <time precision> <right paren> ]
  private static boolean datetime_type_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_type_1_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // [ <with or without time zone> ]
  private static boolean datetime_type_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_type_1_2")) return false;
    with_or_without_time_zone(b, l + 1);
    return true;
  }

  // TIMESTAMP [ <left paren> <timestamp precision> <right paren> ] [ <with or without time zone> ]
  private static boolean datetime_type_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_type_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, TIMESTAMP);
    r = r && datetime_type_2_1(b, l + 1);
    r = r && datetime_type_2_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <timestamp precision> <right paren> ]
  private static boolean datetime_type_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_type_2_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // [ <with or without time zone> ]
  private static boolean datetime_type_2_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_type_2_2")) return false;
    with_or_without_time_zone(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean datetime_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_value")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, DATETIME_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <datetime term>
  // 	|	<interval value expression> <plus sign> <datetime term>
  // 	|	<datetime value expression> <plus sign> <interval term>
  // 	|	<datetime value expression> <minus sign> <interval term>
  public static boolean datetime_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_value_expression")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DATETIME_VALUE_EXPRESSION, "<datetime value expression>");
    r = datetime_term(b, l + 1);
    if (!r) r = interval_value_expression(b, l + 1);
    if (!r) r = datetime_value_expression(b, l + 1);
    if (!r) r = datetime_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <current date value function>
  // 	|	<current time value function>
  // 	|	<current timestamp value function>
  // 	|	<current local time value function>
  // 	|	<current local timestamp value function>
  public static boolean datetime_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "datetime_value_function")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DATETIME_VALUE_FUNCTION, "<datetime value function>");
    r = current_date_value_function(b, l + 1);
    if (!r) r = current_time_value_function(b, l + 1);
    if (!r) r = current_timestamp_value_function(b, l + 1);
    if (!r) r = current_local_time_value_function(b, l + 1);
    if (!r) r = current_local_timestamp_value_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <days value> [ <space> <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ] ]
  public static boolean day_time_interval(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "day_time_interval")) return false;
    if (!nextTokenIs(b, _DAYS_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = days_value(b, l + 1);
    r = r && day_time_interval_1(b, l + 1);
    exit_section_(b, m, DAY_TIME_INTERVAL, r);
    return r;
  }

  // [ <space> <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ] ]
  private static boolean day_time_interval_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "day_time_interval_1")) return false;
    day_time_interval_1_0(b, l + 1);
    return true;
  }

  // <space> <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ]
  private static boolean day_time_interval_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "day_time_interval_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = space(b, l + 1);
    r = r && hours_value(b, l + 1);
    r = r && day_time_interval_1_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <colon> <minutes value> [ <colon> <seconds value> ] ]
  private static boolean day_time_interval_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "day_time_interval_1_0_2")) return false;
    day_time_interval_1_0_2_0(b, l + 1);
    return true;
  }

  // <colon> <minutes value> [ <colon> <seconds value> ]
  private static boolean day_time_interval_1_0_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "day_time_interval_1_0_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = colon(b, l + 1);
    r = r && minutes_value(b, l + 1);
    r = r && day_time_interval_1_0_2_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <colon> <seconds value> ]
  private static boolean day_time_interval_1_0_2_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "day_time_interval_1_0_2_0_2")) return false;
    colon(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <day-time interval> | <time interval>
  public static boolean day_time_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "day_time_literal")) return false;
    if (!nextTokenIs(b, "<day time literal>", _DAY_TIME_INTERVAL_, _TIME_INTERVAL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DAY_TIME_LITERAL, "<day time literal>");
    r = day_time_interval(b, l + 1);
    if (!r) r = time_interval(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <datetime value>
  public static boolean days_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "days_value")) return false;
    if (!nextTokenIs(b, _DATETIME_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = datetime_value(b, l + 1);
    exit_section_(b, m, DAYS_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // DEALLOCATE [ SQL ] DESCRIPTOR <descriptor name>
  public static boolean deallocate_descriptor_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "deallocate_descriptor_statement")) return false;
    if (!nextTokenIs(b, DEALLOCATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DEALLOCATE);
    r = r && deallocate_descriptor_statement_1(b, l + 1);
    r = r && consumeTokens(b, 0, DESCRIPTOR, _DESCRIPTOR_NAME_);
    exit_section_(b, m, DEALLOCATE_DESCRIPTOR_STATEMENT, r);
    return r;
  }

  // [ SQL ]
  private static boolean deallocate_descriptor_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "deallocate_descriptor_statement_1")) return false;
    consumeToken(b, SQL);
    return true;
  }

  /* ********************************************************** */
  // DEALLOCATE PREPARE <SQL statement name>
  public static boolean deallocate_prepared_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "deallocate_prepared_statement")) return false;
    if (!nextTokenIs(b, DEALLOCATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DEALLOCATE, PREPARE, _SQL_STATEMENT_NAME_);
    exit_section_(b, m, DEALLOCATE_PREPARED_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DECLARE <cursor name> [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
  // 		[ <cursor holdability> ] [ <cursor returnability> ] FOR <cursor specification>
  public static boolean declare_cursor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "declare_cursor")) return false;
    if (!nextTokenIs(b, DECLARE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DECLARE, _CURSOR_NAME_);
    r = r && declare_cursor_2(b, l + 1);
    r = r && declare_cursor_3(b, l + 1);
    r = r && consumeToken(b, CURSOR);
    r = r && declare_cursor_5(b, l + 1);
    r = r && declare_cursor_6(b, l + 1);
    r = r && consumeTokens(b, 0, FOR, _CURSOR_SPECIFICATION_);
    exit_section_(b, m, DECLARE_CURSOR, r);
    return r;
  }

  // [ <cursor sensitivity> ]
  private static boolean declare_cursor_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "declare_cursor_2")) return false;
    cursor_sensitivity(b, l + 1);
    return true;
  }

  // [ <cursor scrollability> ]
  private static boolean declare_cursor_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "declare_cursor_3")) return false;
    cursor_scrollability(b, l + 1);
    return true;
  }

  // [ <cursor holdability> ]
  private static boolean declare_cursor_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "declare_cursor_5")) return false;
    cursor_holdability(b, l + 1);
    return true;
  }

  // [ <cursor returnability> ]
  private static boolean declare_cursor_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "declare_cursor_6")) return false;
    cursor_returnability(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // DEFAULT <default option>
  public static boolean default_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "default_clause")) return false;
    if (!nextTokenIs(b, DEFAULT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DEFAULT, _DEFAULT_OPTION_);
    exit_section_(b, m, DEFAULT_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <literal>
  // 	|	<datetime value function>
  // 	|	USER
  // 	|	CURRENT_USER
  // 	|	CURRENT_ROLE
  // 	|	SESSION_USER
  // 	|	SYSTEM_USER
  // 	|	CURRENT_PATH
  // 	|	<implicitly typed value specification>
  public static boolean default_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "default_option")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DEFAULT_OPTION, "<default option>");
    r = literal(b, l + 1);
    if (!r) r = datetime_value_function(b, l + 1);
    if (!r) r = consumeToken(b, USER);
    if (!r) r = consumeToken(b, CURRENT_USER);
    if (!r) r = consumeToken(b, CURRENT_ROLE);
    if (!r) r = consumeToken(b, SESSION_USER);
    if (!r) r = consumeToken(b, SYSTEM_USER);
    if (!r) r = consumeToken(b, CURRENT_PATH);
    if (!r) r = implicitly_typed_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DEFAULT
  public static boolean default_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "default_specification")) return false;
    if (!nextTokenIs(b, DEFAULT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DEFAULT);
    exit_section_(b, m, DEFAULT_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // ON DELETE <referential action>
  public static boolean delete_rule(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "delete_rule")) return false;
    if (!nextTokenIs(b, ON)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ON, DELETE, _REFERENTIAL_ACTION_);
    exit_section_(b, m, DELETE_RULE, r);
    return r;
  }

  /* ********************************************************** */
  // DELETE FROM <target table> WHERE CURRENT OF <cursor name>
  public static boolean delete_statement_positioned(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "delete_statement_positioned")) return false;
    if (!nextTokenIs(b, DELETE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DELETE, FROM, _TARGET_TABLE_, WHERE, CURRENT, OF, _CURSOR_NAME_);
    exit_section_(b, m, DELETE_STATEMENT_POSITIONED, r);
    return r;
  }

  /* ********************************************************** */
  // DELETE FROM <target table> [ WHERE <search condition> ]
  public static boolean delete_statement_searched(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "delete_statement_searched")) return false;
    if (!nextTokenIs(b, DELETE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DELETE, FROM, _TARGET_TABLE_);
    r = r && delete_statement_searched_3(b, l + 1);
    exit_section_(b, m, DELETE_STATEMENT_SEARCHED, r);
    return r;
  }

  // [ WHERE <search condition> ]
  private static boolean delete_statement_searched_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "delete_statement_searched_3")) return false;
    parseTokens(b, 0, WHERE, _SEARCH_CONDITION_);
    return true;
  }

  /* ********************************************************** */
  // <double quote> <delimited identifier body> <double quote>
  public static boolean delimited_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "delimited_identifier")) return false;
    if (!nextTokenIs(b, _DOUBLE_QUOTE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = double_quote(b, l + 1);
    r = r && delimited_identifier_body(b, l + 1);
    r = r && double_quote(b, l + 1);
    exit_section_(b, m, DELIMITED_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // <delimited identifier part>...
  public static boolean delimited_identifier_body(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "delimited_identifier_body")) return false;
    if (!nextTokenIs(b, _DELIMITED_IDENTIFIER_PART____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _DELIMITED_IDENTIFIER_PART____);
    exit_section_(b, m, DELIMITED_IDENTIFIER_BODY, r);
    return r;
  }

  /* ********************************************************** */
  // <nondoublequote character> | <doublequote symbol>
  // 		<ampersand><double quote> <Unicode delimiter body> <double quote>
  // 		<Unicode escape specifier>
  public static boolean delimited_identifier_part(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "delimited_identifier_part")) return false;
    if (!nextTokenIs(b, "<delimited identifier part>", _DOUBLEQUOTE_SYMBOL_, _NONDOUBLEQUOTE_CHARACTER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DELIMITED_IDENTIFIER_PART, "<delimited identifier part>");
    r = nondoublequote_character(b, l + 1);
    if (!r) r = doublequote_symbol(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean dependent_variable_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dependent_variable_expression")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, DEPENDENT_VARIABLE_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <reference value expression> <dereference operator> <attribute name>
  public static boolean dereference_operation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dereference_operation")) return false;
    if (!nextTokenIs(b, _REFERENCE_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = reference_value_expression(b, l + 1);
    r = r && dereference_operator(b, l + 1);
    r = r && attribute_name(b, l + 1);
    exit_section_(b, m, DEREFERENCE_OPERATION, r);
    return r;
  }

  /* ********************************************************** */
  // <right arrow>
  public static boolean dereference_operator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dereference_operator")) return false;
    if (!nextTokenIs(b, _RIGHT_ARROW_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = right_arrow(b, l + 1);
    exit_section_(b, m, DEREFERENCE_OPERATOR, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression> [ <as clause> ]
  public static boolean derived_column(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "derived_column")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    r = r && derived_column_1(b, l + 1);
    exit_section_(b, m, DERIVED_COLUMN, r);
    return r;
  }

  // [ <as clause> ]
  private static boolean derived_column_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "derived_column_1")) return false;
    as_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean derived_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "derived_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, DERIVED_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // REF FROM <list of attributes>
  public static boolean derived_representation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "derived_representation")) return false;
    if (!nextTokenIs(b, REF)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, REF, FROM, _LIST_OF_ATTRIBUTES_);
    exit_section_(b, m, DERIVED_REPRESENTATION, r);
    return r;
  }

  /* ********************************************************** */
  // <table subquery>
  public static boolean derived_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "derived_table")) return false;
    if (!nextTokenIs(b, _TABLE_SUBQUERY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_subquery(b, l + 1);
    exit_section_(b, m, DERIVED_TABLE, r);
    return r;
  }

  /* ********************************************************** */
  // DESCRIBE INPUT <SQL statement name> <using descriptor> [ <nesting option> ]
  public static boolean describe_input_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "describe_input_statement")) return false;
    if (!nextTokenIs(b, DESCRIBE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DESCRIBE, INPUT, _SQL_STATEMENT_NAME_, _USING_DESCRIPTOR_);
    r = r && describe_input_statement_4(b, l + 1);
    exit_section_(b, m, DESCRIBE_INPUT_STATEMENT, r);
    return r;
  }

  // [ <nesting option> ]
  private static boolean describe_input_statement_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "describe_input_statement_4")) return false;
    nesting_option(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // DESCRIBE [ OUTPUT ] <described object> <using descriptor> [ <nesting option> ]
  public static boolean describe_output_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "describe_output_statement")) return false;
    if (!nextTokenIs(b, DESCRIBE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DESCRIBE);
    r = r && describe_output_statement_1(b, l + 1);
    r = r && described_object(b, l + 1);
    r = r && using_descriptor(b, l + 1);
    r = r && describe_output_statement_4(b, l + 1);
    exit_section_(b, m, DESCRIBE_OUTPUT_STATEMENT, r);
    return r;
  }

  // [ OUTPUT ]
  private static boolean describe_output_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "describe_output_statement_1")) return false;
    consumeToken(b, OUTPUT);
    return true;
  }

  // [ <nesting option> ]
  private static boolean describe_output_statement_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "describe_output_statement_4")) return false;
    nesting_option(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <describe input statement> | <describe output statement>
  public static boolean describe_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "describe_statement")) return false;
    if (!nextTokenIs(b, "<describe statement>", _DESCRIBE_INPUT_STATEMENT_, _DESCRIBE_OUTPUT_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DESCRIBE_STATEMENT, "<describe statement>");
    r = describe_input_statement(b, l + 1);
    if (!r) r = describe_output_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL statement name>
  // 	|	CURSOR <extended cursor name> STRUCTURE
  public static boolean described_object(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "described_object")) return false;
    if (!nextTokenIs(b, "<described object>", CURSOR, _SQL_STATEMENT_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DESCRIBED_OBJECT, "<described object>");
    r = SQL_statement_name(b, l + 1);
    if (!r) r = parseTokens(b, 0, CURSOR, _EXTENDED_CURSOR_NAME_, STRUCTURE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CARDINALITY
  // 	|	CHARACTER_SET_CATALOG
  // 	|	CHARACTER_SET_NAME
  // 	|	CHARACTER_SET_SCHEMA
  // 	|	COLLATION_CATALOG
  // 	|	COLLATION_NAME
  // 	|	COLLATION_SCHEMA
  // 	|	DATA
  // 	|	DATETIME_INTERVAL_CODE
  // 	|	DATETIME_INTERVAL_PRECISION
  // 	|	DEGREE
  // 	|	INDICATOR
  // 	|	KEY_MEMBER
  // 	|	LENGTH
  // 	|	LEVEL
  // 	|	NAME
  // 	|	NULLABLE
  // 	|	OCTET_LENGTH
  // 	|	PARAMETER_MODE
  // 	|	PARAMETER_ORDINAL_POSITION
  // 	|	PARAMETER_SPECIFIC_CATALOG
  // 	|	PARAMETER_SPECIFIC_NAME
  // 	|	PARAMETER_SPECIFIC_SCHEMA
  // 	|	PRECISION
  // 	|	RETURNED_CARDINALITY
  // 	|	RETURNED_LENGTH
  // 	|	RETURNED_OCTET_LENGTH
  // 	|	SCALE
  // 	|	SCOPE_CATALOG
  // 	|	SCOPE_NAME
  // 	|	SCOPE_SCHEMA
  // 	|	TYPE
  // 	|	UNNAMED
  // 	|	USER_DEFINED_TYPE_CATALOG
  // 	|	USER_DEFINED_TYPE_NAME
  // 	|	USER_DEFINED_TYPE_SCHEMA
  // 	|	USER_DEFINED_TYPE_CODE
  public static boolean descriptor_item_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "descriptor_item_name")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DESCRIPTOR_ITEM_NAME, "<descriptor item name>");
    r = consumeToken(b, CARDINALITY);
    if (!r) r = consumeToken(b, CHARACTER_SET_CATALOG);
    if (!r) r = consumeToken(b, CHARACTER_SET_NAME);
    if (!r) r = consumeToken(b, CHARACTER_SET_SCHEMA);
    if (!r) r = consumeToken(b, COLLATION_CATALOG);
    if (!r) r = consumeToken(b, COLLATION_NAME);
    if (!r) r = consumeToken(b, COLLATION_SCHEMA);
    if (!r) r = consumeToken(b, DATA);
    if (!r) r = consumeToken(b, DATETIME_INTERVAL_CODE);
    if (!r) r = consumeToken(b, DATETIME_INTERVAL_PRECISION);
    if (!r) r = consumeToken(b, DEGREE);
    if (!r) r = consumeToken(b, INDICATOR);
    if (!r) r = consumeToken(b, KEY_MEMBER);
    if (!r) r = consumeToken(b, LENGTH);
    if (!r) r = consumeToken(b, LEVEL);
    if (!r) r = consumeToken(b, NAME);
    if (!r) r = consumeToken(b, NULLABLE);
    if (!r) r = consumeToken(b, OCTET_LENGTH);
    if (!r) r = consumeToken(b, PARAMETER_MODE);
    if (!r) r = consumeToken(b, PARAMETER_ORDINAL_POSITION);
    if (!r) r = consumeToken(b, PARAMETER_SPECIFIC_CATALOG);
    if (!r) r = consumeToken(b, PARAMETER_SPECIFIC_NAME);
    if (!r) r = consumeToken(b, PARAMETER_SPECIFIC_SCHEMA);
    if (!r) r = consumeToken(b, PRECISION);
    if (!r) r = consumeToken(b, RETURNED_CARDINALITY);
    if (!r) r = consumeToken(b, RETURNED_LENGTH);
    if (!r) r = consumeToken(b, RETURNED_OCTET_LENGTH);
    if (!r) r = consumeToken(b, SCALE);
    if (!r) r = consumeToken(b, SCOPE_CATALOG);
    if (!r) r = consumeToken(b, SCOPE_NAME);
    if (!r) r = consumeToken(b, SCOPE_SCHEMA);
    if (!r) r = consumeToken(b, TYPE);
    if (!r) r = consumeToken(b, UNNAMED);
    if (!r) r = consumeToken(b, USER_DEFINED_TYPE_CATALOG);
    if (!r) r = consumeToken(b, USER_DEFINED_TYPE_NAME);
    if (!r) r = consumeToken(b, USER_DEFINED_TYPE_SCHEMA);
    if (!r) r = consumeToken(b, USER_DEFINED_TYPE_CODE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <scope option> ] <simple value specification>
  public static boolean descriptor_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "descriptor_name")) return false;
    if (!nextTokenIs(b, "<descriptor name>", _SCOPE_OPTION_, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DESCRIPTOR_NAME, "<descriptor name>");
    r = descriptor_name_0(b, l + 1);
    r = r && simple_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <scope option> ]
  private static boolean descriptor_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "descriptor_name_0")) return false;
    scope_option(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // DETERMINISTIC | NOT DETERMINISTIC
  public static boolean deterministic_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "deterministic_characteristic")) return false;
    if (!nextTokenIs(b, "<deterministic characteristic>", DETERMINISTIC, NOT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DETERMINISTIC_CHARACTERISTIC, "<deterministic characteristic>");
    r = consumeToken(b, DETERMINISTIC);
    if (!r) r = parseTokens(b, 0, NOT, DETERMINISTIC);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DIAGNOSTICS SIZE <number of conditions>
  public static boolean diagnostics_size(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "diagnostics_size")) return false;
    if (!nextTokenIs(b, DIAGNOSTICS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DIAGNOSTICS, SIZE, _NUMBER_OF_CONDITIONS_);
    exit_section_(b, m, DIAGNOSTICS_SIZE, r);
    return r;
  }

  /* ********************************************************** */
  // 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
  public static boolean digit(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "digit")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DIGIT, "<digit>");
    r = consumeToken(b, "0");
    if (!r) r = consumeToken(b, "1");
    if (!r) r = consumeToken(b, "2");
    if (!r) r = consumeToken(b, "3");
    if (!r) r = consumeToken(b, "4");
    if (!r) r = consumeToken(b, "5");
    if (!r) r = consumeToken(b, "6");
    if (!r) r = consumeToken(b, "7");
    if (!r) r = consumeToken(b, "8");
    if (!r) r = consumeToken(b, "9");
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <delete statement searched>
  // 	|	<direct select statement multiple rows>
  // 	|	<insert statement>
  // 	|	<update statement searched>
  // 	|	<merge statement>
  // 	|	<temporary table declaration>
  public static boolean direct_SQL_data_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "direct_SQL_data_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DIRECT_SQL_DATA_STATEMENT, "<direct sql data statement>");
    r = delete_statement_searched(b, l + 1);
    if (!r) r = direct_select_statement_multiple_rows(b, l + 1);
    if (!r) r = insert_statement(b, l + 1);
    if (!r) r = update_statement_searched(b, l + 1);
    if (!r) r = merge_statement(b, l + 1);
    if (!r) r = temporary_table_declaration(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <directly executable statement> <semicolon>
  public static boolean direct_SQL_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "direct_SQL_statement")) return false;
    if (!nextTokenIs(b, _DIRECTLY_EXECUTABLE_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = directly_executable_statement(b, l + 1);
    r = r && semicolon(b, l + 1);
    exit_section_(b, m, DIRECT_SQL_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean direct_implementation_defined_statement(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, DIRECT_IMPLEMENTATION_DEFINED_STATEMENT, true);
    return true;
  }

  /* ********************************************************** */
  // <value expression primary> <period> <method name> [ <SQL argument list> ]
  public static boolean direct_invocation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "direct_invocation")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    r = r && period(b, l + 1);
    r = r && method_name(b, l + 1);
    r = r && direct_invocation_3(b, l + 1);
    exit_section_(b, m, DIRECT_INVOCATION, r);
    return r;
  }

  // [ <SQL argument list> ]
  private static boolean direct_invocation_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "direct_invocation_3")) return false;
    SQL_argument_list(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <cursor specification>
  public static boolean direct_select_statement_multiple_rows(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "direct_select_statement_multiple_rows")) return false;
    if (!nextTokenIs(b, _CURSOR_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = cursor_specification(b, l + 1);
    exit_section_(b, m, DIRECT_SELECT_STATEMENT_MULTIPLE_ROWS, r);
    return r;
  }

  /* ********************************************************** */
  // <direct SQL data statement>
  // 	|	<SQL schema statement>
  // 	|	<SQL transaction statement>
  // 	|	<SQL connection statement>
  // 	|	<SQL session statement>
  // 	|	<direct implementation-defined statement>
  public static boolean directly_executable_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "directly_executable_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DIRECTLY_EXECUTABLE_STATEMENT, "<directly executable statement>");
    r = direct_SQL_data_statement(b, l + 1);
    if (!r) r = SQL_schema_statement(b, l + 1);
    if (!r) r = SQL_transaction_statement(b, l + 1);
    if (!r) r = SQL_connection_statement(b, l + 1);
    if (!r) r = SQL_session_statement(b, l + 1);
    if (!r) r = direct_implementation_defined_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <connection object> | ALL |	CURRENT
  public static boolean disconnect_object(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "disconnect_object")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DISCONNECT_OBJECT, "<disconnect object>");
    r = connection_object(b, l + 1);
    if (!r) r = consumeToken(b, ALL);
    if (!r) r = consumeToken(b, CURRENT);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DISCONNECT <disconnect object>
  public static boolean disconnect_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "disconnect_statement")) return false;
    if (!nextTokenIs(b, DISCONNECT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DISCONNECT, _DISCONNECT_OBJECT_);
    exit_section_(b, m, DISCONNECT_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // STATIC DISPATCH
  public static boolean dispatch_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dispatch_clause")) return false;
    if (!nextTokenIs(b, STATIC)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STATIC, DISPATCH);
    exit_section_(b, m, DISPATCH_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand 3> <distinct predicate part 2>
  public static boolean distinct_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "distinct_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_3_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand_3(b, l + 1);
    r = r && distinct_predicate_part_2(b, l + 1);
    exit_section_(b, m, DISTINCT_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // IS DISTINCT FROM <row value predicand 4>
  public static boolean distinct_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "distinct_predicate_part_2")) return false;
    if (!nextTokenIs(b, IS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, IS, DISTINCT, FROM, _ROW_VALUE_PREDICAND_4_);
    exit_section_(b, m, DISTINCT_PREDICATE_PART_2, r);
    return r;
  }

  /* ********************************************************** */
  // [ <constraint name definition> ] <check constraint definition> [ <constraint characteristics> ]
  public static boolean domain_constraint(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_constraint")) return false;
    if (!nextTokenIs(b, "<domain constraint>", _CHECK_CONSTRAINT_DEFINITION_, _CONSTRAINT_NAME_DEFINITION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DOMAIN_CONSTRAINT, "<domain constraint>");
    r = domain_constraint_0(b, l + 1);
    r = r && check_constraint_definition(b, l + 1);
    r = r && domain_constraint_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <constraint name definition> ]
  private static boolean domain_constraint_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_constraint_0")) return false;
    constraint_name_definition(b, l + 1);
    return true;
  }

  // [ <constraint characteristics> ]
  private static boolean domain_constraint_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_constraint_2")) return false;
    constraint_characteristics(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // CREATE DOMAIN <domain name> [ AS ] <data type>
  // 		[ <default clause> ] [ <domain constraint>... ] [ <collate clause> ]
  public static boolean domain_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, DOMAIN, _DOMAIN_NAME_);
    r = r && domain_definition_3(b, l + 1);
    r = r && data_type(b, l + 1);
    r = r && domain_definition_5(b, l + 1);
    r = r && domain_definition_6(b, l + 1);
    r = r && domain_definition_7(b, l + 1);
    exit_section_(b, m, DOMAIN_DEFINITION, r);
    return r;
  }

  // [ AS ]
  private static boolean domain_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_definition_3")) return false;
    consumeToken(b, AS);
    return true;
  }

  // [ <default clause> ]
  private static boolean domain_definition_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_definition_5")) return false;
    default_clause(b, l + 1);
    return true;
  }

  // [ <domain constraint>... ]
  private static boolean domain_definition_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_definition_6")) return false;
    consumeToken(b, _DOMAIN_CONSTRAINT____);
    return true;
  }

  // [ <collate clause> ]
  private static boolean domain_definition_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_definition_7")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean domain_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "domain_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, DOMAIN_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <colon> <colon>
  public static boolean double_colon(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "double_colon")) return false;
    if (!nextTokenIs(b, _COLON_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = colon(b, l + 1);
    r = r && colon(b, l + 1);
    exit_section_(b, m, DOUBLE_COLON, r);
    return r;
  }

  /* ********************************************************** */
  // <period> <period>
  public static boolean double_period(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "double_period")) return false;
    if (!nextTokenIs(b, _PERIOD_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = period(b, l + 1);
    r = r && period(b, l + 1);
    exit_section_(b, m, DOUBLE_PERIOD, r);
    return r;
  }

  /* ********************************************************** */
  // "
  public static boolean double_quote(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, DOUBLE_QUOTE, true);
    return true;
  }

  /* ********************************************************** */
  // <double quote> <double quote>
  // 		<character string literal>
  // 	|	<date string>
  // 	|	<time string>
  // 	|	<timestamp string>
  // 	|	<interval string>
  // 	|	<delimited identifier>
  // 	|	<Unicode delimited identifier>
  // 	|	<SQL special character>
  // 	|	<not equals operator>
  // 	|	<greater than or equals operator>
  // 	|	<less than or equals operator>
  // 	|	<concatenation operator>
  // 	|	<right arrow>
  // 	|	<left bracket trigraph>
  // 	|	<right bracket trigraph>
  // 	|	<double colon>
  // 	|	<double period>
  public static boolean doublequote_symbol(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "doublequote_symbol")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DOUBLEQUOTE_SYMBOL, "<doublequote symbol>");
    r = double_quote(b, l + 1);
    if (!r) r = date_string(b, l + 1);
    if (!r) r = time_string(b, l + 1);
    if (!r) r = timestamp_string(b, l + 1);
    if (!r) r = interval_string(b, l + 1);
    if (!r) r = delimited_identifier(b, l + 1);
    if (!r) r = consumeToken(b, _UNICODE_DELIMITED_IDENTIFIER_);
    if (!r) r = SQL_special_character(b, l + 1);
    if (!r) r = not_equals_operator(b, l + 1);
    if (!r) r = greater_than_or_equals_operator(b, l + 1);
    if (!r) r = less_than_or_equals_operator(b, l + 1);
    if (!r) r = concatenation_operator(b, l + 1);
    if (!r) r = right_arrow(b, l + 1);
    if (!r) r = left_bracket_trigraph(b, l + 1);
    if (!r) r = consumeToken(b, _RIGHT_BRACKET_TRIGRAPH_);
    if (!r) r = double_colon(b, l + 1);
    if (!r) r = double_period(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DROP ASSERTION <constraint name>
  public static boolean drop_assertion_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_assertion_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, ASSERTION, _CONSTRAINT_NAME_);
    exit_section_(b, m, DROP_ASSERTION_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP ATTRIBUTE <attribute name> RESTRICT
  public static boolean drop_attribute_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_attribute_definition")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, ATTRIBUTE, _ATTRIBUTE_NAME_, RESTRICT);
    exit_section_(b, m, DROP_ATTRIBUTE_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // CASCADE | RESTRICT
  public static boolean drop_behavior(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_behavior")) return false;
    if (!nextTokenIs(b, "<drop behavior>", CASCADE, RESTRICT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DROP_BEHAVIOR, "<drop behavior>");
    r = consumeToken(b, CASCADE);
    if (!r) r = consumeToken(b, RESTRICT);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DROP CHARACTER SET <character set name>
  public static boolean drop_character_set_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_character_set_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, CHARACTER, SET, _CHARACTER_SET_NAME_);
    exit_section_(b, m, DROP_CHARACTER_SET_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP COLLATION <collation name> <drop behavior>
  public static boolean drop_collation_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_collation_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, COLLATION, _COLLATION_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_COLLATION_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP DEFAULT
  public static boolean drop_column_default_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_column_default_clause")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, DEFAULT);
    exit_section_(b, m, DROP_COLUMN_DEFAULT_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // DROP [ COLUMN ] <column name> <drop behavior>
  public static boolean drop_column_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_column_definition")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DROP);
    r = r && drop_column_definition_1(b, l + 1);
    r = r && column_name(b, l + 1);
    r = r && drop_behavior(b, l + 1);
    exit_section_(b, m, DROP_COLUMN_DEFINITION, r);
    return r;
  }

  // [ COLUMN ]
  private static boolean drop_column_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_column_definition_1")) return false;
    consumeToken(b, COLUMN);
    return true;
  }

  /* ********************************************************** */
  // DROP SCOPE <drop behavior>
  public static boolean drop_column_scope_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_column_scope_clause")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, SCOPE, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_COLUMN_SCOPE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // DROP TYPE <schema-resolved user-defined type name> <drop behavior>
  public static boolean drop_data_type_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_data_type_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, TYPE, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_DATA_TYPE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP CONSTRAINT <constraint name>
  public static boolean drop_domain_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_domain_constraint_definition")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, CONSTRAINT, _CONSTRAINT_NAME_);
    exit_section_(b, m, DROP_DOMAIN_CONSTRAINT_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // DROP DEFAULT
  public static boolean drop_domain_default_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_domain_default_clause")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, DEFAULT);
    exit_section_(b, m, DROP_DOMAIN_DEFAULT_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // DROP DOMAIN <domain name> <drop behavior>
  public static boolean drop_domain_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_domain_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, DOMAIN, _DOMAIN_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_DOMAIN_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP <specific method specification designator> RESTRICT
  public static boolean drop_method_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_method_specification")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, _SPECIFIC_METHOD_SPECIFICATION_DESIGNATOR_, RESTRICT);
    exit_section_(b, m, DROP_METHOD_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // DROP ROLE <role name>
  public static boolean drop_role_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_role_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, ROLE, _ROLE_NAME_);
    exit_section_(b, m, DROP_ROLE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP <specific routine designator> <drop behavior>
  public static boolean drop_routine_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_routine_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, _SPECIFIC_ROUTINE_DESIGNATOR_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_ROUTINE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP SCHEMA <schema name> <drop behavior>
  public static boolean drop_schema_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_schema_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, SCHEMA, _SCHEMA_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_SCHEMA_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP SEQUENCE <sequence generator name> <drop behavior>
  public static boolean drop_sequence_generator_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_sequence_generator_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, SEQUENCE, _SEQUENCE_GENERATOR_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_SEQUENCE_GENERATOR_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP CONSTRAINT <constraint name> <drop behavior>
  public static boolean drop_table_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_table_constraint_definition")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, CONSTRAINT, _CONSTRAINT_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_TABLE_CONSTRAINT_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // DROP TABLE <table name> <drop behavior>
  public static boolean drop_table_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_table_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, TABLE, _TABLE_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_TABLE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP <left paren> <transform kind> [ <comma> <transform kind> ] <drop behavior> <right paren>
  public static boolean drop_transform_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_transform_element_list")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, _LEFT_PAREN_, _TRANSFORM_KIND_);
    r = r && drop_transform_element_list_3(b, l + 1);
    r = r && drop_behavior(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, DROP_TRANSFORM_ELEMENT_LIST, r);
    return r;
  }

  // [ <comma> <transform kind> ]
  private static boolean drop_transform_element_list_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_transform_element_list_3")) return false;
    comma(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // DROP { TRANSFORM | TRANSFORMS } <transforms to be dropped> FOR <schema-resolved user-defined type name> <drop behavior>
  public static boolean drop_transform_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_transform_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DROP);
    r = r && drop_transform_statement_1(b, l + 1);
    r = r && transforms_to_be_dropped(b, l + 1);
    r = r && consumeTokens(b, 0, FOR, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_TRANSFORM_STATEMENT, r);
    return r;
  }

  // TRANSFORM | TRANSFORMS
  private static boolean drop_transform_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_transform_statement_1")) return false;
    boolean r;
    r = consumeToken(b, TRANSFORM);
    if (!r) r = consumeToken(b, TRANSFORMS);
    return r;
  }

  /* ********************************************************** */
  // DROP TRANSLATION <transliteration name>
  public static boolean drop_transliteration_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_transliteration_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, TRANSLATION, _TRANSLITERATION_NAME_);
    exit_section_(b, m, DROP_TRANSLITERATION_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP TRIGGER <trigger name>
  public static boolean drop_trigger_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_trigger_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, TRIGGER, _TRIGGER_NAME_);
    exit_section_(b, m, DROP_TRIGGER_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP CAST <left paren> <source data type> AS <target data type> <right paren> <drop behavior>
  public static boolean drop_user_defined_cast_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_user_defined_cast_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, CAST, _LEFT_PAREN_, _SOURCE_DATA_TYPE_, AS, _TARGET_DATA_TYPE_, _RIGHT_PAREN_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_USER_DEFINED_CAST_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP ORDERING FOR <schema-resolved user-defined type name> <drop behavior>
  public static boolean drop_user_defined_ordering_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_user_defined_ordering_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, ORDERING, FOR, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_USER_DEFINED_ORDERING_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DROP VIEW <table name> <drop behavior>
  public static boolean drop_view_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "drop_view_statement")) return false;
    if (!nextTokenIs(b, DROP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DROP, VIEW, _TABLE_NAME_, _DROP_BEHAVIOR_);
    exit_section_(b, m, DROP_VIEW_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // CLOSE <dynamic cursor name>
  public static boolean dynamic_close_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_close_statement")) return false;
    if (!nextTokenIs(b, CLOSE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CLOSE, _DYNAMIC_CURSOR_NAME_);
    exit_section_(b, m, DYNAMIC_CLOSE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <cursor name> | <extended cursor name>
  public static boolean dynamic_cursor_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_cursor_name")) return false;
    if (!nextTokenIs(b, "<dynamic cursor name>", _CURSOR_NAME_, _EXTENDED_CURSOR_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, DYNAMIC_CURSOR_NAME, "<dynamic cursor name>");
    r = cursor_name(b, l + 1);
    if (!r) r = extended_cursor_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DECLARE <cursor name> [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
  // 		[ <cursor holdability> ] [ <cursor returnability> ] FOR <statement name>
  public static boolean dynamic_declare_cursor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_declare_cursor")) return false;
    if (!nextTokenIs(b, DECLARE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DECLARE, _CURSOR_NAME_);
    r = r && dynamic_declare_cursor_2(b, l + 1);
    r = r && dynamic_declare_cursor_3(b, l + 1);
    r = r && consumeToken(b, CURSOR);
    r = r && dynamic_declare_cursor_5(b, l + 1);
    r = r && dynamic_declare_cursor_6(b, l + 1);
    r = r && consumeTokens(b, 0, FOR, _STATEMENT_NAME_);
    exit_section_(b, m, DYNAMIC_DECLARE_CURSOR, r);
    return r;
  }

  // [ <cursor sensitivity> ]
  private static boolean dynamic_declare_cursor_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_declare_cursor_2")) return false;
    cursor_sensitivity(b, l + 1);
    return true;
  }

  // [ <cursor scrollability> ]
  private static boolean dynamic_declare_cursor_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_declare_cursor_3")) return false;
    cursor_scrollability(b, l + 1);
    return true;
  }

  // [ <cursor holdability> ]
  private static boolean dynamic_declare_cursor_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_declare_cursor_5")) return false;
    cursor_holdability(b, l + 1);
    return true;
  }

  // [ <cursor returnability> ]
  private static boolean dynamic_declare_cursor_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_declare_cursor_6")) return false;
    cursor_returnability(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // DELETE FROM <target table> WHERE CURRENT OF <dynamic cursor name>
  public static boolean dynamic_delete_statement_positioned(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_delete_statement_positioned")) return false;
    if (!nextTokenIs(b, DELETE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DELETE, FROM, _TARGET_TABLE_, WHERE, CURRENT, OF, _DYNAMIC_CURSOR_NAME_);
    exit_section_(b, m, DYNAMIC_DELETE_STATEMENT_POSITIONED, r);
    return r;
  }

  /* ********************************************************** */
  // FETCH [ [ <fetch orientation> ] FROM ] <dynamic cursor name> <output using clause>
  public static boolean dynamic_fetch_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_fetch_statement")) return false;
    if (!nextTokenIs(b, FETCH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, FETCH);
    r = r && dynamic_fetch_statement_1(b, l + 1);
    r = r && dynamic_cursor_name(b, l + 1);
    r = r && output_using_clause(b, l + 1);
    exit_section_(b, m, DYNAMIC_FETCH_STATEMENT, r);
    return r;
  }

  // [ [ <fetch orientation> ] FROM ]
  private static boolean dynamic_fetch_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_fetch_statement_1")) return false;
    dynamic_fetch_statement_1_0(b, l + 1);
    return true;
  }

  // [ <fetch orientation> ] FROM
  private static boolean dynamic_fetch_statement_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_fetch_statement_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = dynamic_fetch_statement_1_0_0(b, l + 1);
    r = r && consumeToken(b, FROM);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <fetch orientation> ]
  private static boolean dynamic_fetch_statement_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_fetch_statement_1_0_0")) return false;
    fetch_orientation(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // OPEN <dynamic cursor name> [ <input using clause> ]
  public static boolean dynamic_open_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_open_statement")) return false;
    if (!nextTokenIs(b, OPEN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OPEN, _DYNAMIC_CURSOR_NAME_);
    r = r && dynamic_open_statement_2(b, l + 1);
    exit_section_(b, m, DYNAMIC_OPEN_STATEMENT, r);
    return r;
  }

  // [ <input using clause> ]
  private static boolean dynamic_open_statement_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_open_statement_2")) return false;
    input_using_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <question mark>
  public static boolean dynamic_parameter_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_parameter_specification")) return false;
    if (!nextTokenIs(b, _QUESTION_MARK_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = question_mark(b, l + 1);
    exit_section_(b, m, DYNAMIC_PARAMETER_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // DYNAMIC RESULT SETS <maximum dynamic result sets>
  public static boolean dynamic_result_sets_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_result_sets_characteristic")) return false;
    if (!nextTokenIs(b, DYNAMIC)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DYNAMIC, RESULT, SETS, _MAXIMUM_DYNAMIC_RESULT_SETS_);
    exit_section_(b, m, DYNAMIC_RESULT_SETS_CHARACTERISTIC, r);
    return r;
  }

  /* ********************************************************** */
  // <cursor specification>
  public static boolean dynamic_select_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_select_statement")) return false;
    if (!nextTokenIs(b, _CURSOR_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = cursor_specification(b, l + 1);
    exit_section_(b, m, DYNAMIC_SELECT_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <query specification>
  public static boolean dynamic_single_row_select_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_single_row_select_statement")) return false;
    if (!nextTokenIs(b, _QUERY_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = query_specification(b, l + 1);
    exit_section_(b, m, DYNAMIC_SINGLE_ROW_SELECT_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // UPDATE <target table> SET <set clause list> WHERE CURRENT OF <dynamic cursor name>
  public static boolean dynamic_update_statement_positioned(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "dynamic_update_statement_positioned")) return false;
    if (!nextTokenIs(b, UPDATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UPDATE, _TARGET_TABLE_, SET, _SET_CLAUSE_LIST_, WHERE, CURRENT, OF, _DYNAMIC_CURSOR_NAME_);
    exit_section_(b, m, DYNAMIC_UPDATE_STATEMENT_POSITIONED, r);
    return r;
  }

  /* ********************************************************** */
  // ELSE <result>
  public static boolean else_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "else_clause")) return false;
    if (!nextTokenIs(b, ELSE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ELSE, _RESULT_);
    exit_section_(b, m, ELSE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean embedded_SQL_Ada_program(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, EMBEDDED_SQL_ADA_PROGRAM, true);
    return true;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean embedded_SQL_C_program(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, EMBEDDED_SQL_C_PROGRAM, true);
    return true;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean embedded_SQL_COBOL_program(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, EMBEDDED_SQL_COBOL_PROGRAM, true);
    return true;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean embedded_SQL_Fortran_program(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, EMBEDDED_SQL_FORTRAN_PROGRAM, true);
    return true;
  }

  /* ********************************************************** */
  // <SQL prefix> BEGIN DECLARE SECTION [ <embedded character set declaration> ]
  // 		[ <host variable definition>... ] END DECLARE SECTION <SQL terminator>
  public static boolean embedded_SQL_MUMPS_declare(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_MUMPS_declare")) return false;
    if (!nextTokenIs(b, _SQL_PREFIX_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_prefix(b, l + 1);
    r = r && consumeTokens(b, 0, BEGIN, DECLARE, SECTION);
    r = r && embedded_SQL_MUMPS_declare_4(b, l + 1);
    r = r && embedded_SQL_MUMPS_declare_5(b, l + 1);
    r = r && consumeTokens(b, 0, END, DECLARE, SECTION, _SQL_TERMINATOR_);
    exit_section_(b, m, EMBEDDED_SQL_MUMPS_DECLARE, r);
    return r;
  }

  // [ <embedded character set declaration> ]
  private static boolean embedded_SQL_MUMPS_declare_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_MUMPS_declare_4")) return false;
    embedded_character_set_declaration(b, l + 1);
    return true;
  }

  // [ <host variable definition>... ]
  private static boolean embedded_SQL_MUMPS_declare_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_MUMPS_declare_5")) return false;
    consumeToken(b, _HOST_VARIABLE_DEFINITION____);
    return true;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean embedded_SQL_MUMPS_program(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, EMBEDDED_SQL_MUMPS_PROGRAM, true);
    return true;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean embedded_SQL_PL_I_program(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, EMBEDDED_SQL_PL_I_PROGRAM, true);
    return true;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean embedded_SQL_Pascal_program(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, EMBEDDED_SQL_PASCAL_PROGRAM, true);
    return true;
  }

  /* ********************************************************** */
  // <SQL prefix> BEGIN DECLARE SECTION [ <SQL terminator> ]
  public static boolean embedded_SQL_begin_declare(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_begin_declare")) return false;
    if (!nextTokenIs(b, _SQL_PREFIX_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_prefix(b, l + 1);
    r = r && consumeTokens(b, 0, BEGIN, DECLARE, SECTION);
    r = r && embedded_SQL_begin_declare_4(b, l + 1);
    exit_section_(b, m, EMBEDDED_SQL_BEGIN_DECLARE, r);
    return r;
  }

  // [ <SQL terminator> ]
  private static boolean embedded_SQL_begin_declare_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_begin_declare_4")) return false;
    SQL_terminator(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <embedded SQL begin declare> [ <embedded character set declaration> ] [ <host variable definition>... ] <embedded SQL end declare>
  // 	|	<embedded SQL MUMPS declare>
  public static boolean embedded_SQL_declare_section(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_declare_section")) return false;
    if (!nextTokenIs(b, "<embedded sql declare section>", _EMBEDDED_SQL_BEGIN_DECLARE_, _EMBEDDED_SQL_MUMPS_DECLARE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EMBEDDED_SQL_DECLARE_SECTION, "<embedded sql declare section>");
    r = embedded_SQL_declare_section_0(b, l + 1);
    if (!r) r = embedded_SQL_MUMPS_declare(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <embedded SQL begin declare> [ <embedded character set declaration> ] [ <host variable definition>... ] <embedded SQL end declare>
  private static boolean embedded_SQL_declare_section_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_declare_section_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = embedded_SQL_begin_declare(b, l + 1);
    r = r && embedded_SQL_declare_section_0_1(b, l + 1);
    r = r && embedded_SQL_declare_section_0_2(b, l + 1);
    r = r && embedded_SQL_end_declare(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <embedded character set declaration> ]
  private static boolean embedded_SQL_declare_section_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_declare_section_0_1")) return false;
    embedded_character_set_declaration(b, l + 1);
    return true;
  }

  // [ <host variable definition>... ]
  private static boolean embedded_SQL_declare_section_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_declare_section_0_2")) return false;
    consumeToken(b, _HOST_VARIABLE_DEFINITION____);
    return true;
  }

  /* ********************************************************** */
  // <SQL prefix> END DECLARE SECTION [ <SQL terminator> ]
  public static boolean embedded_SQL_end_declare(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_end_declare")) return false;
    if (!nextTokenIs(b, _SQL_PREFIX_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_prefix(b, l + 1);
    r = r && consumeTokens(b, 0, END, DECLARE, SECTION);
    r = r && embedded_SQL_end_declare_4(b, l + 1);
    exit_section_(b, m, EMBEDDED_SQL_END_DECLARE, r);
    return r;
  }

  // [ <SQL terminator> ]
  private static boolean embedded_SQL_end_declare_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_end_declare_4")) return false;
    SQL_terminator(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <embedded SQL Ada program>
  // 	|	<embedded SQL C program>
  // 	|	<embedded SQL COBOL program>
  // 	|	<embedded SQL Fortran program>
  // 	|	<embedded SQL MUMPS program>
  // 	|	<embedded SQL Pascal program>
  // 	|	<embedded SQL PL/I program>
  public static boolean embedded_SQL_host_program(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_host_program")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EMBEDDED_SQL_HOST_PROGRAM, "<embedded sql host program>");
    r = embedded_SQL_Ada_program(b, l + 1);
    if (!r) r = embedded_SQL_C_program(b, l + 1);
    if (!r) r = embedded_SQL_COBOL_program(b, l + 1);
    if (!r) r = embedded_SQL_Fortran_program(b, l + 1);
    if (!r) r = embedded_SQL_MUMPS_program(b, l + 1);
    if (!r) r = embedded_SQL_Pascal_program(b, l + 1);
    if (!r) r = embedded_SQL_PL_I_program(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL prefix> <statement or declaration> [ <SQL terminator> ]
  public static boolean embedded_SQL_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_statement")) return false;
    if (!nextTokenIs(b, _SQL_PREFIX_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_prefix(b, l + 1);
    r = r && statement_or_declaration(b, l + 1);
    r = r && embedded_SQL_statement_2(b, l + 1);
    exit_section_(b, m, EMBEDDED_SQL_STATEMENT, r);
    return r;
  }

  // [ <SQL terminator> ]
  private static boolean embedded_SQL_statement_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_SQL_statement_2")) return false;
    SQL_terminator(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SCHEMA <schema name>
  // 	|	AUTHORIZATION <embedded authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
  // 	|	SCHEMA <schema name> AUTHORIZATION <embedded authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
  public static boolean embedded_authorization_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause")) return false;
    if (!nextTokenIs(b, "<embedded authorization clause>", AUTHORIZATION, SCHEMA)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EMBEDDED_AUTHORIZATION_CLAUSE, "<embedded authorization clause>");
    r = parseTokens(b, 0, SCHEMA, _SCHEMA_NAME_);
    if (!r) r = embedded_authorization_clause_1(b, l + 1);
    if (!r) r = embedded_authorization_clause_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // AUTHORIZATION <embedded authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
  private static boolean embedded_authorization_clause_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, AUTHORIZATION, _EMBEDDED_AUTHORIZATION_IDENTIFIER_);
    r = r && embedded_authorization_clause_1_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ FOR STATIC { ONLY | AND DYNAMIC } ]
  private static boolean embedded_authorization_clause_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause_1_2")) return false;
    embedded_authorization_clause_1_2_0(b, l + 1);
    return true;
  }

  // FOR STATIC { ONLY | AND DYNAMIC }
  private static boolean embedded_authorization_clause_1_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause_1_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FOR, STATIC);
    r = r && embedded_authorization_clause_1_2_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ONLY | AND DYNAMIC
  private static boolean embedded_authorization_clause_1_2_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause_1_2_0_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ONLY);
    if (!r) r = parseTokens(b, 0, AND, DYNAMIC);
    exit_section_(b, m, null, r);
    return r;
  }

  // SCHEMA <schema name> AUTHORIZATION <embedded authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
  private static boolean embedded_authorization_clause_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SCHEMA, _SCHEMA_NAME_, AUTHORIZATION, _EMBEDDED_AUTHORIZATION_IDENTIFIER_);
    r = r && embedded_authorization_clause_2_4(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ FOR STATIC { ONLY | AND DYNAMIC } ]
  private static boolean embedded_authorization_clause_2_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause_2_4")) return false;
    embedded_authorization_clause_2_4_0(b, l + 1);
    return true;
  }

  // FOR STATIC { ONLY | AND DYNAMIC }
  private static boolean embedded_authorization_clause_2_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause_2_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FOR, STATIC);
    r = r && embedded_authorization_clause_2_4_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ONLY | AND DYNAMIC
  private static boolean embedded_authorization_clause_2_4_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_clause_2_4_0_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ONLY);
    if (!r) r = parseTokens(b, 0, AND, DYNAMIC);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // DECLARE <embedded authorization clause>
  public static boolean embedded_authorization_declaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_declaration")) return false;
    if (!nextTokenIs(b, DECLARE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DECLARE, _EMBEDDED_AUTHORIZATION_CLAUSE_);
    exit_section_(b, m, EMBEDDED_AUTHORIZATION_DECLARATION, r);
    return r;
  }

  /* ********************************************************** */
  // <module authorization identifier>
  public static boolean embedded_authorization_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_authorization_identifier")) return false;
    if (!nextTokenIs(b, _MODULE_AUTHORIZATION_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = module_authorization_identifier(b, l + 1);
    exit_section_(b, m, EMBEDDED_AUTHORIZATION_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // SQL NAMES ARE <character set specification>
  public static boolean embedded_character_set_declaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_character_set_declaration")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQL, NAMES, ARE, _CHARACTER_SET_SPECIFICATION_);
    exit_section_(b, m, EMBEDDED_CHARACTER_SET_DECLARATION, r);
    return r;
  }

  /* ********************************************************** */
  // <module collations>
  public static boolean embedded_collation_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_collation_specification")) return false;
    if (!nextTokenIs(b, _MODULE_COLLATIONS_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = module_collations(b, l + 1);
    exit_section_(b, m, EMBEDDED_COLLATION_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // WHENEVER <condition> <condition action>
  public static boolean embedded_exception_declaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_exception_declaration")) return false;
    if (!nextTokenIs(b, WHENEVER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WHENEVER, _CONDITION_, _CONDITION_ACTION_);
    exit_section_(b, m, EMBEDDED_EXCEPTION_DECLARATION, r);
    return r;
  }

  /* ********************************************************** */
  // <path specification>
  public static boolean embedded_path_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_path_specification")) return false;
    if (!nextTokenIs(b, _PATH_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = path_specification(b, l + 1);
    exit_section_(b, m, EMBEDDED_PATH_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <transform group specification>
  public static boolean embedded_transform_group_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_transform_group_specification")) return false;
    if (!nextTokenIs(b, _TRANSFORM_GROUP_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = transform_group_specification(b, l + 1);
    exit_section_(b, m, EMBEDDED_TRANSFORM_GROUP_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <colon> <host identifier>
  public static boolean embedded_variable_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_variable_name")) return false;
    if (!nextTokenIs(b, _COLON_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = colon(b, l + 1);
    r = r && host_identifier(b, l + 1);
    exit_section_(b, m, EMBEDDED_VARIABLE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <embedded variable name> [ <indicator variable> ]
  public static boolean embedded_variable_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_variable_specification")) return false;
    if (!nextTokenIs(b, _EMBEDDED_VARIABLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = embedded_variable_name(b, l + 1);
    r = r && embedded_variable_specification_1(b, l + 1);
    exit_section_(b, m, EMBEDDED_VARIABLE_SPECIFICATION, r);
    return r;
  }

  // [ <indicator variable> ]
  private static boolean embedded_variable_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "embedded_variable_specification_1")) return false;
    indicator_variable(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <left paren> <right paren>
  public static boolean empty_grouping_set(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "empty_grouping_set")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, EMPTY_GROUPING_SET, r);
    return r;
  }

  /* ********************************************************** */
  // ARRAY <left bracket or trigraph> <right bracket or trigraph>
  // 	|	MULTISET <left bracket or trigraph> <right bracket or trigraph>
  public static boolean empty_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "empty_specification")) return false;
    if (!nextTokenIs(b, "<empty specification>", ARRAY, MULTISET)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EMPTY_SPECIFICATION, "<empty specification>");
    r = parseTokens(b, 0, ARRAY, _LEFT_BRACKET_OR_TRIGRAPH_, _RIGHT_BRACKET_OR_TRIGRAPH_);
    if (!r) r = parseTokens(b, 0, MULTISET, _LEFT_BRACKET_OR_TRIGRAPH_, _RIGHT_BRACKET_OR_TRIGRAPH_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <non-second primary datetime field>
  // 	|	SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]
  public static boolean end_field(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "end_field")) return false;
    if (!nextTokenIs(b, "<end field>", SECOND, _NON_SECOND_PRIMARY_DATETIME_FIELD_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, END_FIELD, "<end field>");
    r = non_second_primary_datetime_field(b, l + 1);
    if (!r) r = end_field_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]
  private static boolean end_field_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "end_field_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, SECOND);
    r = r && end_field_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <interval fractional seconds precision> <right paren> ]
  private static boolean end_field_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "end_field_1_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // =
  public static boolean equals_operator(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, EQUALS_OPERATOR, true);
    return true;
  }

  /* ********************************************************** */
  // EQUALS ONLY BY <ordering category>
  public static boolean equals_ordering_form(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "equals_ordering_form")) return false;
    if (!nextTokenIs(b, EQUALS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, EQUALS, ONLY, BY, _ORDERING_CATEGORY_);
    exit_section_(b, m, EQUALS_ORDERING_FORM, r);
    return r;
  }

  /* ********************************************************** */
  // <character value expression>
  public static boolean escape_character(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "escape_character")) return false;
    if (!nextTokenIs(b, _CHARACTER_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_value_expression(b, l + 1);
    exit_section_(b, m, ESCAPE_CHARACTER, r);
    return r;
  }

  /* ********************************************************** */
  // <blob value expression>
  public static boolean escape_octet(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "escape_octet")) return false;
    if (!nextTokenIs(b, _BLOB_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = blob_value_expression(b, l + 1);
    exit_section_(b, m, ESCAPE_OCTET, r);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean escaped_character(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, ESCAPED_CHARACTER, true);
    return true;
  }

  /* ********************************************************** */
  // <unsigned integer> [ <period> [ <unsigned integer> ] ]
  // 	|	<period> <unsigned integer>
  public static boolean exact_numeric_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_literal")) return false;
    if (!nextTokenIs(b, "<exact numeric literal>", _PERIOD_, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXACT_NUMERIC_LITERAL, "<exact numeric literal>");
    r = exact_numeric_literal_0(b, l + 1);
    if (!r) r = period(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <unsigned integer> [ <period> [ <unsigned integer> ] ]
  private static boolean exact_numeric_literal_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_literal_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    r = r && exact_numeric_literal_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <period> [ <unsigned integer> ] ]
  private static boolean exact_numeric_literal_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_literal_0_1")) return false;
    exact_numeric_literal_0_1_0(b, l + 1);
    return true;
  }

  // <period> [ <unsigned integer> ]
  private static boolean exact_numeric_literal_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_literal_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = period(b, l + 1);
    r = r && exact_numeric_literal_0_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <unsigned integer> ]
  private static boolean exact_numeric_literal_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_literal_0_1_0_1")) return false;
    unsigned_integer(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // NUMERIC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  // 	|	DECIMAL [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  // 	|	DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  // 	|	SMALLINT
  // 	|	INTEGER
  // 	|	INT
  // 	|	BIGINT
  public static boolean exact_numeric_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXACT_NUMERIC_TYPE, "<exact numeric type>");
    r = exact_numeric_type_0(b, l + 1);
    if (!r) r = exact_numeric_type_1(b, l + 1);
    if (!r) r = exact_numeric_type_2(b, l + 1);
    if (!r) r = consumeToken(b, SMALLINT);
    if (!r) r = consumeToken(b, INTEGER);
    if (!r) r = consumeToken(b, INT);
    if (!r) r = consumeToken(b, BIGINT);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // NUMERIC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  private static boolean exact_numeric_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NUMERIC);
    r = r && exact_numeric_type_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  private static boolean exact_numeric_type_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_0_1")) return false;
    exact_numeric_type_0_1_0(b, l + 1);
    return true;
  }

  // <left paren> <precision> [ <comma> <scale> ] <right paren>
  private static boolean exact_numeric_type_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && precision(b, l + 1);
    r = r && exact_numeric_type_0_1_0_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <comma> <scale> ]
  private static boolean exact_numeric_type_0_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_0_1_0_2")) return false;
    comma(b, l + 1);
    return true;
  }

  // DECIMAL [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  private static boolean exact_numeric_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DECIMAL);
    r = r && exact_numeric_type_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  private static boolean exact_numeric_type_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_1_1")) return false;
    exact_numeric_type_1_1_0(b, l + 1);
    return true;
  }

  // <left paren> <precision> [ <comma> <scale> ] <right paren>
  private static boolean exact_numeric_type_1_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_1_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && precision(b, l + 1);
    r = r && exact_numeric_type_1_1_0_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <comma> <scale> ]
  private static boolean exact_numeric_type_1_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_1_1_0_2")) return false;
    comma(b, l + 1);
    return true;
  }

  // DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  private static boolean exact_numeric_type_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DEC);
    r = r && exact_numeric_type_2_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
  private static boolean exact_numeric_type_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_2_1")) return false;
    exact_numeric_type_2_1_0(b, l + 1);
    return true;
  }

  // <left paren> <precision> [ <comma> <scale> ] <right paren>
  private static boolean exact_numeric_type_2_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_2_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && precision(b, l + 1);
    r = r && exact_numeric_type_2_1_0_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <comma> <scale> ]
  private static boolean exact_numeric_type_2_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exact_numeric_type_2_1_0_2")) return false;
    comma(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // ONLY <path-resolved user-defined type name>
  public static boolean exclusive_user_defined_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exclusive_user_defined_type_specification")) return false;
    if (!nextTokenIs(b, ONLY)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ONLY, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_);
    exit_section_(b, m, EXCLUSIVE_USER_DEFINED_TYPE_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // EXECUTE IMMEDIATE <SQL statement variable>
  public static boolean execute_immediate_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "execute_immediate_statement")) return false;
    if (!nextTokenIs(b, EXECUTE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, EXECUTE, IMMEDIATE, _SQL_STATEMENT_VARIABLE_);
    exit_section_(b, m, EXECUTE_IMMEDIATE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // EXECUTE <SQL statement name> [ <result using clause> ] [ <parameter using clause> ]
  public static boolean execute_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "execute_statement")) return false;
    if (!nextTokenIs(b, EXECUTE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, EXECUTE, _SQL_STATEMENT_NAME_);
    r = r && execute_statement_2(b, l + 1);
    r = r && execute_statement_3(b, l + 1);
    exit_section_(b, m, EXECUTE_STATEMENT, r);
    return r;
  }

  // [ <result using clause> ]
  private static boolean execute_statement_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "execute_statement_2")) return false;
    result_using_clause(b, l + 1);
    return true;
  }

  // [ <parameter using clause> ]
  private static boolean execute_statement_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "execute_statement_3")) return false;
    parameter_using_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <collation name>
  public static boolean existing_collation_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "existing_collation_name")) return false;
    if (!nextTokenIs(b, _COLLATION_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = collation_name(b, l + 1);
    exit_section_(b, m, EXISTING_COLLATION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <transliteration name>
  public static boolean existing_transliteration_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "existing_transliteration_name")) return false;
    if (!nextTokenIs(b, _TRANSLITERATION_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = transliteration_name(b, l + 1);
    exit_section_(b, m, EXISTING_TRANSLITERATION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <window name>
  public static boolean existing_window_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "existing_window_name")) return false;
    if (!nextTokenIs(b, _WINDOW_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_name(b, l + 1);
    exit_section_(b, m, EXISTING_WINDOW_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // EXISTS <table subquery>
  public static boolean exists_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exists_predicate")) return false;
    if (!nextTokenIs(b, EXISTS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, EXISTS, _TABLE_SUBQUERY_);
    exit_section_(b, m, EXISTS_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <row value constructor element> <comma> <row value constructor element list> <right paren>
  // 	|	ROW <left paren> <row value constructor element list> <right paren>
  // 	|	<row subquery>
  public static boolean explicit_row_value_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "explicit_row_value_constructor")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXPLICIT_ROW_VALUE_CONSTRUCTOR, "<explicit row value constructor>");
    r = left_paren(b, l + 1);
    if (!r) r = parseTokens(b, 0, ROW, _LEFT_PAREN_, _ROW_VALUE_CONSTRUCTOR_ELEMENT_LIST_, _RIGHT_PAREN_);
    if (!r) r = row_subquery(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // TABLE <table or query name>
  public static boolean explicit_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "explicit_table")) return false;
    if (!nextTokenIs(b, TABLE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLE, _TABLE_OR_QUERY_NAME_);
    exit_section_(b, m, EXPLICIT_TABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <signed integer>
  public static boolean exponent(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exponent")) return false;
    if (!nextTokenIs(b, _SIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = signed_integer(b, l + 1);
    exit_section_(b, m, EXPONENT, r);
    return r;
  }

  /* ********************************************************** */
  // EXP <left paren> <numeric value expression> <right paren>
  public static boolean exponential_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exponential_function")) return false;
    if (!nextTokenIs(b, EXP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, EXP, _LEFT_PAREN_, _NUMERIC_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, EXPONENTIAL_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // [ <scope option> ] <simple value specification>
  public static boolean extended_cursor_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "extended_cursor_name")) return false;
    if (!nextTokenIs(b, "<extended cursor name>", _SCOPE_OPTION_, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXTENDED_CURSOR_NAME, "<extended cursor name>");
    r = extended_cursor_name_0(b, l + 1);
    r = r && simple_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <scope option> ]
  private static boolean extended_cursor_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "extended_cursor_name_0")) return false;
    scope_option(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // [ <scope option> ] <simple value specification>
  public static boolean extended_statement_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "extended_statement_name")) return false;
    if (!nextTokenIs(b, "<extended statement name>", _SCOPE_OPTION_, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXTENDED_STATEMENT_NAME, "<extended statement name>");
    r = extended_statement_name_0(b, l + 1);
    r = r && simple_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <scope option> ]
  private static boolean extended_statement_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "extended_statement_name_0")) return false;
    scope_option(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // EXTERNAL [ NAME <external routine name> ] [ <parameter style clause> ]
  // 		[ <transform group specification> ] [ <external security clause> ]
  public static boolean external_body_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "external_body_reference")) return false;
    if (!nextTokenIs(b, EXTERNAL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, EXTERNAL);
    r = r && external_body_reference_1(b, l + 1);
    r = r && external_body_reference_2(b, l + 1);
    r = r && external_body_reference_3(b, l + 1);
    r = r && external_body_reference_4(b, l + 1);
    exit_section_(b, m, EXTERNAL_BODY_REFERENCE, r);
    return r;
  }

  // [ NAME <external routine name> ]
  private static boolean external_body_reference_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "external_body_reference_1")) return false;
    parseTokens(b, 0, NAME, _EXTERNAL_ROUTINE_NAME_);
    return true;
  }

  // [ <parameter style clause> ]
  private static boolean external_body_reference_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "external_body_reference_2")) return false;
    parameter_style_clause(b, l + 1);
    return true;
  }

  // [ <transform group specification> ]
  private static boolean external_body_reference_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "external_body_reference_3")) return false;
    transform_group_specification(b, l + 1);
    return true;
  }

  // [ <external security clause> ]
  private static boolean external_body_reference_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "external_body_reference_4")) return false;
    external_security_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <identifier> | <character string literal>
  public static boolean external_routine_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "external_routine_name")) return false;
    if (!nextTokenIs(b, "<external routine name>", _CHARACTER_STRING_LITERAL_, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXTERNAL_ROUTINE_NAME, "<external routine name>");
    r = identifier(b, l + 1);
    if (!r) r = character_string_literal(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // EXTERNAL SECURITY DEFINER
  // 	|	EXTERNAL SECURITY INVOKER
  // 	|	EXTERNAL SECURITY IMPLEMENTATION DEFINED
  public static boolean external_security_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "external_security_clause")) return false;
    if (!nextTokenIs(b, EXTERNAL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, EXTERNAL, SECURITY, DEFINER);
    if (!r) r = parseTokens(b, 0, EXTERNAL, SECURITY, INVOKER);
    if (!r) r = parseTokens(b, 0, EXTERNAL, SECURITY, IMPLEMENTATION, DEFINED);
    exit_section_(b, m, EXTERNAL_SECURITY_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // PROCEDURE <procedure name> <host parameter declaration list> <semicolon>
  // 		<SQL procedure statement> <semicolon>
  public static boolean externally_invoked_procedure(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "externally_invoked_procedure")) return false;
    if (!nextTokenIs(b, PROCEDURE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, PROCEDURE, _PROCEDURE_NAME_, _HOST_PARAMETER_DECLARATION_LIST_, _SEMICOLON_, _SQL_PROCEDURE_STATEMENT_, _SEMICOLON_);
    exit_section_(b, m, EXTERNALLY_INVOKED_PROCEDURE, r);
    return r;
  }

  /* ********************************************************** */
  // EXTRACT <left paren> <extract field> FROM <extract source> <right paren>
  public static boolean extract_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "extract_expression")) return false;
    if (!nextTokenIs(b, EXTRACT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, EXTRACT, _LEFT_PAREN_, _EXTRACT_FIELD_, FROM, _EXTRACT_SOURCE_, _RIGHT_PAREN_);
    exit_section_(b, m, EXTRACT_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <primary datetime field> | <time zone field>
  public static boolean extract_field(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "extract_field")) return false;
    if (!nextTokenIs(b, "<extract field>", _PRIMARY_DATETIME_FIELD_, _TIME_ZONE_FIELD_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXTRACT_FIELD, "<extract field>");
    r = primary_datetime_field(b, l + 1);
    if (!r) r = time_zone_field(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <datetime value expression> | <interval value expression>
  public static boolean extract_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "extract_source")) return false;
    if (!nextTokenIs(b, "<extract source>", _DATETIME_VALUE_EXPRESSION_, _INTERVAL_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXTRACT_SOURCE, "<extract source>");
    r = datetime_value_expression(b, l + 1);
    if (!r) r = interval_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <sign> ] <numeric primary>
  public static boolean factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "factor")) return false;
    if (!nextTokenIs(b, "<factor>", _NUMERIC_PRIMARY_, _SIGN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FACTOR, "<factor>");
    r = factor_0(b, l + 1);
    r = r && numeric_primary(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <sign> ]
  private static boolean factor_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "factor_0")) return false;
    sign(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // NEXT
  // 	|	PRIOR
  // 	|	FIRST
  // 	|	LAST
  // 	|	{ ABSOLUTE | RELATIVE } <simple value specification>
  public static boolean fetch_orientation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_orientation")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FETCH_ORIENTATION, "<fetch orientation>");
    r = consumeToken(b, NEXT);
    if (!r) r = consumeToken(b, PRIOR);
    if (!r) r = consumeToken(b, FIRST);
    if (!r) r = consumeToken(b, LAST);
    if (!r) r = fetch_orientation_4(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // { ABSOLUTE | RELATIVE } <simple value specification>
  private static boolean fetch_orientation_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_orientation_4")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = fetch_orientation_4_0(b, l + 1);
    r = r && simple_value_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ABSOLUTE | RELATIVE
  private static boolean fetch_orientation_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_orientation_4_0")) return false;
    boolean r;
    r = consumeToken(b, ABSOLUTE);
    if (!r) r = consumeToken(b, RELATIVE);
    return r;
  }

  /* ********************************************************** */
  // FETCH [ [ <fetch orientation> ] FROM ] <cursor name> INTO <fetch target list>
  public static boolean fetch_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_statement")) return false;
    if (!nextTokenIs(b, FETCH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, FETCH);
    r = r && fetch_statement_1(b, l + 1);
    r = r && cursor_name(b, l + 1);
    r = r && consumeTokens(b, 0, INTO, _FETCH_TARGET_LIST_);
    exit_section_(b, m, FETCH_STATEMENT, r);
    return r;
  }

  // [ [ <fetch orientation> ] FROM ]
  private static boolean fetch_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_statement_1")) return false;
    fetch_statement_1_0(b, l + 1);
    return true;
  }

  // [ <fetch orientation> ] FROM
  private static boolean fetch_statement_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_statement_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = fetch_statement_1_0_0(b, l + 1);
    r = r && consumeToken(b, FROM);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <fetch orientation> ]
  private static boolean fetch_statement_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_statement_1_0_0")) return false;
    fetch_orientation(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <target specification> [ { <comma> <target specification> }... ]
  public static boolean fetch_target_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_target_list")) return false;
    if (!nextTokenIs(b, _TARGET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = target_specification(b, l + 1);
    r = r && fetch_target_list_1(b, l + 1);
    exit_section_(b, m, FETCH_TARGET_LIST, r);
    return r;
  }

  // [ { <comma> <target specification> }... ]
  private static boolean fetch_target_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_target_list_1")) return false;
    fetch_target_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <target specification>
  private static boolean fetch_target_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fetch_target_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && target_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <field name> <data type> [ <reference scope check> ]
  public static boolean field_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "field_definition")) return false;
    if (!nextTokenIs(b, _FIELD_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = field_name(b, l + 1);
    r = r && data_type(b, l + 1);
    r = r && field_definition_2(b, l + 1);
    exit_section_(b, m, FIELD_DEFINITION, r);
    return r;
  }

  // [ <reference scope check> ]
  private static boolean field_definition_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "field_definition_2")) return false;
    reference_scope_check(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean field_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "field_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, FIELD_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary> <period> <field name>
  public static boolean field_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "field_reference")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    r = r && period(b, l + 1);
    r = r && field_name(b, l + 1);
    exit_section_(b, m, FIELD_REFERENCE, r);
    return r;
  }

  /* ********************************************************** */
  // FILTER <left paren> WHERE <search condition> <right paren>
  public static boolean filter_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "filter_clause")) return false;
    if (!nextTokenIs(b, FILTER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FILTER, _LEFT_PAREN_, WHERE, _SEARCH_CONDITION_, _RIGHT_PAREN_);
    exit_section_(b, m, FILTER_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // FINAL | NOT FINAL
  public static boolean finality(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "finality")) return false;
    if (!nextTokenIs(b, "<finality>", FINAL, NOT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FINALITY, "<finality>");
    r = consumeToken(b, FINAL);
    if (!r) r = parseTokens(b, 0, NOT, FINAL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // FLOOR <left paren> <numeric value expression> <right paren>
  public static boolean floor_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "floor_function")) return false;
    if (!nextTokenIs(b, FLOOR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FLOOR, _LEFT_PAREN_, _NUMERIC_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, FLOOR_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // { UPPER | LOWER } <left paren> <character value expression> <right paren>
  public static boolean fold(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fold")) return false;
    if (!nextTokenIs(b, "<fold>", LOWER, UPPER)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FOLD, "<fold>");
    r = fold_0(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && character_value_expression(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // UPPER | LOWER
  private static boolean fold_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "fold_0")) return false;
    boolean r;
    r = consumeToken(b, UPPER);
    if (!r) r = consumeToken(b, LOWER);
    return r;
  }

  /* ********************************************************** */
  // FREE LOCATOR <locator reference> [ { <comma> <locator reference> }... ]
  public static boolean free_locator_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "free_locator_statement")) return false;
    if (!nextTokenIs(b, FREE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FREE, LOCATOR, _LOCATOR_REFERENCE_);
    r = r && free_locator_statement_3(b, l + 1);
    exit_section_(b, m, FREE_LOCATOR_STATEMENT, r);
    return r;
  }

  // [ { <comma> <locator reference> }... ]
  private static boolean free_locator_statement_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "free_locator_statement_3")) return false;
    free_locator_statement_3_0(b, l + 1);
    return true;
  }

  // <comma> <locator reference>
  private static boolean free_locator_statement_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "free_locator_statement_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && locator_reference(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // FROM <table reference list>
  public static boolean from_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_clause")) return false;
    if (!nextTokenIs(b, FROM)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FROM, _TABLE_REFERENCE_LIST_);
    exit_section_(b, m, FROM_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // [ <left paren> <insert column list> <right paren> ] [ <override clause> ] <contextually typed table value constructor>
  public static boolean from_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_constructor")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FROM_CONSTRUCTOR, "<from constructor>");
    r = from_constructor_0(b, l + 1);
    r = r && from_constructor_1(b, l + 1);
    r = r && contextually_typed_table_value_constructor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <left paren> <insert column list> <right paren> ]
  private static boolean from_constructor_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_constructor_0")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // [ <override clause> ]
  private static boolean from_constructor_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_constructor_1")) return false;
    override_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // DEFAULT VALUES
  public static boolean from_default(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_default")) return false;
    if (!nextTokenIs(b, DEFAULT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DEFAULT, VALUES);
    exit_section_(b, m, FROM_DEFAULT, r);
    return r;
  }

  /* ********************************************************** */
  // FROM SQL WITH <from sql function>
  public static boolean from_sql(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_sql")) return false;
    if (!nextTokenIs(b, FROM)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FROM, SQL, WITH, _FROM_SQL_FUNCTION_);
    exit_section_(b, m, FROM_SQL, r);
    return r;
  }

  /* ********************************************************** */
  // <specific routine designator>
  public static boolean from_sql_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_sql_function")) return false;
    if (!nextTokenIs(b, _SPECIFIC_ROUTINE_DESIGNATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = specific_routine_designator(b, l + 1);
    exit_section_(b, m, FROM_SQL_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // [ <left paren> <insert column list> <right paren> ] [ <override clause> ] <query expression>
  public static boolean from_subquery(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_subquery")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FROM_SUBQUERY, "<from subquery>");
    r = from_subquery_0(b, l + 1);
    r = r && from_subquery_1(b, l + 1);
    r = r && query_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <left paren> <insert column list> <right paren> ]
  private static boolean from_subquery_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_subquery_0")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // [ <override clause> ]
  private static boolean from_subquery_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "from_subquery_1")) return false;
    override_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // ORDER FULL BY <ordering category>
  public static boolean full_ordering_form(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "full_ordering_form")) return false;
    if (!nextTokenIs(b, ORDER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ORDER, FULL, BY, _ORDERING_CATEGORY_);
    exit_section_(b, m, FULL_ORDERING_FORM, r);
    return r;
  }

  /* ********************************************************** */
  // FUNCTION <schema qualified routine name>
  // 		<SQL parameter declaration list> <returns clause> <routine characteristics> [ <dispatch clause> ]
  public static boolean function_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "function_specification")) return false;
    if (!nextTokenIs(b, FUNCTION)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FUNCTION, _SCHEMA_QUALIFIED_ROUTINE_NAME_, _SQL_PARAMETER_DECLARATION_LIST_, _RETURNS_CLAUSE_, _ROUTINE_CHARACTERISTICS_);
    r = r && function_specification_5(b, l + 1);
    exit_section_(b, m, FUNCTION_SPECIFICATION, r);
    return r;
  }

  // [ <dispatch clause> ]
  private static boolean function_specification_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "function_specification_5")) return false;
    dispatch_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <character string literal>
  // 	|	<national character string literal>
  // 	|	<Unicode character string literal>
  // 	|	<binary string literal>
  // 	|	<datetime literal>
  // 	|	<interval literal>
  // 	|	<boolean literal>
  public static boolean general_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "general_literal")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GENERAL_LITERAL, "<general literal>");
    r = character_string_literal(b, l + 1);
    if (!r) r = national_character_string_literal(b, l + 1);
    if (!r) r = Unicode_character_string_literal(b, l + 1);
    if (!r) r = binary_string_literal(b, l + 1);
    if (!r) r = datetime_literal(b, l + 1);
    if (!r) r = interval_literal(b, l + 1);
    if (!r) r = boolean_literal(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <set function type> <left paren> [ <set quantifier> ] <value expression> <right paren>
  public static boolean general_set_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "general_set_function")) return false;
    if (!nextTokenIs(b, _SET_FUNCTION_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = set_function_type(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && general_set_function_2(b, l + 1);
    r = r && value_expression(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, GENERAL_SET_FUNCTION, r);
    return r;
  }

  // [ <set quantifier> ]
  private static boolean general_set_function_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "general_set_function_2")) return false;
    set_quantifier(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <host parameter specification>
  // 	|	<SQL parameter reference>
  // 	|	<dynamic parameter specification>
  // 	|	<embedded variable specification>
  // 	|	<current collation specification>
  // 	|	CURRENT_DEFAULT_TRANSFORM_GROUP
  // 	|	CURRENT_PATH
  // 	|	CURRENT_ROLE
  // 	|	CURRENT_TRANSFORM_GROUP_FOR_TYPE <path-resolved user-defined type name>
  // 	|	CURRENT_USER
  // 	|	SESSION_USER
  // 	|	SYSTEM_USER
  // 	|	USER
  // 	|	VALUE
  public static boolean general_value_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "general_value_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GENERAL_VALUE_SPECIFICATION, "<general value specification>");
    r = host_parameter_specification(b, l + 1);
    if (!r) r = SQL_parameter_reference(b, l + 1);
    if (!r) r = dynamic_parameter_specification(b, l + 1);
    if (!r) r = embedded_variable_specification(b, l + 1);
    if (!r) r = current_collation_specification(b, l + 1);
    if (!r) r = consumeToken(b, CURRENT_DEFAULT_TRANSFORM_GROUP);
    if (!r) r = consumeToken(b, CURRENT_PATH);
    if (!r) r = consumeToken(b, CURRENT_ROLE);
    if (!r) r = parseTokens(b, 0, CURRENT_TRANSFORM_GROUP_FOR_TYPE, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_);
    if (!r) r = consumeToken(b, CURRENT_USER);
    if (!r) r = consumeToken(b, SESSION_USER);
    if (!r) r = consumeToken(b, SYSTEM_USER);
    if (!r) r = consumeToken(b, USER);
    if (!r) r = consumeToken(b, VALUE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <value expression> AS <path-resolved user-defined type name>
  public static boolean generalized_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "generalized_expression")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    r = r && consumeTokens(b, 0, AS, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_);
    exit_section_(b, m, GENERALIZED_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <value expression primary> AS <data type> <right paren> <period> <method name>
  // 		[ <SQL argument list> ]
  public static boolean generalized_invocation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "generalized_invocation")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && value_expression_primary(b, l + 1);
    r = r && consumeTokens(b, 0, AS, _DATA_TYPE_, _RIGHT_PAREN_, _PERIOD_, _METHOD_NAME_);
    r = r && generalized_invocation_7(b, l + 1);
    exit_section_(b, m, GENERALIZED_INVOCATION, r);
    return r;
  }

  // [ <SQL argument list> ]
  private static boolean generalized_invocation_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "generalized_invocation_7")) return false;
    SQL_argument_list(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <generation rule> AS <generation expression>
  public static boolean generation_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "generation_clause")) return false;
    if (!nextTokenIs(b, _GENERATION_RULE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = generation_rule(b, l + 1);
    r = r && consumeTokens(b, 0, AS, _GENERATION_EXPRESSION_);
    exit_section_(b, m, GENERATION_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <value expression> <right paren>
  public static boolean generation_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "generation_expression")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && value_expression(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, GENERATION_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // GENERATED ALWAYS
  public static boolean generation_rule(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "generation_rule")) return false;
    if (!nextTokenIs(b, GENERATED)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, GENERATED, ALWAYS);
    exit_section_(b, m, GENERATION_RULE, r);
    return r;
  }

  /* ********************************************************** */
  // <get header information> [ { <comma> <get header information> }... ]
  // 	|	VALUE <item number> <get item information> [ { <comma> <get item information> }... ]
  public static boolean get_descriptor_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_descriptor_information")) return false;
    if (!nextTokenIs(b, "<get descriptor information>", VALUE, _GET_HEADER_INFORMATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GET_DESCRIPTOR_INFORMATION, "<get descriptor information>");
    r = get_descriptor_information_0(b, l + 1);
    if (!r) r = get_descriptor_information_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <get header information> [ { <comma> <get header information> }... ]
  private static boolean get_descriptor_information_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_descriptor_information_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = get_header_information(b, l + 1);
    r = r && get_descriptor_information_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <get header information> }... ]
  private static boolean get_descriptor_information_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_descriptor_information_0_1")) return false;
    get_descriptor_information_0_1_0(b, l + 1);
    return true;
  }

  // <comma> <get header information>
  private static boolean get_descriptor_information_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_descriptor_information_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && get_header_information(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // VALUE <item number> <get item information> [ { <comma> <get item information> }... ]
  private static boolean get_descriptor_information_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_descriptor_information_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, VALUE, _ITEM_NUMBER_, _GET_ITEM_INFORMATION_);
    r = r && get_descriptor_information_1_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <get item information> }... ]
  private static boolean get_descriptor_information_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_descriptor_information_1_3")) return false;
    get_descriptor_information_1_3_0(b, l + 1);
    return true;
  }

  // <comma> <get item information>
  private static boolean get_descriptor_information_1_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_descriptor_information_1_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && get_item_information(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // GET DIAGNOSTICS <SQL diagnostics information>
  public static boolean get_diagnostics_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_diagnostics_statement")) return false;
    if (!nextTokenIs(b, GET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, GET, DIAGNOSTICS, _SQL_DIAGNOSTICS_INFORMATION_);
    exit_section_(b, m, GET_DIAGNOSTICS_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <simple target specification 1> <equals operator> <header item name>
  public static boolean get_header_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_header_information")) return false;
    if (!nextTokenIs(b, _SIMPLE_TARGET_SPECIFICATION_1_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_target_specification_1(b, l + 1);
    r = r && equals_operator(b, l + 1);
    r = r && header_item_name(b, l + 1);
    exit_section_(b, m, GET_HEADER_INFORMATION, r);
    return r;
  }

  /* ********************************************************** */
  // <simple target specification 2> <equals operator> <descriptor item name>
  public static boolean get_item_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "get_item_information")) return false;
    if (!nextTokenIs(b, _SIMPLE_TARGET_SPECIFICATION_2_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_target_specification_2(b, l + 1);
    r = r && equals_operator(b, l + 1);
    r = r && descriptor_item_name(b, l + 1);
    exit_section_(b, m, GET_ITEM_INFORMATION, r);
    return r;
  }

  /* ********************************************************** */
  // GLOBAL | LOCAL
  public static boolean global_or_local(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "global_or_local")) return false;
    if (!nextTokenIs(b, "<global or local>", GLOBAL, LOCAL)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GLOBAL_OR_LOCAL, "<global or local>");
    r = consumeToken(b, GLOBAL);
    if (!r) r = consumeToken(b, LOCAL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // { GOTO | GO TO } <goto target>
  public static boolean go_to(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "go_to")) return false;
    if (!nextTokenIs(b, "<go to>", GO, GOTO)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GO_TO, "<go to>");
    r = go_to_0(b, l + 1);
    r = r && goto_target(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // GOTO | GO TO
  private static boolean go_to_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "go_to_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, GOTO);
    if (!r) r = parseTokens(b, 0, GO, TO);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <host label identifier>
  // 	|	<unsigned integer>
  // 	|	<host PL/I label variable>
  public static boolean goto_target(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "goto_target")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GOTO_TARGET, "<goto target>");
    r = host_label_identifier(b, l + 1);
    if (!r) r = unsigned_integer(b, l + 1);
    if (!r) r = host_PL_I_label_variable(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // GRANT <privileges> TO <grantee> [ { <comma> <grantee> }... ]
  // 		[ WITH HIERARCHY OPTION ] [ WITH GRANT OPTION ] [ GRANTED BY <grantor> ]
  public static boolean grant_privilege_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_privilege_statement")) return false;
    if (!nextTokenIs(b, GRANT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, GRANT, _PRIVILEGES_, TO, _GRANTEE_);
    r = r && grant_privilege_statement_4(b, l + 1);
    r = r && grant_privilege_statement_5(b, l + 1);
    r = r && grant_privilege_statement_6(b, l + 1);
    r = r && grant_privilege_statement_7(b, l + 1);
    exit_section_(b, m, GRANT_PRIVILEGE_STATEMENT, r);
    return r;
  }

  // [ { <comma> <grantee> }... ]
  private static boolean grant_privilege_statement_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_privilege_statement_4")) return false;
    grant_privilege_statement_4_0(b, l + 1);
    return true;
  }

  // <comma> <grantee>
  private static boolean grant_privilege_statement_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_privilege_statement_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && grantee(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ WITH HIERARCHY OPTION ]
  private static boolean grant_privilege_statement_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_privilege_statement_5")) return false;
    parseTokens(b, 0, WITH, HIERARCHY, OPTION);
    return true;
  }

  // [ WITH GRANT OPTION ]
  private static boolean grant_privilege_statement_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_privilege_statement_6")) return false;
    parseTokens(b, 0, WITH, GRANT, OPTION);
    return true;
  }

  // [ GRANTED BY <grantor> ]
  private static boolean grant_privilege_statement_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_privilege_statement_7")) return false;
    parseTokens(b, 0, GRANTED, BY, _GRANTOR_);
    return true;
  }

  /* ********************************************************** */
  // GRANT <role granted> [ { <comma> <role granted> }... ]
  // 		TO <grantee> [ { <comma> <grantee> }... ] [ WITH ADMIN OPTION ] [ GRANTED BY <grantor> ]
  public static boolean grant_role_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_role_statement")) return false;
    if (!nextTokenIs(b, GRANT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, GRANT, _ROLE_GRANTED_);
    r = r && grant_role_statement_2(b, l + 1);
    r = r && consumeTokens(b, 0, TO, _GRANTEE_);
    r = r && grant_role_statement_5(b, l + 1);
    r = r && grant_role_statement_6(b, l + 1);
    r = r && grant_role_statement_7(b, l + 1);
    exit_section_(b, m, GRANT_ROLE_STATEMENT, r);
    return r;
  }

  // [ { <comma> <role granted> }... ]
  private static boolean grant_role_statement_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_role_statement_2")) return false;
    grant_role_statement_2_0(b, l + 1);
    return true;
  }

  // <comma> <role granted>
  private static boolean grant_role_statement_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_role_statement_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && role_granted(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <grantee> }... ]
  private static boolean grant_role_statement_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_role_statement_5")) return false;
    grant_role_statement_5_0(b, l + 1);
    return true;
  }

  // <comma> <grantee>
  private static boolean grant_role_statement_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_role_statement_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && grantee(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ WITH ADMIN OPTION ]
  private static boolean grant_role_statement_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_role_statement_6")) return false;
    parseTokens(b, 0, WITH, ADMIN, OPTION);
    return true;
  }

  // [ GRANTED BY <grantor> ]
  private static boolean grant_role_statement_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_role_statement_7")) return false;
    parseTokens(b, 0, GRANTED, BY, _GRANTOR_);
    return true;
  }

  /* ********************************************************** */
  // <grant privilege statement> | <grant role statement>
  public static boolean grant_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grant_statement")) return false;
    if (!nextTokenIs(b, "<grant statement>", _GRANT_PRIVILEGE_STATEMENT_, _GRANT_ROLE_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GRANT_STATEMENT, "<grant statement>");
    r = grant_privilege_statement(b, l + 1);
    if (!r) r = grant_role_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // PUBLIC | <authorization identifier>
  public static boolean grantee(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grantee")) return false;
    if (!nextTokenIs(b, "<grantee>", PUBLIC, _AUTHORIZATION_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GRANTEE, "<grantee>");
    r = consumeToken(b, PUBLIC);
    if (!r) r = authorization_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CURRENT_USER | CURRENT_ROLE
  public static boolean grantor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grantor")) return false;
    if (!nextTokenIs(b, "<grantor>", CURRENT_ROLE, CURRENT_USER)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GRANTOR, "<grantor>");
    r = consumeToken(b, CURRENT_USER);
    if (!r) r = consumeToken(b, CURRENT_ROLE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // >
  public static boolean greater_than_operator(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, GREATER_THAN_OPERATOR, true);
    return true;
  }

  /* ********************************************************** */
  // <greater than operator> <equals operator>
  public static boolean greater_than_or_equals_operator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "greater_than_or_equals_operator")) return false;
    if (!nextTokenIs(b, _GREATER_THAN_OPERATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = greater_than_operator(b, l + 1);
    r = r && equals_operator(b, l + 1);
    exit_section_(b, m, GREATER_THAN_OR_EQUALS_OPERATOR, r);
    return r;
  }

  /* ********************************************************** */
  // GROUP BY [ <set quantifier> ] <grouping element list>
  public static boolean group_by_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "group_by_clause")) return false;
    if (!nextTokenIs(b, GROUP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, GROUP, BY);
    r = r && group_by_clause_2(b, l + 1);
    r = r && grouping_element_list(b, l + 1);
    exit_section_(b, m, GROUP_BY_CLAUSE, r);
    return r;
  }

  // [ <set quantifier> ]
  private static boolean group_by_clause_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "group_by_clause_2")) return false;
    set_quantifier(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean group_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "group_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, GROUP_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <group name> FOR TYPE <path-resolved user-defined type name>
  public static boolean group_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "group_specification")) return false;
    if (!nextTokenIs(b, _GROUP_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = group_name(b, l + 1);
    r = r && consumeTokens(b, 0, FOR, TYPE, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_);
    exit_section_(b, m, GROUP_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <column reference> [ <collate clause> ]
  public static boolean grouping_column_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_column_reference")) return false;
    if (!nextTokenIs(b, _COLUMN_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_reference(b, l + 1);
    r = r && grouping_column_reference_1(b, l + 1);
    exit_section_(b, m, GROUPING_COLUMN_REFERENCE, r);
    return r;
  }

  // [ <collate clause> ]
  private static boolean grouping_column_reference_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_column_reference_1")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <grouping column reference> [ { <comma> <grouping column reference> }... ]
  public static boolean grouping_column_reference_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_column_reference_list")) return false;
    if (!nextTokenIs(b, _GROUPING_COLUMN_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = grouping_column_reference(b, l + 1);
    r = r && grouping_column_reference_list_1(b, l + 1);
    exit_section_(b, m, GROUPING_COLUMN_REFERENCE_LIST, r);
    return r;
  }

  // [ { <comma> <grouping column reference> }... ]
  private static boolean grouping_column_reference_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_column_reference_list_1")) return false;
    grouping_column_reference_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <grouping column reference>
  private static boolean grouping_column_reference_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_column_reference_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && grouping_column_reference(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <ordinary grouping set>
  // 	|	<rollup list>
  // 	|	<cube list>
  // 	|	<grouping sets specification>
  // 	|	<empty grouping set>
  public static boolean grouping_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_element")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GROUPING_ELEMENT, "<grouping element>");
    r = ordinary_grouping_set(b, l + 1);
    if (!r) r = rollup_list(b, l + 1);
    if (!r) r = cube_list(b, l + 1);
    if (!r) r = grouping_sets_specification(b, l + 1);
    if (!r) r = empty_grouping_set(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <grouping element> [ { <comma> <grouping element> }... ]
  public static boolean grouping_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_element_list")) return false;
    if (!nextTokenIs(b, _GROUPING_ELEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = grouping_element(b, l + 1);
    r = r && grouping_element_list_1(b, l + 1);
    exit_section_(b, m, GROUPING_ELEMENT_LIST, r);
    return r;
  }

  // [ { <comma> <grouping element> }... ]
  private static boolean grouping_element_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_element_list_1")) return false;
    grouping_element_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <grouping element>
  private static boolean grouping_element_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_element_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && grouping_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // GROUPING <left paren> <column reference> [ { <comma> <column reference> }... ] <right paren>
  public static boolean grouping_operation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_operation")) return false;
    if (!nextTokenIs(b, GROUPING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, GROUPING, _LEFT_PAREN_, _COLUMN_REFERENCE_);
    r = r && grouping_operation_3(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, GROUPING_OPERATION, r);
    return r;
  }

  // [ { <comma> <column reference> }... ]
  private static boolean grouping_operation_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_operation_3")) return false;
    grouping_operation_3_0(b, l + 1);
    return true;
  }

  // <comma> <column reference>
  private static boolean grouping_operation_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_operation_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && column_reference(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <ordinary grouping set>
  // 	|	<rollup list>
  // 	|	<cube list>
  // 	|	<grouping sets specification>
  // 	|	<empty grouping set>
  public static boolean grouping_set(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_set")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GROUPING_SET, "<grouping set>");
    r = ordinary_grouping_set(b, l + 1);
    if (!r) r = rollup_list(b, l + 1);
    if (!r) r = cube_list(b, l + 1);
    if (!r) r = grouping_sets_specification(b, l + 1);
    if (!r) r = empty_grouping_set(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <grouping set> [ { <comma> <grouping set> }... ]
  public static boolean grouping_set_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_set_list")) return false;
    if (!nextTokenIs(b, _GROUPING_SET_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = grouping_set(b, l + 1);
    r = r && grouping_set_list_1(b, l + 1);
    exit_section_(b, m, GROUPING_SET_LIST, r);
    return r;
  }

  // [ { <comma> <grouping set> }... ]
  private static boolean grouping_set_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_set_list_1")) return false;
    grouping_set_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <grouping set>
  private static boolean grouping_set_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_set_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && grouping_set(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // GROUPING SETS <left paren> <grouping set list> <right paren>
  public static boolean grouping_sets_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "grouping_sets_specification")) return false;
    if (!nextTokenIs(b, GROUPING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, GROUPING, SETS, _LEFT_PAREN_, _GROUPING_SET_LIST_, _RIGHT_PAREN_);
    exit_section_(b, m, GROUPING_SETS_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // HAVING <search condition>
  public static boolean having_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "having_clause")) return false;
    if (!nextTokenIs(b, HAVING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, HAVING, _SEARCH_CONDITION_);
    exit_section_(b, m, HAVING_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // COUNT | KEY_TYPE | DYNAMIC_FUNCTION | DYNAMIC_FUNCTION_CODE | TOP_LEVEL_COUNT
  public static boolean header_item_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "header_item_name")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, HEADER_ITEM_NAME, "<header item name>");
    r = consumeToken(b, COUNT);
    if (!r) r = consumeToken(b, KEY_TYPE);
    if (!r) r = consumeToken(b, DYNAMIC_FUNCTION);
    if (!r) r = consumeToken(b, DYNAMIC_FUNCTION_CODE);
    if (!r) r = consumeToken(b, TOP_LEVEL_COUNT);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <digit> | A | B | C | D | E | F | a | b | c | d | e | f
  public static boolean hexit(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hexit")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, HEXIT, "<hexit>");
    r = digit(b, l + 1);
    if (!r) r = consumeToken(b, A);
    if (!r) r = consumeToken(b, B);
    if (!r) r = consumeToken(b, C);
    if (!r) r = consumeToken(b, D);
    if (!r) r = consumeToken(b, E);
    if (!r) r = consumeToken(b, F);
    if (!r) r = consumeToken(b, A);
    if (!r) r = consumeToken(b, B);
    if (!r) r = consumeToken(b, C);
    if (!r) r = consumeToken(b, D);
    if (!r) r = consumeToken(b, E);
    if (!r) r = consumeToken(b, F);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean high_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "high_value")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, HIGH_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // HOLD LOCATOR <locator reference> [ { <comma> <locator reference> }... ]
  public static boolean hold_locator_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hold_locator_statement")) return false;
    if (!nextTokenIs(b, HOLD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, HOLD, LOCATOR, _LOCATOR_REFERENCE_);
    r = r && hold_locator_statement_3(b, l + 1);
    exit_section_(b, m, HOLD_LOCATOR_STATEMENT, r);
    return r;
  }

  // [ { <comma> <locator reference> }... ]
  private static boolean hold_locator_statement_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hold_locator_statement_3")) return false;
    hold_locator_statement_3_0(b, l + 1);
    return true;
  }

  // <comma> <locator reference>
  private static boolean hold_locator_statement_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hold_locator_statement_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && locator_reference(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean host_PL_I_label_variable(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, HOST_PL_I_LABEL_VARIABLE, true);
    return true;
  }

  /* ********************************************************** */
  // <Ada host identifier>
  // 	|	<C host identifier>
  // 	|	<COBOL host identifier>
  // 	|	<Fortran host identifier>
  // 	|	<MUMPS host identifier>
  // 	|	<Pascal host identifier>
  // 	|	<PL/I host identifier>
  public static boolean host_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_identifier")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, HOST_IDENTIFIER, "<host identifier>");
    r = Ada_host_identifier(b, l + 1);
    if (!r) r = C_host_identifier(b, l + 1);
    if (!r) r = COBOL_host_identifier(b, l + 1);
    if (!r) r = Fortran_host_identifier(b, l + 1);
    if (!r) r = MUMPS_host_identifier(b, l + 1);
    if (!r) r = Pascal_host_identifier(b, l + 1);
    if (!r) r = PL_I_host_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean host_label_identifier(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, HOST_LABEL_IDENTIFIER, true);
    return true;
  }

  /* ********************************************************** */
  // <data type> [ <locator indication> ]
  public static boolean host_parameter_data_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_data_type")) return false;
    if (!nextTokenIs(b, _DATA_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    r = r && host_parameter_data_type_1(b, l + 1);
    exit_section_(b, m, HOST_PARAMETER_DATA_TYPE, r);
    return r;
  }

  // [ <locator indication> ]
  private static boolean host_parameter_data_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_data_type_1")) return false;
    locator_indication(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <host parameter name> <host parameter data type>
  // 	|	<status parameter>
  public static boolean host_parameter_declaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_declaration")) return false;
    if (!nextTokenIs(b, "<host parameter declaration>", _HOST_PARAMETER_NAME_, _STATUS_PARAMETER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, HOST_PARAMETER_DECLARATION, "<host parameter declaration>");
    r = host_parameter_name(b, l + 1);
    if (!r) r = status_parameter(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <host parameter declaration> [ { <comma> <host parameter declaration> }... ] <right paren>
  public static boolean host_parameter_declaration_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_declaration_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && host_parameter_declaration(b, l + 1);
    r = r && host_parameter_declaration_list_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, HOST_PARAMETER_DECLARATION_LIST, r);
    return r;
  }

  // [ { <comma> <host parameter declaration> }... ]
  private static boolean host_parameter_declaration_list_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_declaration_list_2")) return false;
    host_parameter_declaration_list_2_0(b, l + 1);
    return true;
  }

  // <comma> <host parameter declaration>
  private static boolean host_parameter_declaration_list_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_declaration_list_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && host_parameter_declaration(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <colon> <identifier>
  public static boolean host_parameter_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_name")) return false;
    if (!nextTokenIs(b, _COLON_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = colon(b, l + 1);
    r = r && identifier(b, l + 1);
    exit_section_(b, m, HOST_PARAMETER_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <host parameter name> [ <indicator parameter> ]
  public static boolean host_parameter_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_specification")) return false;
    if (!nextTokenIs(b, _HOST_PARAMETER_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = host_parameter_name(b, l + 1);
    r = r && host_parameter_specification_1(b, l + 1);
    exit_section_(b, m, HOST_PARAMETER_SPECIFICATION, r);
    return r;
  }

  // [ <indicator parameter> ]
  private static boolean host_parameter_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_parameter_specification_1")) return false;
    indicator_parameter(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <Ada variable definition>
  // 	|	<C variable definition>
  // 	|	<COBOL variable definition>
  // 	|	<Fortran variable definition>
  // 	|	<MUMPS variable definition>
  // 	|	<Pascal variable definition>
  // 	|	<PL/I variable definition>
  public static boolean host_variable_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "host_variable_definition")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, HOST_VARIABLE_DEFINITION, "<host variable definition>");
    r = Ada_variable_definition(b, l + 1);
    if (!r) r = C_variable_definition(b, l + 1);
    if (!r) r = COBOL_variable_definition(b, l + 1);
    if (!r) r = Fortran_variable_definition(b, l + 1);
    if (!r) r = MUMPS_variable_definition(b, l + 1);
    if (!r) r = Pascal_variable_definition(b, l + 1);
    if (!r) r = PL_I_variable_definition(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <datetime value>
  public static boolean hours_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hours_value")) return false;
    if (!nextTokenIs(b, _DATETIME_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = datetime_value(b, l + 1);
    exit_section_(b, m, HOURS_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <rank function type> <left paren> <hypothetical set function value expression list> <right paren> <within group specification>
  public static boolean hypothetical_set_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hypothetical_set_function")) return false;
    if (!nextTokenIs(b, _RANK_FUNCTION_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = rank_function_type(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && hypothetical_set_function_value_expression_list(b, l + 1);
    r = r && right_paren(b, l + 1);
    r = r && within_group_specification(b, l + 1);
    exit_section_(b, m, HYPOTHETICAL_SET_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression> [ { <comma> <value expression> }... ]
  public static boolean hypothetical_set_function_value_expression_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hypothetical_set_function_value_expression_list")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    r = r && hypothetical_set_function_value_expression_list_1(b, l + 1);
    exit_section_(b, m, HYPOTHETICAL_SET_FUNCTION_VALUE_EXPRESSION_LIST, r);
    return r;
  }

  // [ { <comma> <value expression> }... ]
  private static boolean hypothetical_set_function_value_expression_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hypothetical_set_function_value_expression_list_1")) return false;
    hypothetical_set_function_value_expression_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <value expression>
  private static boolean hypothetical_set_function_value_expression_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "hypothetical_set_function_value_expression_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && value_expression(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <actual identifier>
  public static boolean identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identifier")) return false;
    if (!nextTokenIs(b, _ACTUAL_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = actual_identifier(b, l + 1);
    exit_section_(b, m, IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier start> [ <identifier part>... ]
  public static boolean identifier_body(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identifier_body")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_START_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier_start(b, l + 1);
    r = r && identifier_body_1(b, l + 1);
    exit_section_(b, m, IDENTIFIER_BODY, r);
    return r;
  }

  // [ <identifier part>... ]
  private static boolean identifier_body_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identifier_body_1")) return false;
    consumeToken(b, _IDENTIFIER_PART____);
    return true;
  }

  /* ********************************************************** */
  // <identifier> [ { <period> <identifier> }... ]
  public static boolean identifier_chain(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identifier_chain")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    r = r && identifier_chain_1(b, l + 1);
    exit_section_(b, m, IDENTIFIER_CHAIN, r);
    return r;
  }

  // [ { <period> <identifier> }... ]
  private static boolean identifier_chain_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identifier_chain_1")) return false;
    identifier_chain_1_0(b, l + 1);
    return true;
  }

  // <period> <identifier>
  private static boolean identifier_chain_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identifier_chain_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = period(b, l + 1);
    r = r && identifier(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier start> | <identifier extend>
  public static boolean identifier_part(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identifier_part")) return false;
    if (!nextTokenIs(b, "<identifier part>", _IDENTIFIER_EXTEND_, _IDENTIFIER_START_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, IDENTIFIER_PART, "<identifier part>");
    r = identifier_start(b, l + 1);
    if (!r) r = consumeToken(b, _IDENTIFIER_EXTEND_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <initial alphabetic character> | <ideographic character>
  public static boolean identifier_start(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identifier_start")) return false;
    if (!nextTokenIs(b, "<identifier start>", _IDEOGRAPHIC_CHARACTER_, _INITIAL_ALPHABETIC_CHARACTER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, IDENTIFIER_START, "<identifier start>");
    r = consumeToken(b, _INITIAL_ALPHABETIC_CHARACTER_);
    if (!r) r = consumeToken(b, _IDEOGRAPHIC_CHARACTER_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
  // 		[ <left paren> <common sequence generator options> <right paren> ]
  public static boolean identity_column_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identity_column_specification")) return false;
    if (!nextTokenIs(b, GENERATED)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, GENERATED);
    r = r && identity_column_specification_1(b, l + 1);
    r = r && consumeTokens(b, 0, AS, IDENTITY);
    r = r && identity_column_specification_4(b, l + 1);
    exit_section_(b, m, IDENTITY_COLUMN_SPECIFICATION, r);
    return r;
  }

  // ALWAYS | BY DEFAULT
  private static boolean identity_column_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identity_column_specification_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ALWAYS);
    if (!r) r = parseTokens(b, 0, BY, DEFAULT);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <common sequence generator options> <right paren> ]
  private static boolean identity_column_specification_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identity_column_specification_4")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // INCLUDING IDENTITY | EXCLUDING IDENTITY
  public static boolean identity_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "identity_option")) return false;
    if (!nextTokenIs(b, "<identity option>", EXCLUDING, INCLUDING)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, IDENTITY_OPTION, "<identity option>");
    r = parseTokens(b, 0, INCLUDING, IDENTITY);
    if (!r) r = parseTokens(b, 0, EXCLUDING, IDENTITY);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character set name>
  public static boolean implementation_defined_character_set_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "implementation_defined_character_set_name")) return false;
    if (!nextTokenIs(b, _CHARACTER_SET_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_set_name(b, l + 1);
    exit_section_(b, m, IMPLEMENTATION_DEFINED_CHARACTER_SET_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <null specification> | <empty specification>
  public static boolean implicitly_typed_value_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "implicitly_typed_value_specification")) return false;
    if (!nextTokenIs(b, "<implicitly typed value specification>", _EMPTY_SPECIFICATION_, _NULL_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, IMPLICITLY_TYPED_VALUE_SPECIFICATION, "<implicitly typed value specification>");
    r = null_specification(b, l + 1);
    if (!r) r = empty_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <in predicate part 2>
  public static boolean in_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "in_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && in_predicate_part_2(b, l + 1);
    exit_section_(b, m, IN_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // [ NOT ] IN <in predicate value>
  public static boolean in_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "in_predicate_part_2")) return false;
    if (!nextTokenIs(b, "<in predicate part 2>", IN, NOT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, IN_PREDICATE_PART_2, "<in predicate part 2>");
    r = in_predicate_part_2_0(b, l + 1);
    r = r && consumeTokens(b, 0, IN, _IN_PREDICATE_VALUE_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ NOT ]
  private static boolean in_predicate_part_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "in_predicate_part_2_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  /* ********************************************************** */
  // <table subquery>
  // 	|	<left paren> <in value list> <right paren>
  public static boolean in_predicate_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "in_predicate_value")) return false;
    if (!nextTokenIs(b, "<in predicate value>", _LEFT_PAREN_, _TABLE_SUBQUERY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, IN_PREDICATE_VALUE, "<in predicate value>");
    r = table_subquery(b, l + 1);
    if (!r) r = left_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value expression> [ { <comma> <row value expression> }... ]
  public static boolean in_value_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "in_value_list")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_expression(b, l + 1);
    r = r && in_value_list_1(b, l + 1);
    exit_section_(b, m, IN_VALUE_LIST, r);
    return r;
  }

  // [ { <comma> <row value expression> }... ]
  private static boolean in_value_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "in_value_list_1")) return false;
    in_value_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <row value expression>
  private static boolean in_value_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "in_value_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && row_value_expression(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <window specification>
  public static boolean in_line_window_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "in_line_window_specification")) return false;
    if (!nextTokenIs(b, _WINDOW_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_specification(b, l + 1);
    exit_section_(b, m, IN_LINE_WINDOW_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <path-resolved user-defined type name>
  public static boolean inclusive_user_defined_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "inclusive_user_defined_type_specification")) return false;
    if (!nextTokenIs(b, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = path_resolved_user_defined_type_name(b, l + 1);
    exit_section_(b, m, INCLUSIVE_USER_DEFINED_TYPE_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean independent_variable_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "independent_variable_expression")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, INDEPENDENT_VARIABLE_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // [ INDICATOR ] <host parameter name>
  public static boolean indicator_parameter(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "indicator_parameter")) return false;
    if (!nextTokenIs(b, "<indicator parameter>", INDICATOR, _HOST_PARAMETER_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INDICATOR_PARAMETER, "<indicator parameter>");
    r = indicator_parameter_0(b, l + 1);
    r = r && host_parameter_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ INDICATOR ]
  private static boolean indicator_parameter_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "indicator_parameter_0")) return false;
    consumeToken(b, INDICATOR);
    return true;
  }

  /* ********************************************************** */
  // [ INDICATOR ] <embedded variable name>
  public static boolean indicator_variable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "indicator_variable")) return false;
    if (!nextTokenIs(b, "<indicator variable>", INDICATOR, _EMBEDDED_VARIABLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INDICATOR_VARIABLE, "<indicator variable>");
    r = indicator_variable_0(b, l + 1);
    r = r && embedded_variable_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ INDICATOR ]
  private static boolean indicator_variable_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "indicator_variable_0")) return false;
    consumeToken(b, INDICATOR);
    return true;
  }

  /* ********************************************************** */
  // <using arguments> | <using input descriptor>
  public static boolean input_using_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "input_using_clause")) return false;
    if (!nextTokenIs(b, "<input using clause>", _USING_ARGUMENTS_, _USING_INPUT_DESCRIPTOR_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INPUT_USING_CLAUSE, "<input using clause>");
    r = using_arguments(b, l + 1);
    if (!r) r = using_input_descriptor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean insert_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "insert_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, INSERT_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // <from subquery>
  // 	|	<from constructor>
  // 	|	<from default>
  public static boolean insert_columns_and_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "insert_columns_and_source")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INSERT_COLUMNS_AND_SOURCE, "<insert columns and source>");
    r = from_subquery(b, l + 1);
    if (!r) r = from_constructor(b, l + 1);
    if (!r) r = from_default(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // INSERT INTO <insertion target> <insert columns and source>
  public static boolean insert_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "insert_statement")) return false;
    if (!nextTokenIs(b, INSERT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, INSERT, INTO, _INSERTION_TARGET_, _INSERT_COLUMNS_AND_SOURCE_);
    exit_section_(b, m, INSERT_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <table name>
  public static boolean insertion_target(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "insertion_target")) return false;
    if (!nextTokenIs(b, _TABLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_name(b, l + 1);
    exit_section_(b, m, INSERTION_TARGET, r);
    return r;
  }

  /* ********************************************************** */
  // INSTANTIABLE | NOT INSTANTIABLE
  public static boolean instantiable_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "instantiable_clause")) return false;
    if (!nextTokenIs(b, "<instantiable clause>", INSTANTIABLE, NOT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INSTANTIABLE_CLAUSE, "<instantiable clause>");
    r = consumeToken(b, INSTANTIABLE);
    if (!r) r = parseTokens(b, 0, NOT, INSTANTIABLE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ABS <left paren> <interval value expression> <right paren>
  public static boolean interval_absolute_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_absolute_value_function")) return false;
    if (!nextTokenIs(b, ABS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ABS, _LEFT_PAREN_, _INTERVAL_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, INTERVAL_ABSOLUTE_VALUE_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // [ <sign> ] <interval primary>
  public static boolean interval_factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_factor")) return false;
    if (!nextTokenIs(b, "<interval factor>", _INTERVAL_PRIMARY_, _SIGN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INTERVAL_FACTOR, "<interval factor>");
    r = interval_factor_0(b, l + 1);
    r = r && interval_primary(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <sign> ]
  private static boolean interval_factor_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_factor_0")) return false;
    sign(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean interval_fractional_seconds_precision(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_fractional_seconds_precision")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, INTERVAL_FRACTIONAL_SECONDS_PRECISION, r);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean interval_leading_field_precision(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_leading_field_precision")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, INTERVAL_LEADING_FIELD_PRECISION, r);
    return r;
  }

  /* ********************************************************** */
  // INTERVAL [ <sign> ] <interval string> <interval qualifier>
  public static boolean interval_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_literal")) return false;
    if (!nextTokenIs(b, INTERVAL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, INTERVAL);
    r = r && interval_literal_1(b, l + 1);
    r = r && interval_string(b, l + 1);
    r = r && interval_qualifier(b, l + 1);
    exit_section_(b, m, INTERVAL_LITERAL, r);
    return r;
  }

  // [ <sign> ]
  private static boolean interval_literal_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_literal_1")) return false;
    sign(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <value expression primary> [ <interval qualifier> ]
  // 	|	<interval value function>
  public static boolean interval_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_primary")) return false;
    if (!nextTokenIs(b, "<interval primary>", _INTERVAL_VALUE_FUNCTION_, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INTERVAL_PRIMARY, "<interval primary>");
    r = interval_primary_0(b, l + 1);
    if (!r) r = interval_value_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <value expression primary> [ <interval qualifier> ]
  private static boolean interval_primary_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_primary_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    r = r && interval_primary_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <interval qualifier> ]
  private static boolean interval_primary_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_primary_0_1")) return false;
    interval_qualifier(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <start field> TO <end field>
  // 	|	<single datetime field>
  public static boolean interval_qualifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_qualifier")) return false;
    if (!nextTokenIs(b, "<interval qualifier>", _SINGLE_DATETIME_FIELD_, _START_FIELD_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INTERVAL_QUALIFIER, "<interval qualifier>");
    r = start_field(b, l + 1);
    if (!r) r = single_datetime_field(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <quote> <unquoted interval string> <quote>
  public static boolean interval_string(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_string")) return false;
    if (!nextTokenIs(b, _QUOTE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = quote(b, l + 1);
    r = r && unquoted_interval_string(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, INTERVAL_STRING, r);
    return r;
  }

  /* ********************************************************** */
  // <interval factor>
  // 	|	<interval term 2> <asterisk> <factor>
  // 	|	<interval term 2> <solidus> <factor>
  // 	|	<term> <asterisk> <interval factor>
  public static boolean interval_term(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_term")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INTERVAL_TERM, "<interval term>");
    r = interval_factor(b, l + 1);
    if (!r) r = interval_term_2(b, l + 1);
    if (!r) r = interval_term_2(b, l + 1);
    if (!r) r = term(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <interval term>
  public static boolean interval_term_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_term_1")) return false;
    if (!nextTokenIs(b, _INTERVAL_TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = interval_term(b, l + 1);
    exit_section_(b, m, INTERVAL_TERM_1, r);
    return r;
  }

  /* ********************************************************** */
  // <interval term>
  public static boolean interval_term_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_term_2")) return false;
    if (!nextTokenIs(b, _INTERVAL_TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = interval_term(b, l + 1);
    exit_section_(b, m, INTERVAL_TERM_2, r);
    return r;
  }

  /* ********************************************************** */
  // INTERVAL <interval qualifier>
  public static boolean interval_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_type")) return false;
    if (!nextTokenIs(b, INTERVAL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, INTERVAL, _INTERVAL_QUALIFIER_);
    exit_section_(b, m, INTERVAL_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // <interval term>
  // 	|	<interval value expression 1> <plus sign> <interval term 1>
  // 	|	<interval value expression 1> <minus sign> <interval term 1>
  // 	|	<left paren> <datetime value expression> <minus sign> <datetime term> <right paren> <interval qualifier>
  public static boolean interval_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_value_expression")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INTERVAL_VALUE_EXPRESSION, "<interval value expression>");
    r = interval_term(b, l + 1);
    if (!r) r = interval_value_expression_1(b, l + 1);
    if (!r) r = interval_value_expression_1(b, l + 1);
    if (!r) r = left_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <interval value expression>
  public static boolean interval_value_expression_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_value_expression_1")) return false;
    if (!nextTokenIs(b, _INTERVAL_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = interval_value_expression(b, l + 1);
    exit_section_(b, m, INTERVAL_VALUE_EXPRESSION_1, r);
    return r;
  }

  /* ********************************************************** */
  // <interval absolute value function>
  public static boolean interval_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "interval_value_function")) return false;
    if (!nextTokenIs(b, _INTERVAL_ABSOLUTE_VALUE_FUNCTION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = interval_absolute_value_function(b, l + 1);
    exit_section_(b, m, INTERVAL_VALUE_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <target specification>
  public static boolean into_argument(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "into_argument")) return false;
    if (!nextTokenIs(b, _TARGET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = target_specification(b, l + 1);
    exit_section_(b, m, INTO_ARGUMENT, r);
    return r;
  }

  /* ********************************************************** */
  // INTO <into argument> [ { <comma> <into argument> }... ]
  public static boolean into_arguments(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "into_arguments")) return false;
    if (!nextTokenIs(b, INTO)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, INTO, _INTO_ARGUMENT_);
    r = r && into_arguments_2(b, l + 1);
    exit_section_(b, m, INTO_ARGUMENTS, r);
    return r;
  }

  // [ { <comma> <into argument> }... ]
  private static boolean into_arguments_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "into_arguments_2")) return false;
    into_arguments_2_0(b, l + 1);
    return true;
  }

  // <comma> <into argument>
  private static boolean into_arguments_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "into_arguments_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && into_argument(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // INTO [ SQL ] DESCRIPTOR <descriptor name>
  public static boolean into_descriptor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "into_descriptor")) return false;
    if (!nextTokenIs(b, INTO)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, INTO);
    r = r && into_descriptor_1(b, l + 1);
    r = r && consumeTokens(b, 0, DESCRIPTOR, _DESCRIPTOR_NAME_);
    exit_section_(b, m, INTO_DESCRIPTOR, r);
    return r;
  }

  // [ SQL ]
  private static boolean into_descriptor_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "into_descriptor_1")) return false;
    consumeToken(b, SQL);
    return true;
  }

  /* ********************************************************** */
  // <underscore>
  public static boolean introducer(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "introducer")) return false;
    if (!nextTokenIs(b, _UNDERSCORE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = underscore(b, l + 1);
    exit_section_(b, m, INTRODUCER, r);
    return r;
  }

  /* ********************************************************** */
  // <inverse distribution function type> <left paren> <inverse distribution function argument> <right paren> <within group specification>
  public static boolean inverse_distribution_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "inverse_distribution_function")) return false;
    if (!nextTokenIs(b, _INVERSE_DISTRIBUTION_FUNCTION_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = inverse_distribution_function_type(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && inverse_distribution_function_argument(b, l + 1);
    r = r && right_paren(b, l + 1);
    r = r && within_group_specification(b, l + 1);
    exit_section_(b, m, INVERSE_DISTRIBUTION_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean inverse_distribution_function_argument(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "inverse_distribution_function_argument")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, INVERSE_DISTRIBUTION_FUNCTION_ARGUMENT, r);
    return r;
  }

  /* ********************************************************** */
  // PERCENTILE_CONT | PERCENTILE_DISC
  public static boolean inverse_distribution_function_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "inverse_distribution_function_type")) return false;
    if (!nextTokenIs(b, "<inverse distribution function type>", PERCENTILE_CONT, PERCENTILE_DISC)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INVERSE_DISTRIBUTION_FUNCTION_TYPE, "<inverse distribution function type>");
    r = consumeToken(b, PERCENTILE_CONT);
    if (!r) r = consumeToken(b, PERCENTILE_DISC);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ISOLATION LEVEL <level of isolation>
  public static boolean isolation_level(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "isolation_level")) return false;
    if (!nextTokenIs(b, ISOLATION)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ISOLATION, LEVEL, _LEVEL_OF_ISOLATION_);
    exit_section_(b, m, ISOLATION_LEVEL, r);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean item_number(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item_number")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, ITEM_NUMBER, r);
    return r;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean join_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "join_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, JOIN_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // ON <search condition>
  public static boolean join_condition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "join_condition")) return false;
    if (!nextTokenIs(b, ON)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ON, _SEARCH_CONDITION_);
    exit_section_(b, m, JOIN_CONDITION, r);
    return r;
  }

  /* ********************************************************** */
  // <join condition> | <named columns join>
  public static boolean join_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "join_specification")) return false;
    if (!nextTokenIs(b, "<join specification>", _JOIN_CONDITION_, _NAMED_COLUMNS_JOIN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, JOIN_SPECIFICATION, "<join specification>");
    r = join_condition(b, l + 1);
    if (!r) r = named_columns_join(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // INNER | <outer join type> [ OUTER ]
  public static boolean join_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "join_type")) return false;
    if (!nextTokenIs(b, "<join type>", INNER, _OUTER_JOIN_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, JOIN_TYPE, "<join type>");
    r = consumeToken(b, INNER);
    if (!r) r = join_type_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <outer join type> [ OUTER ]
  private static boolean join_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "join_type_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = outer_join_type(b, l + 1);
    r = r && join_type_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ OUTER ]
  private static boolean join_type_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "join_type_1_1")) return false;
    consumeToken(b, OUTER);
    return true;
  }

  /* ********************************************************** */
  // <cross join>
  // 	|	<qualified join>
  // 	|	<natural join>
  // 	|	<union join>
  public static boolean joined_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "joined_table")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, JOINED_TABLE, "<joined table>");
    r = cross_join(b, l + 1);
    if (!r) r = qualified_join(b, l + 1);
    if (!r) r = natural_join(b, l + 1);
    if (!r) r = union_join(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <reserved word> | <non-reserved word>
  public static boolean key_word(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "key_word")) return false;
    if (!nextTokenIs(b, "<key word>", _NON_RESERVED_WORD_, _RESERVED_WORD_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, KEY_WORD, "<key word>");
    r = reserved_word(b, l + 1);
    if (!r) r = non_reserved_word(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // LANGUAGE <language name>
  public static boolean language_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "language_clause")) return false;
    if (!nextTokenIs(b, LANGUAGE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, LANGUAGE, _LANGUAGE_NAME_);
    exit_section_(b, m, LANGUAGE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // ADA | C | COBOL | FORTRAN | MUMPS | PASCAL | PLI | SQL
  public static boolean language_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "language_name")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LANGUAGE_NAME, "<language name>");
    r = consumeToken(b, ADA);
    if (!r) r = consumeToken(b, C);
    if (!r) r = consumeToken(b, COBOL);
    if (!r) r = consumeToken(b, FORTRAN);
    if (!r) r = consumeToken(b, MUMPS);
    if (!r) r = consumeToken(b, PASCAL);
    if (!r) r = consumeToken(b, PLI);
    if (!r) r = consumeToken(b, SQL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer> [ <multiplier> ] [ <char length units> ]
  // 	|	<large object length token> [ <char length units> ]
  public static boolean large_object_length(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "large_object_length")) return false;
    if (!nextTokenIs(b, "<large object length>", _LARGE_OBJECT_LENGTH_TOKEN_, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LARGE_OBJECT_LENGTH, "<large object length>");
    r = large_object_length_0(b, l + 1);
    if (!r) r = large_object_length_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <unsigned integer> [ <multiplier> ] [ <char length units> ]
  private static boolean large_object_length_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "large_object_length_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    r = r && large_object_length_0_1(b, l + 1);
    r = r && large_object_length_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <multiplier> ]
  private static boolean large_object_length_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "large_object_length_0_1")) return false;
    multiplier(b, l + 1);
    return true;
  }

  // [ <char length units> ]
  private static boolean large_object_length_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "large_object_length_0_2")) return false;
    char_length_units(b, l + 1);
    return true;
  }

  // <large object length token> [ <char length units> ]
  private static boolean large_object_length_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "large_object_length_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = large_object_length_token(b, l + 1);
    r = r && large_object_length_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <char length units> ]
  private static boolean large_object_length_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "large_object_length_1_1")) return false;
    char_length_units(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <digit>... <multiplier>
  public static boolean large_object_length_token(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "large_object_length_token")) return false;
    if (!nextTokenIs(b, _DIGIT______MULTIPLIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _DIGIT______MULTIPLIER_);
    exit_section_(b, m, LARGE_OBJECT_LENGTH_TOKEN, r);
    return r;
  }

  /* ********************************************************** */
  // LATERAL <table subquery>
  public static boolean lateral_derived_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lateral_derived_table")) return false;
    if (!nextTokenIs(b, LATERAL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, LATERAL, _TABLE_SUBQUERY_);
    exit_section_(b, m, LATERAL_DERIVED_TABLE, r);
    return r;
  }

  /* ********************************************************** */
  // {
  public static boolean left_brace(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, LEFT_BRACE, true);
    return true;
  }

  /* ********************************************************** */
  // [
  public static boolean left_bracket(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, LEFT_BRACKET, true);
    return true;
  }

  /* ********************************************************** */
  // <left bracket> | <left bracket trigraph>
  public static boolean left_bracket_or_trigraph(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "left_bracket_or_trigraph")) return false;
    if (!nextTokenIs(b, "<left bracket or trigraph>", _LEFT_BRACKET_, _LEFT_BRACKET_TRIGRAPH_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LEFT_BRACKET_OR_TRIGRAPH, "<left bracket or trigraph>");
    r = left_bracket(b, l + 1);
    if (!r) r = left_bracket_trigraph(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ??(
  // <right bracket> ::= ]
  // <right bracket trigraph> ::= ??)
  public static boolean left_bracket_trigraph(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, LEFT_BRACKET_TRIGRAPH, true);
    return true;
  }

  /* ********************************************************** */
  // (
  public static boolean left_paren(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, LEFT_PAREN, true);
    return true;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean length(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "length")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, LENGTH, r);
    return r;
  }

  /* ********************************************************** */
  // <char length expression>
  // 	|	<octet length expression>
  public static boolean length_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "length_expression")) return false;
    if (!nextTokenIs(b, "<length expression>", _CHAR_LENGTH_EXPRESSION_, _OCTET_LENGTH_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LENGTH_EXPRESSION, "<length expression>");
    r = char_length_expression(b, l + 1);
    if (!r) r = octet_length_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <
  public static boolean less_than_operator(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, LESS_THAN_OPERATOR, true);
    return true;
  }

  /* ********************************************************** */
  // <less than operator> <equals operator>
  public static boolean less_than_or_equals_operator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "less_than_or_equals_operator")) return false;
    if (!nextTokenIs(b, _LESS_THAN_OPERATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = less_than_operator(b, l + 1);
    r = r && equals_operator(b, l + 1);
    exit_section_(b, m, LESS_THAN_OR_EQUALS_OPERATOR, r);
    return r;
  }

  /* ********************************************************** */
  // READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE
  public static boolean level_of_isolation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "level_of_isolation")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LEVEL_OF_ISOLATION, "<level of isolation>");
    r = parseTokens(b, 0, READ, UNCOMMITTED);
    if (!r) r = parseTokens(b, 0, READ, COMMITTED);
    if (!r) r = parseTokens(b, 0, REPEATABLE, READ);
    if (!r) r = consumeToken(b, SERIALIZABLE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CASCADED | LOCAL
  public static boolean levels_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "levels_clause")) return false;
    if (!nextTokenIs(b, "<levels clause>", CASCADED, LOCAL)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LEVELS_CLAUSE, "<levels clause>");
    r = consumeToken(b, CASCADED);
    if (!r) r = consumeToken(b, LOCAL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // LIKE <table name> [ <like options> ]
  public static boolean like_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "like_clause")) return false;
    if (!nextTokenIs(b, LIKE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, LIKE, _TABLE_NAME_);
    r = r && like_clause_2(b, l + 1);
    exit_section_(b, m, LIKE_CLAUSE, r);
    return r;
  }

  // [ <like options> ]
  private static boolean like_clause_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "like_clause_2")) return false;
    like_options(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <identity option> | <column default option>
  public static boolean like_options(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "like_options")) return false;
    if (!nextTokenIs(b, "<like options>", _COLUMN_DEFAULT_OPTION_, _IDENTITY_OPTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LIKE_OPTIONS, "<like options>");
    r = identity_option(b, l + 1);
    if (!r) r = column_default_option(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character like predicate> | <octet like predicate>
  public static boolean like_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "like_predicate")) return false;
    if (!nextTokenIs(b, "<like predicate>", _CHARACTER_LIKE_PREDICATE_, _OCTET_LIKE_PREDICATE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LIKE_PREDICATE, "<like predicate>");
    r = character_like_predicate(b, l + 1);
    if (!r) r = octet_like_predicate(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <attribute name> [ { <comma> <attribute name> }...] <right paren>
  public static boolean list_of_attributes(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "list_of_attributes")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && attribute_name(b, l + 1);
    r = r && list_of_attributes_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, LIST_OF_ATTRIBUTES, r);
    return r;
  }

  // [ { <comma> <attribute name> }...]
  private static boolean list_of_attributes_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "list_of_attributes_2")) return false;
    list_of_attributes_2_0(b, l + 1);
    return true;
  }

  // <comma> <attribute name>
  private static boolean list_of_attributes_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "list_of_attributes_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && attribute_name(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <signed numeric literal> | <general literal>
  public static boolean literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "literal")) return false;
    if (!nextTokenIs(b, "<literal>", _GENERAL_LITERAL_, _SIGNED_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LITERAL, "<literal>");
    r = signed_numeric_literal(b, l + 1);
    if (!r) r = general_literal(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <local or schema qualifier> <period> ] <qualified identifier>
  public static boolean local_or_schema_qualified_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "local_or_schema_qualified_name")) return false;
    if (!nextTokenIs(b, "<local or schema qualified name>", _LOCAL_OR_SCHEMA_QUALIFIER_, _QUALIFIED_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LOCAL_OR_SCHEMA_QUALIFIED_NAME, "<local or schema qualified name>");
    r = local_or_schema_qualified_name_0(b, l + 1);
    r = r && qualified_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <local or schema qualifier> <period> ]
  private static boolean local_or_schema_qualified_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "local_or_schema_qualified_name_0")) return false;
    local_or_schema_qualifier(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <schema name> | MODULE
  public static boolean local_or_schema_qualifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "local_or_schema_qualifier")) return false;
    if (!nextTokenIs(b, "<local or schema qualifier>", MODULE, _SCHEMA_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LOCAL_OR_SCHEMA_QUALIFIER, "<local or schema qualifier>");
    r = schema_name(b, l + 1);
    if (!r) r = consumeToken(b, MODULE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <local qualifier> <period> ] <qualified identifier>
  public static boolean local_qualified_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "local_qualified_name")) return false;
    if (!nextTokenIs(b, "<local qualified name>", _LOCAL_QUALIFIER_, _QUALIFIED_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LOCAL_QUALIFIED_NAME, "<local qualified name>");
    r = local_qualified_name_0(b, l + 1);
    r = r && qualified_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <local qualifier> <period> ]
  private static boolean local_qualified_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "local_qualified_name_0")) return false;
    local_qualifier(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // MODULE
  public static boolean local_qualifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "local_qualifier")) return false;
    if (!nextTokenIs(b, MODULE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, MODULE);
    exit_section_(b, m, LOCAL_QUALIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // AS LOCATOR
  public static boolean locator_indication(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "locator_indication")) return false;
    if (!nextTokenIs(b, AS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, AS, LOCATOR);
    exit_section_(b, m, LOCATOR_INDICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <host parameter name> | <embedded variable name>
  public static boolean locator_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "locator_reference")) return false;
    if (!nextTokenIs(b, "<locator reference>", _EMBEDDED_VARIABLE_NAME_, _HOST_PARAMETER_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LOCATOR_REFERENCE, "<locator reference>");
    r = host_parameter_name(b, l + 1);
    if (!r) r = embedded_variable_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean low_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "low_value")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, LOW_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // SQLEXCEPTION | SQLWARNING | NOT FOUND
  public static boolean major_category(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "major_category")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MAJOR_CATEGORY, "<major category>");
    r = consumeToken(b, SQLEXCEPTION);
    if (!r) r = consumeToken(b, SQLWARNING);
    if (!r) r = parseTokens(b, 0, NOT, FOUND);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <exact numeric literal>
  public static boolean mantissa(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "mantissa")) return false;
    if (!nextTokenIs(b, _EXACT_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = exact_numeric_literal(b, l + 1);
    exit_section_(b, m, MANTISSA, r);
    return r;
  }

  /* ********************************************************** */
  // MAP WITH <map function specification>
  public static boolean map_category(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "map_category")) return false;
    if (!nextTokenIs(b, MAP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, MAP, WITH, _MAP_FUNCTION_SPECIFICATION_);
    exit_section_(b, m, MAP_CATEGORY, r);
    return r;
  }

  /* ********************************************************** */
  // <specific routine designator>
  public static boolean map_function_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "map_function_specification")) return false;
    if (!nextTokenIs(b, _SPECIFIC_ROUTINE_DESIGNATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = specific_routine_designator(b, l + 1);
    exit_section_(b, m, MAP_FUNCTION_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <match predicate part 2>
  public static boolean match_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "match_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && match_predicate_part_2(b, l + 1);
    exit_section_(b, m, MATCH_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // MATCH [ UNIQUE ] [ SIMPLE | PARTIAL | FULL ] <table subquery>
  public static boolean match_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "match_predicate_part_2")) return false;
    if (!nextTokenIs(b, MATCH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, MATCH);
    r = r && match_predicate_part_2_1(b, l + 1);
    r = r && match_predicate_part_2_2(b, l + 1);
    r = r && table_subquery(b, l + 1);
    exit_section_(b, m, MATCH_PREDICATE_PART_2, r);
    return r;
  }

  // [ UNIQUE ]
  private static boolean match_predicate_part_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "match_predicate_part_2_1")) return false;
    consumeToken(b, UNIQUE);
    return true;
  }

  // [ SIMPLE | PARTIAL | FULL ]
  private static boolean match_predicate_part_2_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "match_predicate_part_2_2")) return false;
    match_predicate_part_2_2_0(b, l + 1);
    return true;
  }

  // SIMPLE | PARTIAL | FULL
  private static boolean match_predicate_part_2_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "match_predicate_part_2_2_0")) return false;
    boolean r;
    r = consumeToken(b, SIMPLE);
    if (!r) r = consumeToken(b, PARTIAL);
    if (!r) r = consumeToken(b, FULL);
    return r;
  }

  /* ********************************************************** */
  // FULL | PARTIAL | SIMPLE
  public static boolean match_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "match_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MATCH_TYPE, "<match type>");
    r = consumeToken(b, FULL);
    if (!r) r = consumeToken(b, PARTIAL);
    if (!r) r = consumeToken(b, SIMPLE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean maximum_dynamic_result_sets(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "maximum_dynamic_result_sets")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, MAXIMUM_DYNAMIC_RESULT_SETS, r);
    return r;
  }

  /* ********************************************************** */
  // <attribute definition>
  public static boolean member(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member")) return false;
    if (!nextTokenIs(b, _ATTRIBUTE_DEFINITION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = attribute_definition(b, l + 1);
    exit_section_(b, m, MEMBER, r);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <member> [ { <comma> <member> }... ] <right paren>
  public static boolean member_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && member(b, l + 1);
    r = r && member_list_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, MEMBER_LIST, r);
    return r;
  }

  // [ { <comma> <member> }... ]
  private static boolean member_list_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_list_2")) return false;
    member_list_2_0(b, l + 1);
    return true;
  }

  // <comma> <member>
  private static boolean member_list_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_list_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && member(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <member name alternatives> [ <data type list> ]
  public static boolean member_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_name")) return false;
    if (!nextTokenIs(b, _MEMBER_NAME_ALTERNATIVES_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = member_name_alternatives(b, l + 1);
    r = r && member_name_1(b, l + 1);
    exit_section_(b, m, MEMBER_NAME, r);
    return r;
  }

  // [ <data type list> ]
  private static boolean member_name_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_name_1")) return false;
    data_type_list(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <schema qualified routine name> | <method name>
  public static boolean member_name_alternatives(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_name_alternatives")) return false;
    if (!nextTokenIs(b, "<member name alternatives>", _METHOD_NAME_, _SCHEMA_QUALIFIED_ROUTINE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MEMBER_NAME_ALTERNATIVES, "<member name alternatives>");
    r = schema_qualified_routine_name(b, l + 1);
    if (!r) r = method_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <member predicate part 2>
  public static boolean member_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && member_predicate_part_2(b, l + 1);
    exit_section_(b, m, MEMBER_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // [ NOT ] MEMBER [ OF ] <multiset value expression>
  public static boolean member_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_predicate_part_2")) return false;
    if (!nextTokenIs(b, "<member predicate part 2>", MEMBER, NOT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MEMBER_PREDICATE_PART_2, "<member predicate part 2>");
    r = member_predicate_part_2_0(b, l + 1);
    r = r && consumeToken(b, MEMBER);
    r = r && member_predicate_part_2_2(b, l + 1);
    r = r && multiset_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ NOT ]
  private static boolean member_predicate_part_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_predicate_part_2_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ OF ]
  private static boolean member_predicate_part_2_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "member_predicate_part_2_2")) return false;
    consumeToken(b, OF);
    return true;
  }

  /* ********************************************************** */
  // <correlation name>
  public static boolean merge_correlation_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_correlation_name")) return false;
    if (!nextTokenIs(b, _CORRELATION_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = correlation_name(b, l + 1);
    exit_section_(b, m, MERGE_CORRELATION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // INSERT [ <left paren> <insert column list> <right paren> ]
  // 		[ <override clause> ] VALUES <merge insert value list>
  public static boolean merge_insert_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_insert_specification")) return false;
    if (!nextTokenIs(b, INSERT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, INSERT);
    r = r && merge_insert_specification_1(b, l + 1);
    r = r && merge_insert_specification_2(b, l + 1);
    r = r && consumeTokens(b, 0, VALUES, _MERGE_INSERT_VALUE_LIST_);
    exit_section_(b, m, MERGE_INSERT_SPECIFICATION, r);
    return r;
  }

  // [ <left paren> <insert column list> <right paren> ]
  private static boolean merge_insert_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_insert_specification_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // [ <override clause> ]
  private static boolean merge_insert_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_insert_specification_2")) return false;
    override_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <value expression> | <contextually typed value specification>
  public static boolean merge_insert_value_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_insert_value_element")) return false;
    if (!nextTokenIs(b, "<merge insert value element>", _CONTEXTUALLY_TYPED_VALUE_SPECIFICATION_, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MERGE_INSERT_VALUE_ELEMENT, "<merge insert value element>");
    r = value_expression(b, l + 1);
    if (!r) r = contextually_typed_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <merge insert value element> [ { <comma> <merge insert value element> }... ] <right paren>
  public static boolean merge_insert_value_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_insert_value_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && merge_insert_value_element(b, l + 1);
    r = r && merge_insert_value_list_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, MERGE_INSERT_VALUE_LIST, r);
    return r;
  }

  // [ { <comma> <merge insert value element> }... ]
  private static boolean merge_insert_value_list_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_insert_value_list_2")) return false;
    merge_insert_value_list_2_0(b, l + 1);
    return true;
  }

  // <comma> <merge insert value element>
  private static boolean merge_insert_value_list_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_insert_value_list_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && merge_insert_value_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <merge when clause>...
  public static boolean merge_operation_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_operation_specification")) return false;
    if (!nextTokenIs(b, _MERGE_WHEN_CLAUSE____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _MERGE_WHEN_CLAUSE____);
    exit_section_(b, m, MERGE_OPERATION_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // MERGE INTO <target table> [ [ AS ] <merge correlation name> ]
  // 		USING <table reference> ON <search condition> <merge operation specification>
  public static boolean merge_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_statement")) return false;
    if (!nextTokenIs(b, MERGE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, MERGE, INTO, _TARGET_TABLE_);
    r = r && merge_statement_3(b, l + 1);
    r = r && consumeTokens(b, 0, USING, _TABLE_REFERENCE_, ON, _SEARCH_CONDITION_, _MERGE_OPERATION_SPECIFICATION_);
    exit_section_(b, m, MERGE_STATEMENT, r);
    return r;
  }

  // [ [ AS ] <merge correlation name> ]
  private static boolean merge_statement_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_statement_3")) return false;
    merge_statement_3_0(b, l + 1);
    return true;
  }

  // [ AS ] <merge correlation name>
  private static boolean merge_statement_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_statement_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = merge_statement_3_0_0(b, l + 1);
    r = r && merge_correlation_name(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean merge_statement_3_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_statement_3_0_0")) return false;
    consumeToken(b, AS);
    return true;
  }

  /* ********************************************************** */
  // UPDATE SET <set clause list>
  public static boolean merge_update_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_update_specification")) return false;
    if (!nextTokenIs(b, UPDATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UPDATE, SET, _SET_CLAUSE_LIST_);
    exit_section_(b, m, MERGE_UPDATE_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <merge when matched clause> | <merge when not matched clause>
  public static boolean merge_when_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_when_clause")) return false;
    if (!nextTokenIs(b, "<merge when clause>", _MERGE_WHEN_MATCHED_CLAUSE_, _MERGE_WHEN_NOT_MATCHED_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MERGE_WHEN_CLAUSE, "<merge when clause>");
    r = merge_when_matched_clause(b, l + 1);
    if (!r) r = merge_when_not_matched_clause(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // WHEN MATCHED THEN <merge update specification>
  public static boolean merge_when_matched_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_when_matched_clause")) return false;
    if (!nextTokenIs(b, WHEN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WHEN, MATCHED, THEN, _MERGE_UPDATE_SPECIFICATION_);
    exit_section_(b, m, MERGE_WHEN_MATCHED_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // WHEN NOT MATCHED THEN <merge insert specification>
  public static boolean merge_when_not_matched_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "merge_when_not_matched_clause")) return false;
    if (!nextTokenIs(b, WHEN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WHEN, NOT, MATCHED, THEN, _MERGE_INSERT_SPECIFICATION_);
    exit_section_(b, m, MERGE_WHEN_NOT_MATCHED_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <language clause>
  // 	|	<parameter style clause>
  // 	|	<deterministic characteristic>
  // 	|	<SQL-data access indication>
  // 	|	<null-call clause>
  public static boolean method_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_characteristic")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_CHARACTERISTIC, "<method characteristic>");
    r = language_clause(b, l + 1);
    if (!r) r = parameter_style_clause(b, l + 1);
    if (!r) r = deterministic_characteristic(b, l + 1);
    if (!r) r = SQL_data_access_indication(b, l + 1);
    if (!r) r = null_call_clause(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <method characteristic>...
  public static boolean method_characteristics(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_characteristics")) return false;
    if (!nextTokenIs(b, _METHOD_CHARACTERISTIC____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _METHOD_CHARACTERISTIC____);
    exit_section_(b, m, METHOD_CHARACTERISTICS, r);
    return r;
  }

  /* ********************************************************** */
  // <direct invocation> | <generalized invocation>
  public static boolean method_invocation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_invocation")) return false;
    if (!nextTokenIs(b, "<method invocation>", _DIRECT_INVOCATION_, _GENERALIZED_INVOCATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_INVOCATION, "<method invocation>");
    r = direct_invocation(b, l + 1);
    if (!r) r = generalized_invocation(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean method_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, METHOD_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary> <dereference operator> <method name> <SQL argument list>
  public static boolean method_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_reference")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    r = r && dereference_operator(b, l + 1);
    r = r && method_name(b, l + 1);
    r = r && SQL_argument_list(b, l + 1);
    exit_section_(b, m, METHOD_REFERENCE, r);
    return r;
  }

  /* ********************************************************** */
  // <routine invocation>
  public static boolean method_selection(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_selection")) return false;
    if (!nextTokenIs(b, _ROUTINE_INVOCATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = routine_invocation(b, l + 1);
    exit_section_(b, m, METHOD_SELECTION, r);
    return r;
  }

  /* ********************************************************** */
  // <original method specification> | <overriding method specification>
  public static boolean method_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification")) return false;
    if (!nextTokenIs(b, "<method specification>", _ORIGINAL_METHOD_SPECIFICATION_, _OVERRIDING_METHOD_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_SPECIFICATION, "<method specification>");
    r = original_method_specification(b, l + 1);
    if (!r) r = overriding_method_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SPECIFIC METHOD <specific method name>
  // 	|	[ INSTANCE | STATIC | CONSTRUCTOR ] METHOD <method name> <SQL parameter declaration list>
  // 		[ <returns clause> ] FOR <schema-resolved user-defined type name>
  public static boolean method_specification_designator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification_designator")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_SPECIFICATION_DESIGNATOR, "<method specification designator>");
    r = parseTokens(b, 0, SPECIFIC, METHOD, _SPECIFIC_METHOD_NAME_);
    if (!r) r = method_specification_designator_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ INSTANCE | STATIC | CONSTRUCTOR ] METHOD <method name> <SQL parameter declaration list>
  // 		[ <returns clause> ] FOR <schema-resolved user-defined type name>
  private static boolean method_specification_designator_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification_designator_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = method_specification_designator_1_0(b, l + 1);
    r = r && consumeTokens(b, 0, METHOD, _METHOD_NAME_, _SQL_PARAMETER_DECLARATION_LIST_);
    r = r && method_specification_designator_1_4(b, l + 1);
    r = r && consumeTokens(b, 0, FOR, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ INSTANCE | STATIC | CONSTRUCTOR ]
  private static boolean method_specification_designator_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification_designator_1_0")) return false;
    method_specification_designator_1_0_0(b, l + 1);
    return true;
  }

  // INSTANCE | STATIC | CONSTRUCTOR
  private static boolean method_specification_designator_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification_designator_1_0_0")) return false;
    boolean r;
    r = consumeToken(b, INSTANCE);
    if (!r) r = consumeToken(b, STATIC);
    if (!r) r = consumeToken(b, CONSTRUCTOR);
    return r;
  }

  // [ <returns clause> ]
  private static boolean method_specification_designator_1_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification_designator_1_4")) return false;
    returns_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <method specification> [ { <comma> <method specification> }... ]
  public static boolean method_specification_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification_list")) return false;
    if (!nextTokenIs(b, _METHOD_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = method_specification(b, l + 1);
    r = r && method_specification_list_1(b, l + 1);
    exit_section_(b, m, METHOD_SPECIFICATION_LIST, r);
    return r;
  }

  // [ { <comma> <method specification> }... ]
  private static boolean method_specification_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification_list_1")) return false;
    method_specification_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <method specification>
  private static boolean method_specification_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "method_specification_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && method_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // -
  public static boolean minus_sign(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, MINUS_SIGN, true);
    return true;
  }

  /* ********************************************************** */
  // <datetime value>
  public static boolean minutes_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "minutes_value")) return false;
    if (!nextTokenIs(b, _DATETIME_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = datetime_value(b, l + 1);
    exit_section_(b, m, MINUTES_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // SCHEMA <schema name>
  // 	|	AUTHORIZATION <module authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
  // 	|	SCHEMA <schema name> AUTHORIZATION <module authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
  public static boolean module_authorization_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause")) return false;
    if (!nextTokenIs(b, "<module authorization clause>", AUTHORIZATION, SCHEMA)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MODULE_AUTHORIZATION_CLAUSE, "<module authorization clause>");
    r = parseTokens(b, 0, SCHEMA, _SCHEMA_NAME_);
    if (!r) r = module_authorization_clause_1(b, l + 1);
    if (!r) r = module_authorization_clause_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // AUTHORIZATION <module authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
  private static boolean module_authorization_clause_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, AUTHORIZATION, _MODULE_AUTHORIZATION_IDENTIFIER_);
    r = r && module_authorization_clause_1_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ FOR STATIC { ONLY | AND DYNAMIC } ]
  private static boolean module_authorization_clause_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause_1_2")) return false;
    module_authorization_clause_1_2_0(b, l + 1);
    return true;
  }

  // FOR STATIC { ONLY | AND DYNAMIC }
  private static boolean module_authorization_clause_1_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause_1_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FOR, STATIC);
    r = r && module_authorization_clause_1_2_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ONLY | AND DYNAMIC
  private static boolean module_authorization_clause_1_2_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause_1_2_0_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ONLY);
    if (!r) r = parseTokens(b, 0, AND, DYNAMIC);
    exit_section_(b, m, null, r);
    return r;
  }

  // SCHEMA <schema name> AUTHORIZATION <module authorization identifier> [ FOR STATIC { ONLY | AND DYNAMIC } ]
  private static boolean module_authorization_clause_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SCHEMA, _SCHEMA_NAME_, AUTHORIZATION, _MODULE_AUTHORIZATION_IDENTIFIER_);
    r = r && module_authorization_clause_2_4(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ FOR STATIC { ONLY | AND DYNAMIC } ]
  private static boolean module_authorization_clause_2_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause_2_4")) return false;
    module_authorization_clause_2_4_0(b, l + 1);
    return true;
  }

  // FOR STATIC { ONLY | AND DYNAMIC }
  private static boolean module_authorization_clause_2_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause_2_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FOR, STATIC);
    r = r && module_authorization_clause_2_4_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ONLY | AND DYNAMIC
  private static boolean module_authorization_clause_2_4_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_clause_2_4_0_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ONLY);
    if (!r) r = parseTokens(b, 0, AND, DYNAMIC);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <authorization identifier>
  public static boolean module_authorization_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_authorization_identifier")) return false;
    if (!nextTokenIs(b, _AUTHORIZATION_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = authorization_identifier(b, l + 1);
    exit_section_(b, m, MODULE_AUTHORIZATION_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // NAMES ARE <character set specification>
  public static boolean module_character_set_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_character_set_specification")) return false;
    if (!nextTokenIs(b, NAMES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NAMES, ARE, _CHARACTER_SET_SPECIFICATION_);
    exit_section_(b, m, MODULE_CHARACTER_SET_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // COLLATION <collation name> [ FOR <character set specification list> ]
  public static boolean module_collation_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_collation_specification")) return false;
    if (!nextTokenIs(b, COLLATION)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, COLLATION, _COLLATION_NAME_);
    r = r && module_collation_specification_2(b, l + 1);
    exit_section_(b, m, MODULE_COLLATION_SPECIFICATION, r);
    return r;
  }

  // [ FOR <character set specification list> ]
  private static boolean module_collation_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_collation_specification_2")) return false;
    parseTokens(b, 0, FOR, _CHARACTER_SET_SPECIFICATION_LIST_);
    return true;
  }

  /* ********************************************************** */
  // <module collation specification>...
  public static boolean module_collations(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_collations")) return false;
    if (!nextTokenIs(b, _MODULE_COLLATION_SPECIFICATION____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _MODULE_COLLATION_SPECIFICATION____);
    exit_section_(b, m, MODULE_COLLATIONS, r);
    return r;
  }

  /* ********************************************************** */
  // <declare cursor>
  // 	|	<dynamic declare cursor>
  // 	|	<externally-invoked procedure>
  public static boolean module_contents(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_contents")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MODULE_CONTENTS, "<module contents>");
    r = declare_cursor(b, l + 1);
    if (!r) r = dynamic_declare_cursor(b, l + 1);
    if (!r) r = externally_invoked_procedure(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // MODULE [ <SQL-client module name> ] [ <module character set specification> ]
  public static boolean module_name_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_name_clause")) return false;
    if (!nextTokenIs(b, MODULE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, MODULE);
    r = r && module_name_clause_1(b, l + 1);
    r = r && module_name_clause_2(b, l + 1);
    exit_section_(b, m, MODULE_NAME_CLAUSE, r);
    return r;
  }

  // [ <SQL-client module name> ]
  private static boolean module_name_clause_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_name_clause_1")) return false;
    SQL_client_module_name(b, l + 1);
    return true;
  }

  // [ <module character set specification> ]
  private static boolean module_name_clause_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_name_clause_2")) return false;
    module_character_set_specification(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <path specification>
  public static boolean module_path_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_path_specification")) return false;
    if (!nextTokenIs(b, _PATH_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = path_specification(b, l + 1);
    exit_section_(b, m, MODULE_PATH_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <transform group specification>
  public static boolean module_transform_group_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "module_transform_group_specification")) return false;
    if (!nextTokenIs(b, _TRANSFORM_GROUP_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = transform_group_specification(b, l + 1);
    exit_section_(b, m, MODULE_TRANSFORM_GROUP_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // MOD <left paren> <numeric value expression dividend> <comma> <numeric value expression divisor><right paren>
  public static boolean modulus_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "modulus_expression")) return false;
    if (!nextTokenIs(b, MOD)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, MOD, _LEFT_PAREN_, _NUMERIC_VALUE_EXPRESSION_DIVIDEND_, _COMMA_, _NUMERIC_VALUE_EXPRESSION_DIVISOR_, _RIGHT_PAREN_);
    exit_section_(b, m, MODULUS_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <datetime value>
  public static boolean months_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "months_value")) return false;
    if (!nextTokenIs(b, _DATETIME_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = datetime_value(b, l + 1);
    exit_section_(b, m, MONTHS_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <set target list> <equals operator> <assigned row>
  public static boolean multiple_column_assignment(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiple_column_assignment")) return false;
    if (!nextTokenIs(b, _SET_TARGET_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = set_target_list(b, l + 1);
    r = r && equals_operator(b, l + 1);
    r = r && assigned_row(b, l + 1);
    exit_section_(b, m, MULTIPLE_COLUMN_ASSIGNMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <group specification> [ { <comma> <group specification> }... ]
  public static boolean multiple_group_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiple_group_specification")) return false;
    if (!nextTokenIs(b, _GROUP_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = group_specification(b, l + 1);
    r = r && multiple_group_specification_1(b, l + 1);
    exit_section_(b, m, MULTIPLE_GROUP_SPECIFICATION, r);
    return r;
  }

  // [ { <comma> <group specification> }... ]
  private static boolean multiple_group_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiple_group_specification_1")) return false;
    multiple_group_specification_1_0(b, l + 1);
    return true;
  }

  // <comma> <group specification>
  private static boolean multiple_group_specification_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiple_group_specification_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && group_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // K | M | G
  public static boolean multiplier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiplier")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MULTIPLIER, "<multiplier>");
    r = consumeToken(b, K);
    if (!r) r = consumeToken(b, M);
    if (!r) r = consumeToken(b, G);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  public static boolean multiset_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_element")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    exit_section_(b, m, MULTISET_ELEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <multiset element> [ { <comma> <multiset element> } ]
  public static boolean multiset_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_element_list")) return false;
    if (!nextTokenIs(b, _MULTISET_ELEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = multiset_element(b, l + 1);
    r = r && multiset_element_list_1(b, l + 1);
    exit_section_(b, m, MULTISET_ELEMENT_LIST, r);
    return r;
  }

  // [ { <comma> <multiset element> } ]
  private static boolean multiset_element_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_element_list_1")) return false;
    multiset_element_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <multiset element>
  private static boolean multiset_element_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_element_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && multiset_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // ELEMENT <left paren> <multset value expression> <right paren>
  public static boolean multiset_element_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_element_reference")) return false;
    if (!nextTokenIs(b, ELEMENT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ELEMENT, _LEFT_PAREN_, _MULTSET_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, MULTISET_ELEMENT_REFERENCE, r);
    return r;
  }

  /* ********************************************************** */
  // <multiset value function> | <value expression primary>
  public static boolean multiset_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_primary")) return false;
    if (!nextTokenIs(b, "<multiset primary>", _MULTISET_VALUE_FUNCTION_, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MULTISET_PRIMARY, "<multiset primary>");
    r = multiset_value_function(b, l + 1);
    if (!r) r = value_expression_primary(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SET <left paren> <multiset value expression> <right paren>
  public static boolean multiset_set_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_set_function")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, _LEFT_PAREN_, _MULTISET_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, MULTISET_SET_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <multiset primary>
  // 	|	<multiset term> MULTISET INTERSECT [ ALL | DISTINCT ] <multiset primary>
  public static boolean multiset_term(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_term")) return false;
    if (!nextTokenIs(b, "<multiset term>", _MULTISET_PRIMARY_, _MULTISET_TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MULTISET_TERM, "<multiset term>");
    r = multiset_primary(b, l + 1);
    if (!r) r = multiset_term_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <multiset term> MULTISET INTERSECT [ ALL | DISTINCT ] <multiset primary>
  private static boolean multiset_term_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_term_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = multiset_term(b, l + 1);
    r = r && consumeTokens(b, 0, MULTISET, INTERSECT);
    r = r && multiset_term_1_3(b, l + 1);
    r = r && multiset_primary(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ALL | DISTINCT ]
  private static boolean multiset_term_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_term_1_3")) return false;
    multiset_term_1_3_0(b, l + 1);
    return true;
  }

  // ALL | DISTINCT
  private static boolean multiset_term_1_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_term_1_3_0")) return false;
    boolean r;
    r = consumeToken(b, ALL);
    if (!r) r = consumeToken(b, DISTINCT);
    return r;
  }

  /* ********************************************************** */
  // <data type> MULTISET
  public static boolean multiset_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_type")) return false;
    if (!nextTokenIs(b, _DATA_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    r = r && consumeToken(b, MULTISET);
    exit_section_(b, m, MULTISET_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // <multiset value constructor by enumeration>
  // 	|	<multiset value constructor by query>
  // 	|	<table value constructor by query>
  public static boolean multiset_value_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_constructor")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MULTISET_VALUE_CONSTRUCTOR, "<multiset value constructor>");
    r = multiset_value_constructor_by_enumeration(b, l + 1);
    if (!r) r = multiset_value_constructor_by_query(b, l + 1);
    if (!r) r = table_value_constructor_by_query(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // MULTISET <left bracket or trigraph> <multiset element list> <right bracket or trigraph>
  public static boolean multiset_value_constructor_by_enumeration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_constructor_by_enumeration")) return false;
    if (!nextTokenIs(b, MULTISET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, MULTISET, _LEFT_BRACKET_OR_TRIGRAPH_, _MULTISET_ELEMENT_LIST_, _RIGHT_BRACKET_OR_TRIGRAPH_);
    exit_section_(b, m, MULTISET_VALUE_CONSTRUCTOR_BY_ENUMERATION, r);
    return r;
  }

  /* ********************************************************** */
  // MULTISET <left paren> <query expression> <right paren>
  public static boolean multiset_value_constructor_by_query(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_constructor_by_query")) return false;
    if (!nextTokenIs(b, MULTISET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, MULTISET, _LEFT_PAREN_, _QUERY_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, MULTISET_VALUE_CONSTRUCTOR_BY_QUERY, r);
    return r;
  }

  /* ********************************************************** */
  // <multiset term>
  // 	|	<multiset value expression> MULTISET UNION [ ALL | DISTINCT ] <multiset term>
  // 	|	<multiset value expression> MULTISET EXCEPT [ ALL | DISTINCT ] <multiset term>
  public static boolean multiset_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_expression")) return false;
    if (!nextTokenIs(b, "<multiset value expression>", _MULTISET_TERM_, _MULTISET_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MULTISET_VALUE_EXPRESSION, "<multiset value expression>");
    r = multiset_term(b, l + 1);
    if (!r) r = multiset_value_expression_1(b, l + 1);
    if (!r) r = multiset_value_expression_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <multiset value expression> MULTISET UNION [ ALL | DISTINCT ] <multiset term>
  private static boolean multiset_value_expression_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_expression_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = multiset_value_expression(b, l + 1);
    r = r && consumeTokens(b, 0, MULTISET, UNION);
    r = r && multiset_value_expression_1_3(b, l + 1);
    r = r && multiset_term(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ALL | DISTINCT ]
  private static boolean multiset_value_expression_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_expression_1_3")) return false;
    multiset_value_expression_1_3_0(b, l + 1);
    return true;
  }

  // ALL | DISTINCT
  private static boolean multiset_value_expression_1_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_expression_1_3_0")) return false;
    boolean r;
    r = consumeToken(b, ALL);
    if (!r) r = consumeToken(b, DISTINCT);
    return r;
  }

  // <multiset value expression> MULTISET EXCEPT [ ALL | DISTINCT ] <multiset term>
  private static boolean multiset_value_expression_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_expression_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = multiset_value_expression(b, l + 1);
    r = r && consumeTokens(b, 0, MULTISET, EXCEPT);
    r = r && multiset_value_expression_2_3(b, l + 1);
    r = r && multiset_term(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ALL | DISTINCT ]
  private static boolean multiset_value_expression_2_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_expression_2_3")) return false;
    multiset_value_expression_2_3_0(b, l + 1);
    return true;
  }

  // ALL | DISTINCT
  private static boolean multiset_value_expression_2_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_expression_2_3_0")) return false;
    boolean r;
    r = consumeToken(b, ALL);
    if (!r) r = consumeToken(b, DISTINCT);
    return r;
  }

  /* ********************************************************** */
  // <multiset set function>
  public static boolean multiset_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "multiset_value_function")) return false;
    if (!nextTokenIs(b, _MULTISET_SET_FUNCTION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = multiset_set_function(b, l + 1);
    exit_section_(b, m, MULTISET_VALUE_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <mutated target> <period> <method name>
  public static boolean mutated_set_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "mutated_set_clause")) return false;
    if (!nextTokenIs(b, _MUTATED_TARGET_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = mutated_target(b, l + 1);
    r = r && period(b, l + 1);
    r = r && method_name(b, l + 1);
    exit_section_(b, m, MUTATED_SET_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <object column> | <mutated set clause>
  public static boolean mutated_target(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "mutated_target")) return false;
    if (!nextTokenIs(b, "<mutated target>", _MUTATED_SET_CLAUSE_, _OBJECT_COLUMN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MUTATED_TARGET, "<mutated target>");
    r = object_column(b, l + 1);
    if (!r) r = mutated_set_clause(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // USING <left paren> <join column list> <right paren>
  public static boolean named_columns_join(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "named_columns_join")) return false;
    if (!nextTokenIs(b, USING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, USING, _LEFT_PAREN_, _JOIN_COLUMN_LIST_, _RIGHT_PAREN_);
    exit_section_(b, m, NAMED_COLUMNS_JOIN, r);
    return r;
  }

  /* ********************************************************** */
  // N <quote> [ <character representation>... ] <quote>
  // 		[ { <separator> <quote> [ <character representation>... ] <quote> }... ]
  public static boolean national_character_string_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_literal")) return false;
    if (!nextTokenIs(b, N)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, N, _QUOTE_);
    r = r && national_character_string_literal_2(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && national_character_string_literal_4(b, l + 1);
    exit_section_(b, m, NATIONAL_CHARACTER_STRING_LITERAL, r);
    return r;
  }

  // [ <character representation>... ]
  private static boolean national_character_string_literal_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_literal_2")) return false;
    consumeToken(b, _CHARACTER_REPRESENTATION____);
    return true;
  }

  // [ { <separator> <quote> [ <character representation>... ] <quote> }... ]
  private static boolean national_character_string_literal_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_literal_4")) return false;
    national_character_string_literal_4_0(b, l + 1);
    return true;
  }

  // <separator> <quote> [ <character representation>... ] <quote>
  private static boolean national_character_string_literal_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_literal_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = separator(b, l + 1);
    r = r && quote(b, l + 1);
    r = r && national_character_string_literal_4_0_2(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <character representation>... ]
  private static boolean national_character_string_literal_4_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_literal_4_0_2")) return false;
    consumeToken(b, _CHARACTER_REPRESENTATION____);
    return true;
  }

  /* ********************************************************** */
  // NATIONAL CHARACTER [ <left paren> <length> <right paren> ]
  // 	|	NATIONAL CHAR [ <left paren> <length> <right paren> ]
  // 	|	NCHAR [ <left paren> <length> <right paren> ]
  // 	|	NATIONAL CHARACTER VARYING <left paren> <length> <right paren>
  // 	|	NATIONAL CHAR VARYING <left paren> <length> <right paren>
  // 	|	NCHAR VARYING <left paren> <length> <right paren>
  // 	|	NATIONAL CHARACTER LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  // 	|	NCHAR LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  // 	|	NCLOB [ <left paren> <large object length> <right paren> ]
  public static boolean national_character_string_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NATIONAL_CHARACTER_STRING_TYPE, "<national character string type>");
    r = national_character_string_type_0(b, l + 1);
    if (!r) r = national_character_string_type_1(b, l + 1);
    if (!r) r = national_character_string_type_2(b, l + 1);
    if (!r) r = parseTokens(b, 0, NATIONAL, CHARACTER, VARYING, _LEFT_PAREN_, _LENGTH_, _RIGHT_PAREN_);
    if (!r) r = parseTokens(b, 0, NATIONAL, CHAR, VARYING, _LEFT_PAREN_, _LENGTH_, _RIGHT_PAREN_);
    if (!r) r = parseTokens(b, 0, NCHAR, VARYING, _LEFT_PAREN_, _LENGTH_, _RIGHT_PAREN_);
    if (!r) r = national_character_string_type_6(b, l + 1);
    if (!r) r = national_character_string_type_7(b, l + 1);
    if (!r) r = national_character_string_type_8(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // NATIONAL CHARACTER [ <left paren> <length> <right paren> ]
  private static boolean national_character_string_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NATIONAL, CHARACTER);
    r = r && national_character_string_type_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <length> <right paren> ]
  private static boolean national_character_string_type_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_0_2")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // NATIONAL CHAR [ <left paren> <length> <right paren> ]
  private static boolean national_character_string_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NATIONAL, CHAR);
    r = r && national_character_string_type_1_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <length> <right paren> ]
  private static boolean national_character_string_type_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_1_2")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // NCHAR [ <left paren> <length> <right paren> ]
  private static boolean national_character_string_type_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NCHAR);
    r = r && national_character_string_type_2_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <length> <right paren> ]
  private static boolean national_character_string_type_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_2_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // NATIONAL CHARACTER LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  private static boolean national_character_string_type_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_6")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NATIONAL, CHARACTER, LARGE, OBJECT);
    r = r && national_character_string_type_6_4(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <large object length> <right paren> ]
  private static boolean national_character_string_type_6_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_6_4")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // NCHAR LARGE OBJECT [ <left paren> <large object length> <right paren> ]
  private static boolean national_character_string_type_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_7")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NCHAR, LARGE, OBJECT);
    r = r && national_character_string_type_7_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <large object length> <right paren> ]
  private static boolean national_character_string_type_7_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_7_3")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // NCLOB [ <left paren> <large object length> <right paren> ]
  private static boolean national_character_string_type_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_8")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NCLOB);
    r = r && national_character_string_type_8_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <large object length> <right paren> ]
  private static boolean national_character_string_type_8_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "national_character_string_type_8_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <table reference> NATURAL [ <join type> ] JOIN <table primary>
  public static boolean natural_join(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "natural_join")) return false;
    if (!nextTokenIs(b, _TABLE_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_reference(b, l + 1);
    r = r && consumeToken(b, NATURAL);
    r = r && natural_join_2(b, l + 1);
    r = r && consumeTokens(b, 0, JOIN, _TABLE_PRIMARY_);
    exit_section_(b, m, NATURAL_JOIN, r);
    return r;
  }

  // [ <join type> ]
  private static boolean natural_join_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "natural_join_2")) return false;
    join_type(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // LN <left paren> <numeric value expression> <right paren>
  public static boolean natural_logarithm(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "natural_logarithm")) return false;
    if (!nextTokenIs(b, LN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, LN, _LEFT_PAREN_, _NUMERIC_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, NATURAL_LOGARITHM, r);
    return r;
  }

  /* ********************************************************** */
  // WITH NESTING | WITHOUT NESTING
  public static boolean nesting_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "nesting_option")) return false;
    if (!nextTokenIs(b, "<nesting option>", WITH, WITHOUT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NESTING_OPTION, "<nesting option>");
    r = parseTokens(b, 0, WITH, NESTING);
    if (!r) r = parseTokens(b, 0, WITHOUT, NESTING);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <method invocation> | <routine invocation>
  public static boolean new_invocation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "new_invocation")) return false;
    if (!nextTokenIs(b, "<new invocation>", _METHOD_INVOCATION_, _ROUTINE_INVOCATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NEW_INVOCATION, "<new invocation>");
    r = method_invocation(b, l + 1);
    if (!r) r = routine_invocation(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // NEW <routine invocation>
  public static boolean new_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "new_specification")) return false;
    if (!nextTokenIs(b, NEW)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NEW, _ROUTINE_INVOCATION_);
    exit_section_(b, m, NEW_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <correlation name>
  public static boolean new_values_correlation_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "new_values_correlation_name")) return false;
    if (!nextTokenIs(b, _CORRELATION_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = correlation_name(b, l + 1);
    exit_section_(b, m, NEW_VALUES_CORRELATION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean new_values_table_alias(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "new_values_table_alias")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, NEW_VALUES_TABLE_ALIAS, r);
    return r;
  }

  /* ********************************************************** */
  // <window name>
  public static boolean new_window_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "new_window_name")) return false;
    if (!nextTokenIs(b, _WINDOW_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_name(b, l + 1);
    exit_section_(b, m, NEW_WINDOW_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // NEXT VALUE FOR <sequence generator name>
  public static boolean next_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "next_value_expression")) return false;
    if (!nextTokenIs(b, NEXT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NEXT, VALUE, FOR, _SEQUENCE_GENERATOR_NAME_);
    exit_section_(b, m, NEXT_VALUE_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  public static boolean non_cycle_mark_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_cycle_mark_value")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    exit_section_(b, m, NON_CYCLE_MARK_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean non_escaped_character(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, NON_ESCAPED_CHARACTER, true);
    return true;
  }

  /* ********************************************************** */
  // <non-join query term>
  // 	|	<query expression body> UNION [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
  // 	|	<query expression body> EXCEPT [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
  public static boolean non_join_query_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression")) return false;
    if (!nextTokenIs(b, "<non join query expression>", _NON_JOIN_QUERY_TERM_, _QUERY_EXPRESSION_BODY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NON_JOIN_QUERY_EXPRESSION, "<non join query expression>");
    r = non_join_query_term(b, l + 1);
    if (!r) r = non_join_query_expression_1(b, l + 1);
    if (!r) r = non_join_query_expression_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <query expression body> UNION [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
  private static boolean non_join_query_expression_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = query_expression_body(b, l + 1);
    r = r && consumeToken(b, UNION);
    r = r && non_join_query_expression_1_2(b, l + 1);
    r = r && non_join_query_expression_1_3(b, l + 1);
    r = r && query_term(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ALL | DISTINCT ]
  private static boolean non_join_query_expression_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression_1_2")) return false;
    non_join_query_expression_1_2_0(b, l + 1);
    return true;
  }

  // ALL | DISTINCT
  private static boolean non_join_query_expression_1_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression_1_2_0")) return false;
    boolean r;
    r = consumeToken(b, ALL);
    if (!r) r = consumeToken(b, DISTINCT);
    return r;
  }

  // [ <corresponding spec> ]
  private static boolean non_join_query_expression_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression_1_3")) return false;
    corresponding_spec(b, l + 1);
    return true;
  }

  // <query expression body> EXCEPT [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
  private static boolean non_join_query_expression_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = query_expression_body(b, l + 1);
    r = r && consumeToken(b, EXCEPT);
    r = r && non_join_query_expression_2_2(b, l + 1);
    r = r && non_join_query_expression_2_3(b, l + 1);
    r = r && query_term(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ALL | DISTINCT ]
  private static boolean non_join_query_expression_2_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression_2_2")) return false;
    non_join_query_expression_2_2_0(b, l + 1);
    return true;
  }

  // ALL | DISTINCT
  private static boolean non_join_query_expression_2_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression_2_2_0")) return false;
    boolean r;
    r = consumeToken(b, ALL);
    if (!r) r = consumeToken(b, DISTINCT);
    return r;
  }

  // [ <corresponding spec> ]
  private static boolean non_join_query_expression_2_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_expression_2_3")) return false;
    corresponding_spec(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <simple table> | <left paren> <non-join query expression> <right paren>
  public static boolean non_join_query_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_primary")) return false;
    if (!nextTokenIs(b, "<non join query primary>", _LEFT_PAREN_, _SIMPLE_TABLE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NON_JOIN_QUERY_PRIMARY, "<non join query primary>");
    r = simple_table(b, l + 1);
    if (!r) r = left_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <non-join query primary>
  // 	|	<query term> INTERSECT [ ALL | DISTINCT ] [ <corresponding spec> ] <query primary>
  public static boolean non_join_query_term(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_term")) return false;
    if (!nextTokenIs(b, "<non join query term>", _NON_JOIN_QUERY_PRIMARY_, _QUERY_TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NON_JOIN_QUERY_TERM, "<non join query term>");
    r = non_join_query_primary(b, l + 1);
    if (!r) r = non_join_query_term_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <query term> INTERSECT [ ALL | DISTINCT ] [ <corresponding spec> ] <query primary>
  private static boolean non_join_query_term_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_term_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = query_term(b, l + 1);
    r = r && consumeToken(b, INTERSECT);
    r = r && non_join_query_term_1_2(b, l + 1);
    r = r && non_join_query_term_1_3(b, l + 1);
    r = r && query_primary(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ALL | DISTINCT ]
  private static boolean non_join_query_term_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_term_1_2")) return false;
    non_join_query_term_1_2_0(b, l + 1);
    return true;
  }

  // ALL | DISTINCT
  private static boolean non_join_query_term_1_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_term_1_2_0")) return false;
    boolean r;
    r = consumeToken(b, ALL);
    if (!r) r = consumeToken(b, DISTINCT);
    return r;
  }

  // [ <corresponding spec> ]
  private static boolean non_join_query_term_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_join_query_term_1_3")) return false;
    corresponding_spec(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // A
  // 	|	ABS
  // 	|	ABSOLUTE
  // 	|	ACTION
  // 	|	ADA
  // 	|	ADMIN
  // 	|	AFTER
  // 	|	ALWAYS
  // 	|	ASC
  // 	|	ASSERTION
  // 	|	ASSIGNMENT
  // 	|	ATTRIBUTE
  // 	|	ATTRIBUTES
  // 	|	AVG
  // 	|	BEFORE
  // 	|	BERNOULLI
  // 	|	BREADTH
  // 	|	C
  // 	|	CARDINALITY
  // 	|	CASCADE
  // 	|	CATALOG
  // 	|	CATALOG_NAME
  // 	|	CEIL
  // 	|	CEILING
  // 	|	CHAIN
  // 	|	CHARACTERISTICS
  // 	|	CHARACTERS
  // 	|	CHARACTER_LENGTH
  // 	|	CHARACTER_SET_CATALOG
  // 	|	CHARACTER_SET_NAME
  // 	|	CHARACTER_SET_SCHEMA
  // 	|	CHAR_LENGTH
  // 	|	CHECKED
  // 	|	CLASS_ORIGIN
  // 	|	COALESCE
  // 	|	COBOL
  // 	|	CODE_UNITS
  // 	|	COLLATION
  // 	|	COLLATION_CATALOG
  // 	|	COLLATION_NAME
  // 	|	COLLATION_SCHEMA
  // 	|	COLLECT
  // 	|	COLUMN_NAME
  // 	|	COMMAND_FUNCTION
  // 	|	COMMAND_FUNCTION_CODE
  // 	|	COMMITTED
  // 	|	CONDITION
  // 	|	CONDITION_NUMBER
  // 	|	CONNECTION_NAME
  // 	|	CONSTRAINTS
  // 	|	CONSTRAINT_CATALOG
  // 	|	CONSTRAINT_NAME
  // 	|	CONSTRAINT_SCHEMA
  // 	|	CONSTRUCTORS
  // 	|	CONTAINS
  // 	|	CONVERT
  // 	|	CORR
  // 	|	COUNT
  // 	|	COVAR_POP
  // 	|	COVAR_SAMP
  // 	|	CUME_DIST
  // 	|	CURRENT_COLLATION
  // 	|	CURSOR_NAME
  // 	|	DATA
  // 	|	DATETIME_INTERVAL_CODE
  // 	|	DATETIME_INTERVAL_PRECISION
  // 	|	DEFAULTS
  // 	|	DEFERRABLE
  // 	|	DEFERRED
  // 	|	DEFINED
  // 	|	DEFINER
  // 	|	DEGREE
  // 	|	DENSE_RANK
  // 	|	DEPTH
  // 	|	DERIVED
  // 	|	DESC
  // 	|	DESCRIPTOR
  // 	|	DIAGNOSTICS
  // 	|	DISPATCH
  // 	|	DOMAIN
  // 	|	DYNAMIC_FUNCTION
  // 	|	DYNAMIC_FUNCTION_CODE
  // 	|	EQUALS
  // 	|	EVERY
  // 	|	EXCEPTION
  // 	|	EXCLUDE
  // 	|	EXCLUDING
  // 	|	EXP
  // 	|	EXTRACT
  // 	|	FINAL
  // 	|	FIRST
  // 	|	FLOOR
  // 	|	FOLLOWING
  // 	|	FORTRAN
  // 	|	FOUND
  // 	|	FUSION
  // 	|	G
  // 	|	GENERAL
  // 	|	GO
  // 	|	GOTO
  // 	|	GRANTED
  // 	|	HIERARCHY
  // 	|	IMPLEMENTATION
  // 	|	INCLUDING
  // 	|	INCREMENT
  // 	|	INITIALLY
  // 	|	INSTANCE
  // 	|	INSTANTIABLE
  // 	|	INTERSECTION
  // 	|	INVOKER
  // 	|	ISOLATION
  // 	|	K
  // 	|	KEY
  // 	|	KEY_MEMBER
  // 	|	KEY_TYPE
  // 	|	LAST
  // 	|	LENGTH
  // 	|	LEVEL
  // 	|	LN
  // 	|	LOCATOR
  // 	|	LOWER
  // 	|	M
  // 	|	MAP
  // 	|	MATCHED
  // 	|	MAX
  // 	|	MAXVALUE
  // 	|	MESSAGE_LENGTH
  // 	|	MESSAGE_OCTET_LENGTH
  // 	|	MESSAGE_TEXT
  // 	|	MIN
  // 	|	MINVALUE
  // 	|	MOD
  // 	|	MORE
  // 	|	MUMPS
  // 	|	NAME
  // 	|	NAMES
  // 	|	NESTING
  // 	|	NEXT
  // 	|	NORMALIZE
  // 	|	NORMALIZED
  // 	|	NULLABLE
  // 	|	NULLIF
  // 	|	NULLS
  // 	|	NUMBER
  // 	|	OBJECT
  // 	|	OCTETS
  // 	|	OCTET_LENGTH
  // 	|	OPTION
  // 	|	OPTIONS
  // 	|	ORDERING
  // 	|	ORDINALITY
  // 	|	OTHERS
  // 	|	OVERLAY
  // 	|	OVERRIDING
  // 	|	PAD
  // 	|	PARAMETER_MODE
  // 	|	PARAMETER_NAME
  // 	|	PARAMETER_ORDINAL_POSITION
  // 	|	PARAMETER_SPECIFIC_CATALOG
  // 	|	PARAMETER_SPECIFIC_NAME
  // 	|	PARAMETER_SPECIFIC_SCHEMA
  // 	|	PARTIAL
  // 	|	PASCAL
  // 	|	PATH
  // 	|	PERCENTILE_CONT
  // 	|	PERCENTILE_DISC
  // 	|	PERCENT_RANK
  // 	|	PLACING
  // 	|	PLI
  // 	|	POSITION
  // 	|	POWER
  // 	|	PRECEDING
  // 	|	PRESERVE
  // 	|	PRIOR
  // 	|	PRIVILEGES
  // 	|	PUBLIC
  // 	|	RANK
  // 	|	READ
  // 	|	RELATIVE
  // 	|	REPEATABLE
  // 	|	RESTART
  // 	|	RETURNED_CARDINALITY
  // 	|	RETURNED_LENGTH
  // 	|	RETURNED_OCTET_LENGTH
  // 	|	RETURNED_SQLSTATE
  // 	|	ROLE
  // 	|	ROUTINE
  // 	|	ROUTINE_CATALOG
  // 	|	ROUTINE_NAME
  // 	|	ROUTINE_SCHEMA
  // 	|	ROW_COUNT
  // 	|	ROW_NUMBER
  // 	|	SCALE
  // 	|	SCHEMA
  // 	|	SCHEMA_NAME
  // 	|	SCOPE_CATALOG
  // 	|	SCOPE_NAME
  // 	|	SCOPE_SCHEMA
  // 	|	SECTION
  // 	|	SECURITY
  // 	|	SELF
  // 	|	SEQUENCE
  // 	|	SERIALIZABLE
  // 	|	SERVER_NAME
  // 	|	SESSION
  // 	|	SETS
  // 	|	SIMPLE
  // 	|	SIZE
  // 	|	SOURCE
  // 	|	SPACE
  // 	|	SPECIFIC_NAME
  // 	|	SQRT
  // 	|	STATE
  // 	|	STATEMENT
  // 	|	STDDEV_POP
  // 	|	STDDEV_SAMP
  // 	|	STRUCTURE
  // 	|	STYLE
  // 	|	SUBCLASS_ORIGIN
  // 	|	SUBSTRING
  // 	|	SUM
  // 	|	TABLESAMPLE
  // 	|	TABLE_NAME
  // 	|	TEMPORARY
  // 	|	TIES
  // 	|	TOP_LEVEL_COUNT
  // 	|	TRANSACTION
  // 	|	TRANSACTIONS_COMMITTED
  // 	|	TRANSACTIONS_ROLLED_BACK
  // 	|	TRANSACTION_ACTIVE
  // 	|	TRANSFORM
  // 	|	TRANSFORMS
  // 	|	TRANSLATE
  // 	|	TRIGGER_CATALOG
  // 	|	TRIGGER_NAME
  // 	|	TRIGGER_SCHEMA
  // 	|	TRIM
  // 	|	TYPE
  // 	|	UNBOUNDED
  // 	|	UNCOMMITTED
  // 	|	UNDER
  // 	|	UNNAMED
  // 	|	USAGE
  // 	|	USER_DEFINED_TYPE_CATALOG
  // 	|	USER_DEFINED_TYPE_CODE
  // 	|	USER_DEFINED_TYPE_NAME
  // 	|	USER_DEFINED_TYPE_SCHEMA
  // 	|	VIEW
  // 	|	WORK
  // 	|	WRITE
  // 	|	ZONE
  public static boolean non_reserved_word(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_reserved_word")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NON_RESERVED_WORD, "<non reserved word>");
    r = consumeToken(b, A);
    if (!r) r = consumeToken(b, ABS);
    if (!r) r = consumeToken(b, ABSOLUTE);
    if (!r) r = consumeToken(b, ACTION);
    if (!r) r = consumeToken(b, ADA);
    if (!r) r = consumeToken(b, ADMIN);
    if (!r) r = consumeToken(b, AFTER);
    if (!r) r = consumeToken(b, ALWAYS);
    if (!r) r = consumeToken(b, ASC);
    if (!r) r = consumeToken(b, ASSERTION);
    if (!r) r = consumeToken(b, ASSIGNMENT);
    if (!r) r = consumeToken(b, ATTRIBUTE);
    if (!r) r = consumeToken(b, ATTRIBUTES);
    if (!r) r = consumeToken(b, AVG);
    if (!r) r = consumeToken(b, BEFORE);
    if (!r) r = consumeToken(b, BERNOULLI);
    if (!r) r = consumeToken(b, BREADTH);
    if (!r) r = consumeToken(b, C);
    if (!r) r = consumeToken(b, CARDINALITY);
    if (!r) r = consumeToken(b, CASCADE);
    if (!r) r = consumeToken(b, CATALOG);
    if (!r) r = consumeToken(b, CATALOG_NAME);
    if (!r) r = consumeToken(b, CEIL);
    if (!r) r = consumeToken(b, CEILING);
    if (!r) r = consumeToken(b, CHAIN);
    if (!r) r = consumeToken(b, CHARACTERISTICS);
    if (!r) r = consumeToken(b, CHARACTERS);
    if (!r) r = consumeToken(b, CHARACTER_LENGTH);
    if (!r) r = consumeToken(b, CHARACTER_SET_CATALOG);
    if (!r) r = consumeToken(b, CHARACTER_SET_NAME);
    if (!r) r = consumeToken(b, CHARACTER_SET_SCHEMA);
    if (!r) r = consumeToken(b, CHAR_LENGTH);
    if (!r) r = consumeToken(b, CHECKED);
    if (!r) r = consumeToken(b, CLASS_ORIGIN);
    if (!r) r = consumeToken(b, COALESCE);
    if (!r) r = consumeToken(b, COBOL);
    if (!r) r = consumeToken(b, CODE_UNITS);
    if (!r) r = consumeToken(b, COLLATION);
    if (!r) r = consumeToken(b, COLLATION_CATALOG);
    if (!r) r = consumeToken(b, COLLATION_NAME);
    if (!r) r = consumeToken(b, COLLATION_SCHEMA);
    if (!r) r = consumeToken(b, COLLECT);
    if (!r) r = consumeToken(b, COLUMN_NAME);
    if (!r) r = consumeToken(b, COMMAND_FUNCTION);
    if (!r) r = consumeToken(b, COMMAND_FUNCTION_CODE);
    if (!r) r = consumeToken(b, COMMITTED);
    if (!r) r = consumeToken(b, CONDITION);
    if (!r) r = consumeToken(b, CONDITION_NUMBER);
    if (!r) r = consumeToken(b, CONNECTION_NAME);
    if (!r) r = consumeToken(b, CONSTRAINTS);
    if (!r) r = consumeToken(b, CONSTRAINT_CATALOG);
    if (!r) r = consumeToken(b, CONSTRAINT_NAME);
    if (!r) r = consumeToken(b, CONSTRAINT_SCHEMA);
    if (!r) r = consumeToken(b, CONSTRUCTORS);
    if (!r) r = consumeToken(b, CONTAINS);
    if (!r) r = consumeToken(b, CONVERT);
    if (!r) r = consumeToken(b, CORR);
    if (!r) r = consumeToken(b, COUNT);
    if (!r) r = consumeToken(b, COVAR_POP);
    if (!r) r = consumeToken(b, COVAR_SAMP);
    if (!r) r = consumeToken(b, CUME_DIST);
    if (!r) r = consumeToken(b, CURRENT_COLLATION);
    if (!r) r = consumeToken(b, CURSOR_NAME);
    if (!r) r = consumeToken(b, DATA);
    if (!r) r = consumeToken(b, DATETIME_INTERVAL_CODE);
    if (!r) r = consumeToken(b, DATETIME_INTERVAL_PRECISION);
    if (!r) r = consumeToken(b, DEFAULTS);
    if (!r) r = consumeToken(b, DEFERRABLE);
    if (!r) r = consumeToken(b, DEFERRED);
    if (!r) r = consumeToken(b, DEFINED);
    if (!r) r = consumeToken(b, DEFINER);
    if (!r) r = consumeToken(b, DEGREE);
    if (!r) r = consumeToken(b, DENSE_RANK);
    if (!r) r = consumeToken(b, DEPTH);
    if (!r) r = consumeToken(b, DERIVED);
    if (!r) r = consumeToken(b, DESC);
    if (!r) r = consumeToken(b, DESCRIPTOR);
    if (!r) r = consumeToken(b, DIAGNOSTICS);
    if (!r) r = consumeToken(b, DISPATCH);
    if (!r) r = consumeToken(b, DOMAIN);
    if (!r) r = consumeToken(b, DYNAMIC_FUNCTION);
    if (!r) r = consumeToken(b, DYNAMIC_FUNCTION_CODE);
    if (!r) r = consumeToken(b, EQUALS);
    if (!r) r = consumeToken(b, EVERY);
    if (!r) r = consumeToken(b, EXCEPTION);
    if (!r) r = consumeToken(b, EXCLUDE);
    if (!r) r = consumeToken(b, EXCLUDING);
    if (!r) r = consumeToken(b, EXP);
    if (!r) r = consumeToken(b, EXTRACT);
    if (!r) r = consumeToken(b, FINAL);
    if (!r) r = consumeToken(b, FIRST);
    if (!r) r = consumeToken(b, FLOOR);
    if (!r) r = consumeToken(b, FOLLOWING);
    if (!r) r = consumeToken(b, FORTRAN);
    if (!r) r = consumeToken(b, FOUND);
    if (!r) r = consumeToken(b, FUSION);
    if (!r) r = consumeToken(b, G);
    if (!r) r = consumeToken(b, GENERAL);
    if (!r) r = consumeToken(b, GO);
    if (!r) r = consumeToken(b, GOTO);
    if (!r) r = consumeToken(b, GRANTED);
    if (!r) r = consumeToken(b, HIERARCHY);
    if (!r) r = consumeToken(b, IMPLEMENTATION);
    if (!r) r = consumeToken(b, INCLUDING);
    if (!r) r = consumeToken(b, INCREMENT);
    if (!r) r = consumeToken(b, INITIALLY);
    if (!r) r = consumeToken(b, INSTANCE);
    if (!r) r = consumeToken(b, INSTANTIABLE);
    if (!r) r = consumeToken(b, INTERSECTION);
    if (!r) r = consumeToken(b, INVOKER);
    if (!r) r = consumeToken(b, ISOLATION);
    if (!r) r = consumeToken(b, K);
    if (!r) r = consumeToken(b, KEY);
    if (!r) r = consumeToken(b, KEY_MEMBER);
    if (!r) r = consumeToken(b, KEY_TYPE);
    if (!r) r = consumeToken(b, LAST);
    if (!r) r = consumeToken(b, LENGTH);
    if (!r) r = consumeToken(b, LEVEL);
    if (!r) r = consumeToken(b, LN);
    if (!r) r = consumeToken(b, LOCATOR);
    if (!r) r = consumeToken(b, LOWER);
    if (!r) r = consumeToken(b, M);
    if (!r) r = consumeToken(b, MAP);
    if (!r) r = consumeToken(b, MATCHED);
    if (!r) r = consumeToken(b, MAX);
    if (!r) r = consumeToken(b, MAXVALUE);
    if (!r) r = consumeToken(b, MESSAGE_LENGTH);
    if (!r) r = consumeToken(b, MESSAGE_OCTET_LENGTH);
    if (!r) r = consumeToken(b, MESSAGE_TEXT);
    if (!r) r = consumeToken(b, MIN);
    if (!r) r = consumeToken(b, MINVALUE);
    if (!r) r = consumeToken(b, MOD);
    if (!r) r = consumeToken(b, MORE);
    if (!r) r = consumeToken(b, MUMPS);
    if (!r) r = consumeToken(b, NAME);
    if (!r) r = consumeToken(b, NAMES);
    if (!r) r = consumeToken(b, NESTING);
    if (!r) r = consumeToken(b, NEXT);
    if (!r) r = consumeToken(b, NORMALIZE);
    if (!r) r = consumeToken(b, NORMALIZED);
    if (!r) r = consumeToken(b, NULLABLE);
    if (!r) r = consumeToken(b, NULLIF);
    if (!r) r = consumeToken(b, NULLS);
    if (!r) r = consumeToken(b, NUMBER);
    if (!r) r = consumeToken(b, OBJECT);
    if (!r) r = consumeToken(b, OCTETS);
    if (!r) r = consumeToken(b, OCTET_LENGTH);
    if (!r) r = consumeToken(b, OPTION);
    if (!r) r = consumeToken(b, OPTIONS);
    if (!r) r = consumeToken(b, ORDERING);
    if (!r) r = consumeToken(b, ORDINALITY);
    if (!r) r = consumeToken(b, OTHERS);
    if (!r) r = consumeToken(b, OVERLAY);
    if (!r) r = consumeToken(b, OVERRIDING);
    if (!r) r = consumeToken(b, PAD);
    if (!r) r = consumeToken(b, PARAMETER_MODE);
    if (!r) r = consumeToken(b, PARAMETER_NAME);
    if (!r) r = consumeToken(b, PARAMETER_ORDINAL_POSITION);
    if (!r) r = consumeToken(b, PARAMETER_SPECIFIC_CATALOG);
    if (!r) r = consumeToken(b, PARAMETER_SPECIFIC_NAME);
    if (!r) r = consumeToken(b, PARAMETER_SPECIFIC_SCHEMA);
    if (!r) r = consumeToken(b, PARTIAL);
    if (!r) r = consumeToken(b, PASCAL);
    if (!r) r = consumeToken(b, PATH);
    if (!r) r = consumeToken(b, PERCENTILE_CONT);
    if (!r) r = consumeToken(b, PERCENTILE_DISC);
    if (!r) r = consumeToken(b, PERCENT_RANK);
    if (!r) r = consumeToken(b, PLACING);
    if (!r) r = consumeToken(b, PLI);
    if (!r) r = consumeToken(b, POSITION);
    if (!r) r = consumeToken(b, POWER);
    if (!r) r = consumeToken(b, PRECEDING);
    if (!r) r = consumeToken(b, PRESERVE);
    if (!r) r = consumeToken(b, PRIOR);
    if (!r) r = consumeToken(b, PRIVILEGES);
    if (!r) r = consumeToken(b, PUBLIC);
    if (!r) r = consumeToken(b, RANK);
    if (!r) r = consumeToken(b, READ);
    if (!r) r = consumeToken(b, RELATIVE);
    if (!r) r = consumeToken(b, REPEATABLE);
    if (!r) r = consumeToken(b, RESTART);
    if (!r) r = consumeToken(b, RETURNED_CARDINALITY);
    if (!r) r = consumeToken(b, RETURNED_LENGTH);
    if (!r) r = consumeToken(b, RETURNED_OCTET_LENGTH);
    if (!r) r = consumeToken(b, RETURNED_SQLSTATE);
    if (!r) r = consumeToken(b, ROLE);
    if (!r) r = consumeToken(b, ROUTINE);
    if (!r) r = consumeToken(b, ROUTINE_CATALOG);
    if (!r) r = consumeToken(b, ROUTINE_NAME);
    if (!r) r = consumeToken(b, ROUTINE_SCHEMA);
    if (!r) r = consumeToken(b, ROW_COUNT);
    if (!r) r = consumeToken(b, ROW_NUMBER);
    if (!r) r = consumeToken(b, SCALE);
    if (!r) r = consumeToken(b, SCHEMA);
    if (!r) r = consumeToken(b, SCHEMA_NAME);
    if (!r) r = consumeToken(b, SCOPE_CATALOG);
    if (!r) r = consumeToken(b, SCOPE_NAME);
    if (!r) r = consumeToken(b, SCOPE_SCHEMA);
    if (!r) r = consumeToken(b, SECTION);
    if (!r) r = consumeToken(b, SECURITY);
    if (!r) r = consumeToken(b, SELF);
    if (!r) r = consumeToken(b, SEQUENCE);
    if (!r) r = consumeToken(b, SERIALIZABLE);
    if (!r) r = consumeToken(b, SERVER_NAME);
    if (!r) r = consumeToken(b, SESSION);
    if (!r) r = consumeToken(b, SETS);
    if (!r) r = consumeToken(b, SIMPLE);
    if (!r) r = consumeToken(b, SIZE);
    if (!r) r = consumeToken(b, SOURCE);
    if (!r) r = consumeToken(b, SPACE);
    if (!r) r = consumeToken(b, SPECIFIC_NAME);
    if (!r) r = consumeToken(b, SQRT);
    if (!r) r = consumeToken(b, STATE);
    if (!r) r = consumeToken(b, STATEMENT);
    if (!r) r = consumeToken(b, STDDEV_POP);
    if (!r) r = consumeToken(b, STDDEV_SAMP);
    if (!r) r = consumeToken(b, STRUCTURE);
    if (!r) r = consumeToken(b, STYLE);
    if (!r) r = consumeToken(b, SUBCLASS_ORIGIN);
    if (!r) r = consumeToken(b, SUBSTRING);
    if (!r) r = consumeToken(b, SUM);
    if (!r) r = consumeToken(b, TABLESAMPLE);
    if (!r) r = consumeToken(b, TABLE_NAME);
    if (!r) r = consumeToken(b, TEMPORARY);
    if (!r) r = consumeToken(b, TIES);
    if (!r) r = consumeToken(b, TOP_LEVEL_COUNT);
    if (!r) r = consumeToken(b, TRANSACTION);
    if (!r) r = consumeToken(b, TRANSACTIONS_COMMITTED);
    if (!r) r = consumeToken(b, TRANSACTIONS_ROLLED_BACK);
    if (!r) r = consumeToken(b, TRANSACTION_ACTIVE);
    if (!r) r = consumeToken(b, TRANSFORM);
    if (!r) r = consumeToken(b, TRANSFORMS);
    if (!r) r = consumeToken(b, TRANSLATE);
    if (!r) r = consumeToken(b, TRIGGER_CATALOG);
    if (!r) r = consumeToken(b, TRIGGER_NAME);
    if (!r) r = consumeToken(b, TRIGGER_SCHEMA);
    if (!r) r = consumeToken(b, TRIM);
    if (!r) r = consumeToken(b, TYPE);
    if (!r) r = consumeToken(b, UNBOUNDED);
    if (!r) r = consumeToken(b, UNCOMMITTED);
    if (!r) r = consumeToken(b, UNDER);
    if (!r) r = consumeToken(b, UNNAMED);
    if (!r) r = consumeToken(b, USAGE);
    if (!r) r = consumeToken(b, USER_DEFINED_TYPE_CATALOG);
    if (!r) r = consumeToken(b, USER_DEFINED_TYPE_CODE);
    if (!r) r = consumeToken(b, USER_DEFINED_TYPE_NAME);
    if (!r) r = consumeToken(b, USER_DEFINED_TYPE_SCHEMA);
    if (!r) r = consumeToken(b, VIEW);
    if (!r) r = consumeToken(b, WORK);
    if (!r) r = consumeToken(b, WRITE);
    if (!r) r = consumeToken(b, ZONE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // YEAR | MONTH | DAY | HOUR | MINUTE
  public static boolean non_second_primary_datetime_field(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "non_second_primary_datetime_field")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NON_SECOND_PRIMARY_DATETIME_FIELD, "<non second primary datetime field>");
    r = consumeToken(b, YEAR);
    if (!r) r = consumeToken(b, MONTH);
    if (!r) r = consumeToken(b, DAY);
    if (!r) r = consumeToken(b, HOUR);
    if (!r) r = consumeToken(b, MINUTE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <regular identifier>
  // 	|	<key word>
  // 	|	<unsigned numeric literal>
  // 	|	<national character string literal>
  // 	|	<bit string literal>
  // 	|	<hex string literal>
  // 	|	<large object length token>
  // 	|	<multiplier>
  public static boolean nondelimiter_token(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "nondelimiter_token")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NONDELIMITER_TOKEN, "<nondelimiter token>");
    r = regular_identifier(b, l + 1);
    if (!r) r = key_word(b, l + 1);
    if (!r) r = unsigned_numeric_literal(b, l + 1);
    if (!r) r = national_character_string_literal(b, l + 1);
    if (!r) r = consumeToken(b, _BIT_STRING_LITERAL_);
    if (!r) r = consumeToken(b, _HEX_STRING_LITERAL_);
    if (!r) r = large_object_length_token(b, l + 1);
    if (!r) r = multiplier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean nondoublequote_character(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, NONDOUBLEQUOTE_CHARACTER, true);
    return true;
  }

  /* ********************************************************** */
  // <unsigned value specification>
  // 	|	<column reference>
  // 	|	<set function specification>
  // 	|	<window function>
  // 	|	<scalar subquery>
  // 	|	<case expression>
  // 	|	<cast specification>
  // 	|	<field reference>
  // 	|	<subtype treatment>
  // 	|	<method invocation>
  // 	|	<static method invocation>
  // 	|	<new specification>
  // 	|	<attribute or method reference>
  // 	|	<reference resolution>
  // 	|	<collection value constructor>
  // 	|	<array element reference>
  // 	|	<multiset element reference>
  // 	|	<routine invocation>
  // 	|	<next value expression>
  public static boolean nonparenthesized_value_expression_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "nonparenthesized_value_expression_primary")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NONPARENTHESIZED_VALUE_EXPRESSION_PRIMARY, "<nonparenthesized value expression primary>");
    r = unsigned_value_specification(b, l + 1);
    if (!r) r = column_reference(b, l + 1);
    if (!r) r = set_function_specification(b, l + 1);
    if (!r) r = window_function(b, l + 1);
    if (!r) r = scalar_subquery(b, l + 1);
    if (!r) r = case_expression(b, l + 1);
    if (!r) r = cast_specification(b, l + 1);
    if (!r) r = field_reference(b, l + 1);
    if (!r) r = subtype_treatment(b, l + 1);
    if (!r) r = method_invocation(b, l + 1);
    if (!r) r = static_method_invocation(b, l + 1);
    if (!r) r = new_specification(b, l + 1);
    if (!r) r = attribute_or_method_reference(b, l + 1);
    if (!r) r = reference_resolution(b, l + 1);
    if (!r) r = collection_value_constructor(b, l + 1);
    if (!r) r = array_element_reference(b, l + 1);
    if (!r) r = multiset_element_reference(b, l + 1);
    if (!r) r = routine_invocation(b, l + 1);
    if (!r) r = next_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean nonquote_character(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, NONQUOTE_CHARACTER, true);
    return true;
  }

  /* ********************************************************** */
  // NORMALIZE <left paren> <character value expression> <right paren>
  public static boolean normalize_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "normalize_function")) return false;
    if (!nextTokenIs(b, NORMALIZE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NORMALIZE, _LEFT_PAREN_, _CHARACTER_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, NORMALIZE_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <string value expression> IS [ NOT ] NORMALIZED
  public static boolean normalized_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "normalized_predicate")) return false;
    if (!nextTokenIs(b, _STRING_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = string_value_expression(b, l + 1);
    r = r && consumeToken(b, IS);
    r = r && normalized_predicate_2(b, l + 1);
    r = r && consumeToken(b, NORMALIZED);
    exit_section_(b, m, NORMALIZED_PREDICATE, r);
    return r;
  }

  // [ NOT ]
  private static boolean normalized_predicate_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "normalized_predicate_2")) return false;
    consumeToken(b, NOT);
    return true;
  }

  /* ********************************************************** */
  // <less than operator> <greater than operator>
  public static boolean not_equals_operator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "not_equals_operator")) return false;
    if (!nextTokenIs(b, _LESS_THAN_OPERATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = less_than_operator(b, l + 1);
    r = r && greater_than_operator(b, l + 1);
    exit_section_(b, m, NOT_EQUALS_OPERATOR, r);
    return r;
  }

  /* ********************************************************** */
  // NULLS FIRST | NULLS LAST
  public static boolean null_ordering(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "null_ordering")) return false;
    if (!nextTokenIs(b, NULLS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, NULLS, FIRST);
    if (!r) r = parseTokens(b, 0, NULLS, LAST);
    exit_section_(b, m, NULL_ORDERING, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <null predicate part 2>
  public static boolean null_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "null_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && null_predicate_part_2(b, l + 1);
    exit_section_(b, m, NULL_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // IS [ NOT ] NULL
  public static boolean null_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "null_predicate_part_2")) return false;
    if (!nextTokenIs(b, IS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, IS);
    r = r && null_predicate_part_2_1(b, l + 1);
    r = r && consumeToken(b, NULL);
    exit_section_(b, m, NULL_PREDICATE_PART_2, r);
    return r;
  }

  // [ NOT ]
  private static boolean null_predicate_part_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "null_predicate_part_2_1")) return false;
    consumeToken(b, NOT);
    return true;
  }

  /* ********************************************************** */
  // NULL
  public static boolean null_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "null_specification")) return false;
    if (!nextTokenIs(b, NULL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NULL);
    exit_section_(b, m, NULL_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // RETURNS NULL ON NULL INPUT
  // 	|	CALLED ON NULL INPUT
  public static boolean null_call_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "null_call_clause")) return false;
    if (!nextTokenIs(b, "<null call clause>", CALLED, RETURNS)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NULL_CALL_CLAUSE, "<null call clause>");
    r = parseTokens(b, 0, RETURNS, NULL, ON, NULL, INPUT);
    if (!r) r = parseTokens(b, 0, CALLED, ON, NULL, INPUT);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean number_of_conditions(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "number_of_conditions")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, NUMBER_OF_CONDITIONS, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary>
  // 	|	<numeric value function>
  public static boolean numeric_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "numeric_primary")) return false;
    if (!nextTokenIs(b, "<numeric primary>", _NUMERIC_VALUE_FUNCTION_, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NUMERIC_PRIMARY, "<numeric primary>");
    r = value_expression_primary(b, l + 1);
    if (!r) r = numeric_value_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <exact numeric type> | <approximate numeric type>
  public static boolean numeric_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "numeric_type")) return false;
    if (!nextTokenIs(b, "<numeric type>", _APPROXIMATE_NUMERIC_TYPE_, _EXACT_NUMERIC_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NUMERIC_TYPE, "<numeric type>");
    r = exact_numeric_type(b, l + 1);
    if (!r) r = approximate_numeric_type(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <term>
  // 	|	<numeric value expression> <plus sign> <term>
  // 	|	<numeric value expression> <minus sign> <term>
  public static boolean numeric_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "numeric_value_expression")) return false;
    if (!nextTokenIs(b, "<numeric value expression>", _NUMERIC_VALUE_EXPRESSION_, _TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NUMERIC_VALUE_EXPRESSION, "<numeric value expression>");
    r = term(b, l + 1);
    if (!r) r = numeric_value_expression(b, l + 1);
    if (!r) r = numeric_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean numeric_value_expression_base(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "numeric_value_expression_base")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, NUMERIC_VALUE_EXPRESSION_BASE, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean numeric_value_expression_exponent(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "numeric_value_expression_exponent")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, NUMERIC_VALUE_EXPRESSION_EXPONENT, r);
    return r;
  }

  /* ********************************************************** */
  // <position expression>
  // 	|	<extract expression>
  // 	|	<length expression>
  // 	|	<cardinality expression>
  // 	|	<absolute value expression>
  // 	|	<modulus expression>
  // 	|	<natural logarithm>
  // 	|	<exponential function>
  // 	|	<power function>
  // 	|	<square root>
  // 	|	<floor function>
  // 	|	<ceiling function>
  // 	|	<width bucket function>
  public static boolean numeric_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "numeric_value_function")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, NUMERIC_VALUE_FUNCTION, "<numeric value function>");
    r = position_expression(b, l + 1);
    if (!r) r = extract_expression(b, l + 1);
    if (!r) r = length_expression(b, l + 1);
    if (!r) r = cardinality_expression(b, l + 1);
    if (!r) r = absolute_value_expression(b, l + 1);
    if (!r) r = modulus_expression(b, l + 1);
    if (!r) r = natural_logarithm(b, l + 1);
    if (!r) r = exponential_function(b, l + 1);
    if (!r) r = power_function(b, l + 1);
    if (!r) r = square_root(b, l + 1);
    if (!r) r = floor_function(b, l + 1);
    if (!r) r = ceiling_function(b, l + 1);
    if (!r) r = width_bucket_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <column name>
  public static boolean object_column(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "object_column")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    exit_section_(b, m, OBJECT_COLUMN, r);
    return r;
  }

  /* ********************************************************** */
  // [ TABLE ] <table name>
  // 	|	DOMAIN <domain name>
  // 	|	COLLATION <collation name>
  // 	|	CHARACTER SET <character set name>
  // 	|	TRANSLATION <transliteration name>
  // 	|	TYPE <schema-resolved user-defined type name>
  // 	|	SEQUENCE <sequence generator name>
  // 	|	<specific routine designator>
  public static boolean object_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "object_name")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, OBJECT_NAME, "<object name>");
    r = object_name_0(b, l + 1);
    if (!r) r = parseTokens(b, 0, DOMAIN, _DOMAIN_NAME_);
    if (!r) r = parseTokens(b, 0, COLLATION, _COLLATION_NAME_);
    if (!r) r = parseTokens(b, 0, CHARACTER, SET, _CHARACTER_SET_NAME_);
    if (!r) r = parseTokens(b, 0, TRANSLATION, _TRANSLITERATION_NAME_);
    if (!r) r = parseTokens(b, 0, TYPE, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_);
    if (!r) r = parseTokens(b, 0, SEQUENCE, _SEQUENCE_GENERATOR_NAME_);
    if (!r) r = specific_routine_designator(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ TABLE ] <table name>
  private static boolean object_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "object_name_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = object_name_0_0(b, l + 1);
    r = r && table_name(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ TABLE ]
  private static boolean object_name_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "object_name_0_0")) return false;
    consumeToken(b, TABLE);
    return true;
  }

  /* ********************************************************** */
  // ALL PRIVILEGES
  // 	|	<action> [ { <comma> <action> }... ]
  public static boolean object_privileges(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "object_privileges")) return false;
    if (!nextTokenIs(b, "<object privileges>", ALL, _ACTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, OBJECT_PRIVILEGES, "<object privileges>");
    r = parseTokens(b, 0, ALL, PRIVILEGES);
    if (!r) r = object_privileges_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <action> [ { <comma> <action> }... ]
  private static boolean object_privileges_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "object_privileges_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = action(b, l + 1);
    r = r && object_privileges_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <action> }... ]
  private static boolean object_privileges_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "object_privileges_1_1")) return false;
    object_privileges_1_1_0(b, l + 1);
    return true;
  }

  // <comma> <action>
  private static boolean object_privileges_1_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "object_privileges_1_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && action(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean occurrences(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "occurrences")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, OCCURRENCES, r);
    return r;
  }

  /* ********************************************************** */
  // OCTET_LENGTH <left paren> <string value expression> <right paren>
  public static boolean octet_length_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "octet_length_expression")) return false;
    if (!nextTokenIs(b, OCTET_LENGTH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OCTET_LENGTH, _LEFT_PAREN_, _STRING_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, OCTET_LENGTH_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <octet like predicate part 2>
  public static boolean octet_like_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "octet_like_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && octet_like_predicate_part_2(b, l + 1);
    exit_section_(b, m, OCTET_LIKE_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // [ NOT ] LIKE <octet pattern> [ ESCAPE <escape octet> ]
  public static boolean octet_like_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "octet_like_predicate_part_2")) return false;
    if (!nextTokenIs(b, "<octet like predicate part 2>", LIKE, NOT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, OCTET_LIKE_PREDICATE_PART_2, "<octet like predicate part 2>");
    r = octet_like_predicate_part_2_0(b, l + 1);
    r = r && consumeTokens(b, 0, LIKE, _OCTET_PATTERN_);
    r = r && octet_like_predicate_part_2_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ NOT ]
  private static boolean octet_like_predicate_part_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "octet_like_predicate_part_2_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ ESCAPE <escape octet> ]
  private static boolean octet_like_predicate_part_2_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "octet_like_predicate_part_2_3")) return false;
    parseTokens(b, 0, ESCAPE, _ESCAPE_OCTET_);
    return true;
  }

  /* ********************************************************** */
  // <blob value expression>
  public static boolean octet_pattern(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "octet_pattern")) return false;
    if (!nextTokenIs(b, _BLOB_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = blob_value_expression(b, l + 1);
    exit_section_(b, m, OCTET_PATTERN, r);
    return r;
  }

  /* ********************************************************** */
  // OLD [ ROW ] [ AS ] <old values correlation name>
  // 	|	NEW [ ROW ] [ AS ] <new values correlation name>
  // 	|	OLD TABLE [ AS ] <old values table alias>
  // 	|	NEW TABLE [ AS ] <new values table alias>
  public static boolean old_or_new_values_alias(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias")) return false;
    if (!nextTokenIs(b, "<old or new values alias>", NEW, OLD)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, OLD_OR_NEW_VALUES_ALIAS, "<old or new values alias>");
    r = old_or_new_values_alias_0(b, l + 1);
    if (!r) r = old_or_new_values_alias_1(b, l + 1);
    if (!r) r = old_or_new_values_alias_2(b, l + 1);
    if (!r) r = old_or_new_values_alias_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // OLD [ ROW ] [ AS ] <old values correlation name>
  private static boolean old_or_new_values_alias_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, OLD);
    r = r && old_or_new_values_alias_0_1(b, l + 1);
    r = r && old_or_new_values_alias_0_2(b, l + 1);
    r = r && old_values_correlation_name(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ROW ]
  private static boolean old_or_new_values_alias_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_0_1")) return false;
    consumeToken(b, ROW);
    return true;
  }

  // [ AS ]
  private static boolean old_or_new_values_alias_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_0_2")) return false;
    consumeToken(b, AS);
    return true;
  }

  // NEW [ ROW ] [ AS ] <new values correlation name>
  private static boolean old_or_new_values_alias_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NEW);
    r = r && old_or_new_values_alias_1_1(b, l + 1);
    r = r && old_or_new_values_alias_1_2(b, l + 1);
    r = r && new_values_correlation_name(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ ROW ]
  private static boolean old_or_new_values_alias_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_1_1")) return false;
    consumeToken(b, ROW);
    return true;
  }

  // [ AS ]
  private static boolean old_or_new_values_alias_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_1_2")) return false;
    consumeToken(b, AS);
    return true;
  }

  // OLD TABLE [ AS ] <old values table alias>
  private static boolean old_or_new_values_alias_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OLD, TABLE);
    r = r && old_or_new_values_alias_2_2(b, l + 1);
    r = r && old_values_table_alias(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean old_or_new_values_alias_2_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_2_2")) return false;
    consumeToken(b, AS);
    return true;
  }

  // NEW TABLE [ AS ] <new values table alias>
  private static boolean old_or_new_values_alias_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NEW, TABLE);
    r = r && old_or_new_values_alias_3_2(b, l + 1);
    r = r && new_values_table_alias(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean old_or_new_values_alias_3_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_3_2")) return false;
    consumeToken(b, AS);
    return true;
  }

  /* ********************************************************** */
  // <old or new values alias>...
  public static boolean old_or_new_values_alias_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_or_new_values_alias_list")) return false;
    if (!nextTokenIs(b, _OLD_OR_NEW_VALUES_ALIAS____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _OLD_OR_NEW_VALUES_ALIAS____);
    exit_section_(b, m, OLD_OR_NEW_VALUES_ALIAS_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // <correlation name>
  public static boolean old_values_correlation_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_values_correlation_name")) return false;
    if (!nextTokenIs(b, _CORRELATION_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = correlation_name(b, l + 1);
    exit_section_(b, m, OLD_VALUES_CORRELATION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean old_values_table_alias(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "old_values_table_alias")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, OLD_VALUES_TABLE_ALIAS, r);
    return r;
  }

  /* ********************************************************** */
  // ONLY <left paren> <table or query name> <right paren>
  public static boolean only_spec(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "only_spec")) return false;
    if (!nextTokenIs(b, ONLY)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ONLY, _LEFT_PAREN_, _TABLE_OR_QUERY_NAME_, _RIGHT_PAREN_);
    exit_section_(b, m, ONLY_SPEC, r);
    return r;
  }

  /* ********************************************************** */
  // OPEN <cursor name>
  public static boolean open_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "open_statement")) return false;
    if (!nextTokenIs(b, OPEN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OPEN, _CURSOR_NAME_);
    exit_section_(b, m, OPEN_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // ORDER BY <sort specification list>
  public static boolean order_by_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "order_by_clause")) return false;
    if (!nextTokenIs(b, ORDER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ORDER, BY, _SORT_SPECIFICATION_LIST_);
    exit_section_(b, m, ORDER_BY_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <hypothetical set function> | <inverse distribution function>
  public static boolean ordered_set_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ordered_set_function")) return false;
    if (!nextTokenIs(b, "<ordered set function>", _HYPOTHETICAL_SET_FUNCTION_, _INVERSE_DISTRIBUTION_FUNCTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ORDERED_SET_FUNCTION, "<ordered set function>");
    r = hypothetical_set_function(b, l + 1);
    if (!r) r = inverse_distribution_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <relative category> | <map category> | <state category>
  public static boolean ordering_category(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ordering_category")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ORDERING_CATEGORY, "<ordering category>");
    r = relative_category(b, l + 1);
    if (!r) r = map_category(b, l + 1);
    if (!r) r = state_category(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <equals ordering form> | <full ordering form>
  public static boolean ordering_form(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ordering_form")) return false;
    if (!nextTokenIs(b, "<ordering form>", _EQUALS_ORDERING_FORM_, _FULL_ORDERING_FORM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ORDERING_FORM, "<ordering form>");
    r = equals_ordering_form(b, l + 1);
    if (!r) r = full_ordering_form(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ASC | DESC
  public static boolean ordering_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ordering_specification")) return false;
    if (!nextTokenIs(b, "<ordering specification>", ASC, DESC)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ORDERING_SPECIFICATION, "<ordering specification>");
    r = consumeToken(b, ASC);
    if (!r) r = consumeToken(b, DESC);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <grouping column reference>
  // 	|	<left paren> <grouping column reference list> <right paren>
  public static boolean ordinary_grouping_set(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ordinary_grouping_set")) return false;
    if (!nextTokenIs(b, "<ordinary grouping set>", _GROUPING_COLUMN_REFERENCE_, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ORDINARY_GROUPING_SET, "<ordinary grouping set>");
    r = grouping_column_reference(b, l + 1);
    if (!r) r = left_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <ordinary grouping set> [ { <comma> <ordinary grouping set> }... ]
  public static boolean ordinary_grouping_set_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ordinary_grouping_set_list")) return false;
    if (!nextTokenIs(b, _ORDINARY_GROUPING_SET_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = ordinary_grouping_set(b, l + 1);
    r = r && ordinary_grouping_set_list_1(b, l + 1);
    exit_section_(b, m, ORDINARY_GROUPING_SET_LIST, r);
    return r;
  }

  // [ { <comma> <ordinary grouping set> }... ]
  private static boolean ordinary_grouping_set_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ordinary_grouping_set_list_1")) return false;
    ordinary_grouping_set_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <ordinary grouping set>
  private static boolean ordinary_grouping_set_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ordinary_grouping_set_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && ordinary_grouping_set(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <partial method specification> [ SELF AS RESULT ] [ SELF AS LOCATOR ] [ <method characteristics> ]
  public static boolean original_method_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "original_method_specification")) return false;
    if (!nextTokenIs(b, _PARTIAL_METHOD_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = partial_method_specification(b, l + 1);
    r = r && original_method_specification_1(b, l + 1);
    r = r && original_method_specification_2(b, l + 1);
    r = r && original_method_specification_3(b, l + 1);
    exit_section_(b, m, ORIGINAL_METHOD_SPECIFICATION, r);
    return r;
  }

  // [ SELF AS RESULT ]
  private static boolean original_method_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "original_method_specification_1")) return false;
    parseTokens(b, 0, SELF, AS, RESULT);
    return true;
  }

  // [ SELF AS LOCATOR ]
  private static boolean original_method_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "original_method_specification_2")) return false;
    parseTokens(b, 0, SELF, AS, LOCATOR);
    return true;
  }

  // [ <method characteristics> ]
  private static boolean original_method_specification_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "original_method_specification_3")) return false;
    method_characteristics(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // LEFT | RIGHT | FULL
  public static boolean outer_join_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "outer_join_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, OUTER_JOIN_TYPE, "<outer join type>");
    r = consumeToken(b, LEFT);
    if (!r) r = consumeToken(b, RIGHT);
    if (!r) r = consumeToken(b, FULL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <into arguments> | <into descriptor>
  public static boolean output_using_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "output_using_clause")) return false;
    if (!nextTokenIs(b, "<output using clause>", _INTO_ARGUMENTS_, _INTO_DESCRIPTOR_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, OUTPUT_USING_CLAUSE, "<output using clause>");
    r = into_arguments(b, l + 1);
    if (!r) r = into_descriptor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <overlaps predicate part 1> <overlaps predicate part 2>
  public static boolean overlaps_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "overlaps_predicate")) return false;
    if (!nextTokenIs(b, _OVERLAPS_PREDICATE_PART_1_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = overlaps_predicate_part_1(b, l + 1);
    r = r && overlaps_predicate_part_2(b, l + 1);
    exit_section_(b, m, OVERLAPS_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand 1>
  public static boolean overlaps_predicate_part_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "overlaps_predicate_part_1")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_1_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand_1(b, l + 1);
    exit_section_(b, m, OVERLAPS_PREDICATE_PART_1, r);
    return r;
  }

  /* ********************************************************** */
  // OVERLAPS <row value predicand 2>
  public static boolean overlaps_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "overlaps_predicate_part_2")) return false;
    if (!nextTokenIs(b, OVERLAPS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OVERLAPS, _ROW_VALUE_PREDICAND_2_);
    exit_section_(b, m, OVERLAPS_PREDICATE_PART_2, r);
    return r;
  }

  /* ********************************************************** */
  // OVERRIDING USER VALUE | OVERRIDING SYSTEM VALUE
  public static boolean override_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "override_clause")) return false;
    if (!nextTokenIs(b, OVERRIDING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, OVERRIDING, USER, VALUE);
    if (!r) r = parseTokens(b, 0, OVERRIDING, SYSTEM, VALUE);
    exit_section_(b, m, OVERRIDE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // OVERRIDING <partial method specification>
  public static boolean overriding_method_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "overriding_method_specification")) return false;
    if (!nextTokenIs(b, OVERRIDING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OVERRIDING, _PARTIAL_METHOD_SPECIFICATION_);
    exit_section_(b, m, OVERRIDING_METHOD_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // NO PAD | PAD SPACE
  public static boolean pad_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "pad_characteristic")) return false;
    if (!nextTokenIs(b, "<pad characteristic>", NO, PAD)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PAD_CHARACTERISTIC, "<pad characteristic>");
    r = parseTokens(b, 0, NO, PAD);
    if (!r) r = parseTokens(b, 0, PAD, SPACE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // IN | OUT | INOUT
  public static boolean parameter_mode(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "parameter_mode")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PARAMETER_MODE, "<parameter mode>");
    r = consumeToken(b, IN);
    if (!r) r = consumeToken(b, OUT);
    if (!r) r = consumeToken(b, INOUT);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SQL | GENERAL
  public static boolean parameter_style(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "parameter_style")) return false;
    if (!nextTokenIs(b, "<parameter style>", GENERAL, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PARAMETER_STYLE, "<parameter style>");
    r = consumeToken(b, SQL);
    if (!r) r = consumeToken(b, GENERAL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // PARAMETER STYLE <parameter style>
  public static boolean parameter_style_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "parameter_style_clause")) return false;
    if (!nextTokenIs(b, PARAMETER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, PARAMETER, STYLE, _PARAMETER_STYLE_);
    exit_section_(b, m, PARAMETER_STYLE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <data type> [ <locator indication> ]
  public static boolean parameter_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "parameter_type")) return false;
    if (!nextTokenIs(b, _DATA_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    r = r && parameter_type_1(b, l + 1);
    exit_section_(b, m, PARAMETER_TYPE, r);
    return r;
  }

  // [ <locator indication> ]
  private static boolean parameter_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "parameter_type_1")) return false;
    locator_indication(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <input using clause>
  public static boolean parameter_using_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "parameter_using_clause")) return false;
    if (!nextTokenIs(b, _INPUT_USING_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = input_using_clause(b, l + 1);
    exit_section_(b, m, PARAMETER_USING_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <boolean value expression> <right paren>
  public static boolean parenthesized_boolean_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "parenthesized_boolean_value_expression")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && boolean_value_expression(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, PARENTHESIZED_BOOLEAN_VALUE_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <value expression> <right paren>
  public static boolean parenthesized_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "parenthesized_value_expression")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && value_expression(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, PARENTHESIZED_VALUE_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // [ INSTANCE | STATIC | CONSTRUCTOR ] METHOD <method name> <SQL parameter declaration list>
  // 		<returns clause> [ SPECIFIC <specific method name> ]
  public static boolean partial_method_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "partial_method_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PARTIAL_METHOD_SPECIFICATION, "<partial method specification>");
    r = partial_method_specification_0(b, l + 1);
    r = r && consumeTokens(b, 0, METHOD, _METHOD_NAME_, _SQL_PARAMETER_DECLARATION_LIST_, _RETURNS_CLAUSE_);
    r = r && partial_method_specification_5(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ INSTANCE | STATIC | CONSTRUCTOR ]
  private static boolean partial_method_specification_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "partial_method_specification_0")) return false;
    partial_method_specification_0_0(b, l + 1);
    return true;
  }

  // INSTANCE | STATIC | CONSTRUCTOR
  private static boolean partial_method_specification_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "partial_method_specification_0_0")) return false;
    boolean r;
    r = consumeToken(b, INSTANCE);
    if (!r) r = consumeToken(b, STATIC);
    if (!r) r = consumeToken(b, CONSTRUCTOR);
    return r;
  }

  // [ SPECIFIC <specific method name> ]
  private static boolean partial_method_specification_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "partial_method_specification_5")) return false;
    parseTokens(b, 0, SPECIFIC, _SPECIFIC_METHOD_NAME_);
    return true;
  }

  /* ********************************************************** */
  // <column name>
  public static boolean path_column(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "path_column")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    exit_section_(b, m, PATH_COLUMN, r);
    return r;
  }

  /* ********************************************************** */
  // PATH <schema name list>
  public static boolean path_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "path_specification")) return false;
    if (!nextTokenIs(b, PATH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, PATH, _SCHEMA_NAME_LIST_);
    exit_section_(b, m, PATH_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <user-defined type name>
  public static boolean path_resolved_user_defined_type_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "path_resolved_user_defined_type_name")) return false;
    if (!nextTokenIs(b, _USER_DEFINED_TYPE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = user_defined_type_name(b, l + 1);
    exit_section_(b, m, PATH_RESOLVED_USER_DEFINED_TYPE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // %
  public static boolean percent(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, PERCENT, true);
    return true;
  }

  /* ********************************************************** */
  // .
  public static boolean period(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, PERIOD, true);
    return true;
  }

  /* ********************************************************** */
  // +
  public static boolean plus_sign(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, PLUS_SIGN, true);
    return true;
  }

  /* ********************************************************** */
  // <string position expression>
  // 	|	<blob position expression>
  public static boolean position_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "position_expression")) return false;
    if (!nextTokenIs(b, "<position expression>", _BLOB_POSITION_EXPRESSION_, _STRING_POSITION_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, POSITION_EXPRESSION, "<position expression>");
    r = string_position_expression(b, l + 1);
    if (!r) r = blob_position_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // POWER <left paren> <numeric value expression base> <comma> <numeric value expression exponent> <right paren>
  public static boolean power_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "power_function")) return false;
    if (!nextTokenIs(b, POWER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, POWER, _LEFT_PAREN_, _NUMERIC_VALUE_EXPRESSION_BASE_, _COMMA_, _NUMERIC_VALUE_EXPRESSION_EXPONENT_, _RIGHT_PAREN_);
    exit_section_(b, m, POWER_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean precision(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "precision")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, PRECISION, r);
    return r;
  }

  /* ********************************************************** */
  // <character string type> [ CHARACTER SET <character set specification> ] [ <collate clause> ]
  // 	|	<national character string type> [ <collate clause> ]
  // 	|	<binary large object string type>
  // 	|	<numeric type>
  // 	|	<boolean type>
  // 	|	<datetime type>
  // 	|	<interval type>
  public static boolean predefined_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "predefined_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PREDEFINED_TYPE, "<predefined type>");
    r = predefined_type_0(b, l + 1);
    if (!r) r = predefined_type_1(b, l + 1);
    if (!r) r = binary_large_object_string_type(b, l + 1);
    if (!r) r = numeric_type(b, l + 1);
    if (!r) r = boolean_type(b, l + 1);
    if (!r) r = datetime_type(b, l + 1);
    if (!r) r = interval_type(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <character string type> [ CHARACTER SET <character set specification> ] [ <collate clause> ]
  private static boolean predefined_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "predefined_type_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_string_type(b, l + 1);
    r = r && predefined_type_0_1(b, l + 1);
    r = r && predefined_type_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ CHARACTER SET <character set specification> ]
  private static boolean predefined_type_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "predefined_type_0_1")) return false;
    parseTokens(b, 0, CHARACTER, SET, _CHARACTER_SET_SPECIFICATION_);
    return true;
  }

  // [ <collate clause> ]
  private static boolean predefined_type_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "predefined_type_0_2")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  // <national character string type> [ <collate clause> ]
  private static boolean predefined_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "predefined_type_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = national_character_string_type(b, l + 1);
    r = r && predefined_type_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <collate clause> ]
  private static boolean predefined_type_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "predefined_type_1_1")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <comparison predicate>
  // 	|	<between predicate>
  // 	|	<in predicate>
  // 	|	<like predicate>
  // 	|	<similar predicate>
  // 	|	<null predicate>
  // 	|	<quantified comparison predicate>
  // 	|	<exists predicate>
  // 	|	<unique predicate>
  // 	|	<normalized predicate>
  // 	|	<match predicate>
  // 	|	<overlaps predicate>
  // 	|	<distinct predicate>
  // 	|	<member predicate>
  // 	|	<submultiset predicate>
  // 	|	<set predicate>
  // 	|	<type predicate>
  public static boolean predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "predicate")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PREDICATE, "<predicate>");
    r = comparison_predicate(b, l + 1);
    if (!r) r = between_predicate(b, l + 1);
    if (!r) r = in_predicate(b, l + 1);
    if (!r) r = like_predicate(b, l + 1);
    if (!r) r = similar_predicate(b, l + 1);
    if (!r) r = null_predicate(b, l + 1);
    if (!r) r = quantified_comparison_predicate(b, l + 1);
    if (!r) r = exists_predicate(b, l + 1);
    if (!r) r = unique_predicate(b, l + 1);
    if (!r) r = normalized_predicate(b, l + 1);
    if (!r) r = match_predicate(b, l + 1);
    if (!r) r = overlaps_predicate(b, l + 1);
    if (!r) r = distinct_predicate(b, l + 1);
    if (!r) r = member_predicate(b, l + 1);
    if (!r) r = submultiset_predicate(b, l + 1);
    if (!r) r = set_predicate(b, l + 1);
    if (!r) r = type_predicate(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL control statement>
  public static boolean preparable_SQL_control_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_SQL_control_statement")) return false;
    if (!nextTokenIs(b, _SQL_CONTROL_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_control_statement(b, l + 1);
    exit_section_(b, m, PREPARABLE_SQL_CONTROL_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <delete statement searched>
  // 	|	<dynamic single row select statement>
  // 	|	<insert statement>
  // 	|	<dynamic select statement>
  // 	|	<update statement searched>
  // 	|	<merge statement>
  // 	|	<preparable dynamic delete statement positioned>
  // 	|	<preparable dynamic update statement positioned>
  public static boolean preparable_SQL_data_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_SQL_data_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PREPARABLE_SQL_DATA_STATEMENT, "<preparable sql data statement>");
    r = delete_statement_searched(b, l + 1);
    if (!r) r = dynamic_single_row_select_statement(b, l + 1);
    if (!r) r = insert_statement(b, l + 1);
    if (!r) r = dynamic_select_statement(b, l + 1);
    if (!r) r = update_statement_searched(b, l + 1);
    if (!r) r = merge_statement(b, l + 1);
    if (!r) r = preparable_dynamic_delete_statement_positioned(b, l + 1);
    if (!r) r = preparable_dynamic_update_statement_positioned(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <SQL schema statement>
  public static boolean preparable_SQL_schema_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_SQL_schema_statement")) return false;
    if (!nextTokenIs(b, _SQL_SCHEMA_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_schema_statement(b, l + 1);
    exit_section_(b, m, PREPARABLE_SQL_SCHEMA_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <SQL session statement>
  public static boolean preparable_SQL_session_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_SQL_session_statement")) return false;
    if (!nextTokenIs(b, _SQL_SESSION_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_session_statement(b, l + 1);
    exit_section_(b, m, PREPARABLE_SQL_SESSION_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <SQL transaction statement>
  public static boolean preparable_SQL_transaction_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_SQL_transaction_statement")) return false;
    if (!nextTokenIs(b, _SQL_TRANSACTION_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_transaction_statement(b, l + 1);
    exit_section_(b, m, PREPARABLE_SQL_TRANSACTION_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // DELETE [ FROM <target table> ] WHERE CURRENT OF [ <scope option> ] <cursor name>
  public static boolean preparable_dynamic_delete_statement_positioned(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_dynamic_delete_statement_positioned")) return false;
    if (!nextTokenIs(b, DELETE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DELETE);
    r = r && preparable_dynamic_delete_statement_positioned_1(b, l + 1);
    r = r && consumeTokens(b, 0, WHERE, CURRENT, OF);
    r = r && preparable_dynamic_delete_statement_positioned_5(b, l + 1);
    r = r && cursor_name(b, l + 1);
    exit_section_(b, m, PREPARABLE_DYNAMIC_DELETE_STATEMENT_POSITIONED, r);
    return r;
  }

  // [ FROM <target table> ]
  private static boolean preparable_dynamic_delete_statement_positioned_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_dynamic_delete_statement_positioned_1")) return false;
    parseTokens(b, 0, FROM, _TARGET_TABLE_);
    return true;
  }

  // [ <scope option> ]
  private static boolean preparable_dynamic_delete_statement_positioned_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_dynamic_delete_statement_positioned_5")) return false;
    scope_option(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // UPDATE [ <target table> ] SET <set clause list> WHERE CURRENT OF [ <scope option> ] <cursor name>
  public static boolean preparable_dynamic_update_statement_positioned(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_dynamic_update_statement_positioned")) return false;
    if (!nextTokenIs(b, UPDATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, UPDATE);
    r = r && preparable_dynamic_update_statement_positioned_1(b, l + 1);
    r = r && consumeTokens(b, 0, SET, _SET_CLAUSE_LIST_, WHERE, CURRENT, OF);
    r = r && preparable_dynamic_update_statement_positioned_7(b, l + 1);
    r = r && cursor_name(b, l + 1);
    exit_section_(b, m, PREPARABLE_DYNAMIC_UPDATE_STATEMENT_POSITIONED, r);
    return r;
  }

  // [ <target table> ]
  private static boolean preparable_dynamic_update_statement_positioned_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_dynamic_update_statement_positioned_1")) return false;
    target_table(b, l + 1);
    return true;
  }

  // [ <scope option> ]
  private static boolean preparable_dynamic_update_statement_positioned_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_dynamic_update_statement_positioned_7")) return false;
    scope_option(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean preparable_implementation_defined_statement(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, PREPARABLE_IMPLEMENTATION_DEFINED_STATEMENT, true);
    return true;
  }

  /* ********************************************************** */
  // <preparable SQL data statement>
  // 	|	<preparable SQL schema statement>
  // 	|	<preparable SQL transaction statement>
  // 	|	<preparable SQL control statement>
  // 	|	<preparable SQL session statement>
  // 	|	<preparable implementation-defined statement>
  public static boolean preparable_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "preparable_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PREPARABLE_STATEMENT, "<preparable statement>");
    r = preparable_SQL_data_statement(b, l + 1);
    if (!r) r = preparable_SQL_schema_statement(b, l + 1);
    if (!r) r = preparable_SQL_transaction_statement(b, l + 1);
    if (!r) r = preparable_SQL_control_statement(b, l + 1);
    if (!r) r = preparable_SQL_session_statement(b, l + 1);
    if (!r) r = preparable_implementation_defined_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // PREPARE <SQL statement name> [ <attributes specification> ] FROM <SQL statement variable>
  public static boolean prepare_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "prepare_statement")) return false;
    if (!nextTokenIs(b, PREPARE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, PREPARE, _SQL_STATEMENT_NAME_);
    r = r && prepare_statement_2(b, l + 1);
    r = r && consumeTokens(b, 0, FROM, _SQL_STATEMENT_VARIABLE_);
    exit_section_(b, m, PREPARE_STATEMENT, r);
    return r;
  }

  // [ <attributes specification> ]
  private static boolean prepare_statement_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "prepare_statement_2")) return false;
    attributes_specification(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <non-second primary datetime field>
  // 	|	SECOND
  public static boolean primary_datetime_field(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "primary_datetime_field")) return false;
    if (!nextTokenIs(b, "<primary datetime field>", SECOND, _NON_SECOND_PRIMARY_DATETIME_FIELD_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, PRIMARY_DATETIME_FIELD, "<primary datetime field>");
    r = non_second_primary_datetime_field(b, l + 1);
    if (!r) r = consumeToken(b, SECOND);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean privilege_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "privilege_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, PRIVILEGE_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // <specific routine designator> [ { <comma> <specific routine designator> }... ]
  public static boolean privilege_method_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "privilege_method_list")) return false;
    if (!nextTokenIs(b, _SPECIFIC_ROUTINE_DESIGNATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = specific_routine_designator(b, l + 1);
    r = r && privilege_method_list_1(b, l + 1);
    exit_section_(b, m, PRIVILEGE_METHOD_LIST, r);
    return r;
  }

  // [ { <comma> <specific routine designator> }... ]
  private static boolean privilege_method_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "privilege_method_list_1")) return false;
    privilege_method_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <specific routine designator>
  private static boolean privilege_method_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "privilege_method_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && specific_routine_designator(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <object privileges> ON <object name>
  public static boolean privileges(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "privileges")) return false;
    if (!nextTokenIs(b, _OBJECT_PRIVILEGES_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = object_privileges(b, l + 1);
    r = r && consumeTokens(b, 0, ON, _OBJECT_NAME_);
    exit_section_(b, m, PRIVILEGES, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean procedure_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "procedure_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, PROCEDURE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <asterisked identifier chain> <period> <asterisk>
  // 	|	<all fields reference>
  public static boolean qualified_asterisk(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "qualified_asterisk")) return false;
    if (!nextTokenIs(b, "<qualified asterisk>", _ALL_FIELDS_REFERENCE_, _ASTERISKED_IDENTIFIER_CHAIN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, QUALIFIED_ASTERISK, "<qualified asterisk>");
    r = asterisked_identifier_chain(b, l + 1);
    if (!r) r = all_fields_reference(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean qualified_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "qualified_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, QUALIFIED_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // <table reference> [ <join type> ] JOIN <table reference> <join specification>
  public static boolean qualified_join(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "qualified_join")) return false;
    if (!nextTokenIs(b, _TABLE_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_reference(b, l + 1);
    r = r && qualified_join_1(b, l + 1);
    r = r && consumeTokens(b, 0, JOIN, _TABLE_REFERENCE_, _JOIN_SPECIFICATION_);
    exit_section_(b, m, QUALIFIED_JOIN, r);
    return r;
  }

  // [ <join type> ]
  private static boolean qualified_join_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "qualified_join_1")) return false;
    join_type(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <row value predicand> <quantified comparison predicate part 2>
  public static boolean quantified_comparison_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "quantified_comparison_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && quantified_comparison_predicate_part_2(b, l + 1);
    exit_section_(b, m, QUANTIFIED_COMPARISON_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // <comp op> <quantifier> <table subquery>
  public static boolean quantified_comparison_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "quantified_comparison_predicate_part_2")) return false;
    if (!nextTokenIs(b, _COMP_OP_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comp_op(b, l + 1);
    r = r && quantifier(b, l + 1);
    r = r && table_subquery(b, l + 1);
    exit_section_(b, m, QUANTIFIED_COMPARISON_PREDICATE_PART_2, r);
    return r;
  }

  /* ********************************************************** */
  // <all> | <some>
  public static boolean quantifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "quantifier")) return false;
    if (!nextTokenIs(b, "<quantifier>", _ALL_, _SOME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, QUANTIFIER, "<quantifier>");
    r = all(b, l + 1);
    if (!r) r = some(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <with clause> ] <query expression body>
  public static boolean query_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "query_expression")) return false;
    if (!nextTokenIs(b, "<query expression>", _QUERY_EXPRESSION_BODY_, _WITH_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, QUERY_EXPRESSION, "<query expression>");
    r = query_expression_0(b, l + 1);
    r = r && query_expression_body(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <with clause> ]
  private static boolean query_expression_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "query_expression_0")) return false;
    with_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <non-join query expression> | <joined table>
  public static boolean query_expression_body(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "query_expression_body")) return false;
    if (!nextTokenIs(b, "<query expression body>", _JOINED_TABLE_, _NON_JOIN_QUERY_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, QUERY_EXPRESSION_BODY, "<query expression body>");
    r = non_join_query_expression(b, l + 1);
    if (!r) r = joined_table(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean query_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "query_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, QUERY_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <non-join query primary> | <joined table>
  public static boolean query_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "query_primary")) return false;
    if (!nextTokenIs(b, "<query primary>", _JOINED_TABLE_, _NON_JOIN_QUERY_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, QUERY_PRIMARY, "<query primary>");
    r = non_join_query_primary(b, l + 1);
    if (!r) r = joined_table(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SELECT [ <set quantifier> ] <select list> <table expression>
  public static boolean query_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "query_specification")) return false;
    if (!nextTokenIs(b, SELECT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, SELECT);
    r = r && query_specification_1(b, l + 1);
    r = r && select_list(b, l + 1);
    r = r && table_expression(b, l + 1);
    exit_section_(b, m, QUERY_SPECIFICATION, r);
    return r;
  }

  // [ <set quantifier> ]
  private static boolean query_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "query_specification_1")) return false;
    set_quantifier(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <non-join query term> | <joined table>
  public static boolean query_term(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "query_term")) return false;
    if (!nextTokenIs(b, "<query term>", _JOINED_TABLE_, _NON_JOIN_QUERY_TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, QUERY_TERM, "<query term>");
    r = non_join_query_term(b, l + 1);
    if (!r) r = joined_table(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ?
  public static boolean question_mark(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, QUESTION_MARK, true);
    return true;
  }

  /* ********************************************************** */
  // '
  public static boolean quote(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, QUOTE, true);
    return true;
  }

  /* ********************************************************** */
  // <quote><quote>
  public static boolean quote_symbol(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "quote_symbol")) return false;
    if (!nextTokenIs(b, _QUOTE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = quote(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, QUOTE_SYMBOL, r);
    return r;
  }

  /* ********************************************************** */
  // RANK | DENSE_RANK | PERCENT_RANK | CUME_DIST
  public static boolean rank_function_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rank_function_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, RANK_FUNCTION_TYPE, "<rank function type>");
    r = consumeToken(b, RANK);
    if (!r) r = consumeToken(b, DENSE_RANK);
    if (!r) r = consumeToken(b, PERCENT_RANK);
    if (!r) r = consumeToken(b, CUME_DIST);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DEPTH FIRST BY <sort specification list>
  // 	|	BREADTH FIRST BY <sort specification list>
  public static boolean recursive_search_order(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "recursive_search_order")) return false;
    if (!nextTokenIs(b, "<recursive search order>", BREADTH, DEPTH)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, RECURSIVE_SEARCH_ORDER, "<recursive search order>");
    r = parseTokens(b, 0, DEPTH, FIRST, BY, _SORT_SPECIFICATION_LIST_);
    if (!r) r = parseTokens(b, 0, BREADTH, FIRST, BY, _SORT_SPECIFICATION_LIST_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <cast to ref> ] [ <cast to type> ]
  public static boolean ref_cast_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ref_cast_option")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REF_CAST_OPTION, "<ref cast option>");
    r = ref_cast_option_0(b, l + 1);
    r = r && ref_cast_option_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <cast to ref> ]
  private static boolean ref_cast_option_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ref_cast_option_0")) return false;
    cast_to_ref(b, l + 1);
    return true;
  }

  // [ <cast to type> ]
  private static boolean ref_cast_option_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ref_cast_option_1")) return false;
    cast_to_type(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean reference_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, REFERENCE_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // SYSTEM GENERATED | USER GENERATED | DERIVED
  public static boolean reference_generation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_generation")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REFERENCE_GENERATION, "<reference generation>");
    r = parseTokens(b, 0, SYSTEM, GENERATED);
    if (!r) r = parseTokens(b, 0, USER, GENERATED);
    if (!r) r = consumeToken(b, DERIVED);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DEREF <left paren> <reference value expression> <right paren>
  public static boolean reference_resolution(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_resolution")) return false;
    if (!nextTokenIs(b, DEREF)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DEREF, _LEFT_PAREN_, _REFERENCE_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, REFERENCE_RESOLUTION, r);
    return r;
  }

  /* ********************************************************** */
  // REFERENCES ARE [ NOT ] CHECKED [ ON DELETE <reference scope check action> ]
  public static boolean reference_scope_check(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_scope_check")) return false;
    if (!nextTokenIs(b, REFERENCES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, REFERENCES, ARE);
    r = r && reference_scope_check_2(b, l + 1);
    r = r && consumeToken(b, CHECKED);
    r = r && reference_scope_check_4(b, l + 1);
    exit_section_(b, m, REFERENCE_SCOPE_CHECK, r);
    return r;
  }

  // [ NOT ]
  private static boolean reference_scope_check_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_scope_check_2")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ ON DELETE <reference scope check action> ]
  private static boolean reference_scope_check_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_scope_check_4")) return false;
    parseTokens(b, 0, ON, DELETE, _REFERENCE_SCOPE_CHECK_ACTION_);
    return true;
  }

  /* ********************************************************** */
  // <referential action>
  public static boolean reference_scope_check_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_scope_check_action")) return false;
    if (!nextTokenIs(b, _REFERENTIAL_ACTION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = referential_action(b, l + 1);
    exit_section_(b, m, REFERENCE_SCOPE_CHECK_ACTION, r);
    return r;
  }

  /* ********************************************************** */
  // REF <left paren> <referenced type> <right paren> [ <scope clause> ]
  public static boolean reference_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_type")) return false;
    if (!nextTokenIs(b, REF)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, REF, _LEFT_PAREN_, _REFERENCED_TYPE_, _RIGHT_PAREN_);
    r = r && reference_type_4(b, l + 1);
    exit_section_(b, m, REFERENCE_TYPE, r);
    return r;
  }

  // [ <scope clause> ]
  private static boolean reference_type_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_type_4")) return false;
    scope_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <user-defined representation>
  // 	|	<derived representation>
  // 	|	<system-generated representation>
  public static boolean reference_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_type_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REFERENCE_TYPE_SPECIFICATION, "<reference type specification>");
    r = user_defined_representation(b, l + 1);
    if (!r) r = derived_representation(b, l + 1);
    if (!r) r = system_generated_representation(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary>
  public static boolean reference_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reference_value_expression")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    exit_section_(b, m, REFERENCE_VALUE_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // OF <path-resolved user-defined type name> [ <subview clause> ] [ <view element list> ]
  public static boolean referenceable_view_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referenceable_view_specification")) return false;
    if (!nextTokenIs(b, OF)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OF, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_);
    r = r && referenceable_view_specification_2(b, l + 1);
    r = r && referenceable_view_specification_3(b, l + 1);
    exit_section_(b, m, REFERENCEABLE_VIEW_SPECIFICATION, r);
    return r;
  }

  // [ <subview clause> ]
  private static boolean referenceable_view_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referenceable_view_specification_2")) return false;
    subview_clause(b, l + 1);
    return true;
  }

  // [ <view element list> ]
  private static boolean referenceable_view_specification_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referenceable_view_specification_3")) return false;
    view_element_list(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <table name> [ <left paren> <reference column list> <right paren> ]
  public static boolean referenced_table_and_columns(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referenced_table_and_columns")) return false;
    if (!nextTokenIs(b, _TABLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_name(b, l + 1);
    r = r && referenced_table_and_columns_1(b, l + 1);
    exit_section_(b, m, REFERENCED_TABLE_AND_COLUMNS, r);
    return r;
  }

  // [ <left paren> <reference column list> <right paren> ]
  private static boolean referenced_table_and_columns_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referenced_table_and_columns_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <path-resolved user-defined type name>
  public static boolean referenced_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referenced_type")) return false;
    if (!nextTokenIs(b, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = path_resolved_user_defined_type_name(b, l + 1);
    exit_section_(b, m, REFERENCED_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]
  public static boolean references_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "references_specification")) return false;
    if (!nextTokenIs(b, REFERENCES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, REFERENCES, _REFERENCED_TABLE_AND_COLUMNS_);
    r = r && references_specification_2(b, l + 1);
    r = r && references_specification_3(b, l + 1);
    exit_section_(b, m, REFERENCES_SPECIFICATION, r);
    return r;
  }

  // [ MATCH <match type> ]
  private static boolean references_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "references_specification_2")) return false;
    parseTokens(b, 0, MATCH, _MATCH_TYPE_);
    return true;
  }

  // [ <referential triggered action> ]
  private static boolean references_specification_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "references_specification_3")) return false;
    referential_triggered_action(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <reference column list>
  public static boolean referencing_columns(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referencing_columns")) return false;
    if (!nextTokenIs(b, _REFERENCE_COLUMN_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = reference_column_list(b, l + 1);
    exit_section_(b, m, REFERENCING_COLUMNS, r);
    return r;
  }

  /* ********************************************************** */
  // CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION
  public static boolean referential_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referential_action")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REFERENTIAL_ACTION, "<referential action>");
    r = consumeToken(b, CASCADE);
    if (!r) r = parseTokens(b, 0, SET, NULL);
    if (!r) r = parseTokens(b, 0, SET, DEFAULT);
    if (!r) r = consumeToken(b, RESTRICT);
    if (!r) r = parseTokens(b, 0, NO, ACTION);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // FOREIGN KEY <left paren> <referencing columns> <right paren> <references specification>
  public static boolean referential_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referential_constraint_definition")) return false;
    if (!nextTokenIs(b, FOREIGN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FOREIGN, KEY, _LEFT_PAREN_, _REFERENCING_COLUMNS_, _RIGHT_PAREN_, _REFERENCES_SPECIFICATION_);
    exit_section_(b, m, REFERENTIAL_CONSTRAINT_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // <update rule> [ <delete rule> ] | <delete rule> [ <update rule> ]
  public static boolean referential_triggered_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referential_triggered_action")) return false;
    if (!nextTokenIs(b, "<referential triggered action>", _DELETE_RULE_, _UPDATE_RULE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REFERENTIAL_TRIGGERED_ACTION, "<referential triggered action>");
    r = referential_triggered_action_0(b, l + 1);
    if (!r) r = referential_triggered_action_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <update rule> [ <delete rule> ]
  private static boolean referential_triggered_action_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referential_triggered_action_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = update_rule(b, l + 1);
    r = r && referential_triggered_action_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <delete rule> ]
  private static boolean referential_triggered_action_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referential_triggered_action_0_1")) return false;
    delete_rule(b, l + 1);
    return true;
  }

  // <delete rule> [ <update rule> ]
  private static boolean referential_triggered_action_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referential_triggered_action_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = delete_rule(b, l + 1);
    r = r && referential_triggered_action_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <update rule> ]
  private static boolean referential_triggered_action_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "referential_triggered_action_1_1")) return false;
    update_rule(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <underscore>
  // 	|	<left bracket> <character enumeration>... <right bracket>
  // 	|	<left bracket> <circumflex> <character enumeration>... <right bracket>
  // 	|	<left bracket> <character enumeration include>...  <circumflex> <character enumeration exclude>... <right bracket>
  public static boolean regular_character_set(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_character_set")) return false;
    if (!nextTokenIs(b, "<regular character set>", _LEFT_BRACKET_, _UNDERSCORE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REGULAR_CHARACTER_SET, "<regular character set>");
    r = underscore(b, l + 1);
    if (!r) r = left_bracket(b, l + 1);
    if (!r) r = left_bracket(b, l + 1);
    if (!r) r = left_bracket(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean regular_character_set_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_character_set_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, REGULAR_CHARACTER_SET_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // <regular term>
  // 	|	<regular expression> <vertical bar> <regular term>
  public static boolean regular_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_expression")) return false;
    if (!nextTokenIs(b, "<regular expression>", _REGULAR_EXPRESSION_, _REGULAR_TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REGULAR_EXPRESSION, "<regular expression>");
    r = regular_term(b, l + 1);
    if (!r) r = regular_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SUBSTRING <left paren> <character value expression>
  // 		SIMILAR <character value expression> ESCAPE <escape character> <right paren>
  public static boolean regular_expression_substring_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_expression_substring_function")) return false;
    if (!nextTokenIs(b, SUBSTRING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SUBSTRING, _LEFT_PAREN_, _CHARACTER_VALUE_EXPRESSION_, SIMILAR, _CHARACTER_VALUE_EXPRESSION_, ESCAPE, _ESCAPE_CHARACTER_, _RIGHT_PAREN_);
    exit_section_(b, m, REGULAR_EXPRESSION_SUBSTRING_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <regular primary>
  // 	|	<regular primary> <asterisk>
  // 	|	<regular primary> <plus sign>
  // 	|	<regular primary> <question mark>
  // 	|	<regular primary> <repeat factor>
  public static boolean regular_factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_factor")) return false;
    if (!nextTokenIs(b, _REGULAR_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = regular_primary(b, l + 1);
    if (!r) r = regular_primary(b, l + 1);
    if (!r) r = regular_primary(b, l + 1);
    if (!r) r = regular_primary(b, l + 1);
    if (!r) r = regular_primary(b, l + 1);
    exit_section_(b, m, REGULAR_FACTOR, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier body>
  public static boolean regular_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_BODY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier_body(b, l + 1);
    exit_section_(b, m, REGULAR_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // <character specifier>
  // 	|	<percent>
  // 	|	<regular character set>
  // 	|	<left paren> <regular expression> <right paren>
  public static boolean regular_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_primary")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REGULAR_PRIMARY, "<regular primary>");
    r = character_specifier(b, l + 1);
    if (!r) r = percent(b, l + 1);
    if (!r) r = regular_character_set(b, l + 1);
    if (!r) r = left_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <regular factor>
  // 	|	<regular term> <regular factor>
  public static boolean regular_term(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_term")) return false;
    if (!nextTokenIs(b, "<regular term>", _REGULAR_FACTOR_, _REGULAR_TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REGULAR_TERM, "<regular term>");
    r = regular_factor(b, l + 1);
    if (!r) r = regular_term(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <left paren> <view column list> <right paren> ]
  public static boolean regular_view_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "regular_view_specification")) return false;
    Marker m = enter_section_(b, l, _NONE_, REGULAR_VIEW_SPECIFICATION, "<regular view specification>");
    left_paren(b, l + 1);
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  /* ********************************************************** */
  // RELATIVE WITH <relative function specification>
  public static boolean relative_category(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "relative_category")) return false;
    if (!nextTokenIs(b, RELATIVE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, RELATIVE, WITH, _RELATIVE_FUNCTION_SPECIFICATION_);
    exit_section_(b, m, RELATIVE_CATEGORY, r);
    return r;
  }

  /* ********************************************************** */
  // <specific routine designator>
  public static boolean relative_function_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "relative_function_specification")) return false;
    if (!nextTokenIs(b, _SPECIFIC_ROUTINE_DESIGNATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = specific_routine_designator(b, l + 1);
    exit_section_(b, m, RELATIVE_FUNCTION_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // RELEASE SAVEPOINT <savepoint specifier>
  public static boolean release_savepoint_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "release_savepoint_statement")) return false;
    if (!nextTokenIs(b, RELEASE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, RELEASE, SAVEPOINT, _SAVEPOINT_SPECIFIER_);
    exit_section_(b, m, RELEASE_SAVEPOINT_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean repeat_argument(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "repeat_argument")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, REPEAT_ARGUMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <left brace> <low value> [ <upper limit> ] <right brace>
  public static boolean repeat_factor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "repeat_factor")) return false;
    if (!nextTokenIs(b, _LEFT_BRACE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_brace(b, l + 1);
    r = r && low_value(b, l + 1);
    r = r && repeat_factor_2(b, l + 1);
    r = r && right_brace(b, l + 1);
    exit_section_(b, m, REPEAT_FACTOR, r);
    return r;
  }

  // [ <upper limit> ]
  private static boolean repeat_factor_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "repeat_factor_2")) return false;
    upper_limit(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // REPEATABLE <left paren> <repeat argument> <right paren>
  public static boolean repeatable_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "repeatable_clause")) return false;
    if (!nextTokenIs(b, REPEATABLE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, REPEATABLE, _LEFT_PAREN_, _REPEAT_ARGUMENT_, _RIGHT_PAREN_);
    exit_section_(b, m, REPEATABLE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <predefined type> | <member list>
  public static boolean representation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "representation")) return false;
    if (!nextTokenIs(b, "<representation>", _MEMBER_LIST_, _PREDEFINED_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REPRESENTATION, "<representation>");
    r = predefined_type(b, l + 1);
    if (!r) r = member_list(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ADD
  // 	|	ALL
  // 	|	ALLOCATE
  // 	|	ALTER
  // 	|	AND
  // 	|	ANY
  // 	|	ARE
  // 	|	ARRAY
  // 	|	AS
  // 	|	ASENSITIVE
  // 	|	ASYMMETRIC
  // 	|	AT
  // 	|	ATOMIC
  // 	|	AUTHORIZATION
  // 	|	BEGIN
  // 	|	BETWEEN
  // 	|	BIGINT
  // 	|	BINARY
  // 	|	BLOB
  // 	|	BOOLEAN
  // 	|	BOTH
  // 	|	BY
  // 	|	CALL
  // 	|	CALLED
  // 	|	CASCADED
  // 	|	CASE
  // 	|	CAST
  // 	|	CHAR
  // 	|	CHARACTER
  // 	|	CHECK
  // 	|	CLOB
  // 	|	CLOSE
  // 	|	COLLATE
  // 	|	COLUMN
  // 	|	COMMIT
  // 	|	CONNECT
  // 	|	CONSTRAINT
  // 	|	CONTINUE
  // 	|	CORRESPONDING
  // 	|	CREATE
  // 	|	CROSS
  // 	|	CUBE
  // 	|	CURRENT
  // 	|	CURRENT_DATE
  // 	|	CURRENT_DEFAULT_TRANSFORM_GROUP
  // 	|	CURRENT_PATH
  // 	|	CURRENT_ROLE
  // 	|	CURRENT_TIME
  // 	|	CURRENT_TIMESTAMP
  // 	|	CURRENT_TRANSFORM_GROUP_FOR_TYPE
  // 	|	CURRENT_USER
  // 	|	CURSOR
  // 	|	CYCLE
  // 	|	DATE
  // 	|	DAY
  // 	|	DEALLOCATE
  // 	|	DEC
  // 	|	DECIMAL
  // 	|	DECLARE
  // 	|	DEFAULT
  // 	|	DELETE
  // 	|	DEREF
  // 	|	DESCRIBE
  // 	|	DETERMINISTIC
  // 	|	DISCONNECT
  // 	|	DISTINCT
  // 	|	DOUBLE
  // 	|	DROP
  // 	|	DYNAMIC
  // 	|	EACH
  // 	|	ELEMENT
  // 	|	ELSE
  // 	|	END
  // 	|	END-EXEC
  // 	|	ESCAPE
  // 	|	EXCEPT
  // 	|	EXEC
  // 	|	EXECUTE
  // 	|	EXISTS
  // 	|	EXTERNAL
  // 	|	FALSE
  // 	|	FETCH
  // 	|	FILTER
  // 	|	FLOAT
  // 	|	FOR
  // 	|	FOREIGN
  // 	|	FREE
  // 	|	FROM
  // 	|	FULL
  // 	|	FUNCTION
  // 	|	GET
  // 	|	GLOBAL
  // 	|	GRANT
  // 	|	GROUP
  // 	|	GROUPING
  // 	|	HAVING
  // 	|	HOLD
  // 	|	HOUR
  // 	|	IDENTITY
  // 	|	IMMEDIATE
  // 	|	IN
  // 	|	INDICATOR
  // 	|	INNER
  // 	|	INOUT
  // 	|	INPUT
  // 	|	INSENSITIVE
  // 	|	INSERT
  // 	|	INT
  // 	|	INTEGER
  // 	|	INTERSECT
  // 	|	INTERVAL
  // 	|	INTO
  // 	|	IS
  // 	|	ISOLATION
  // 	|	JOIN
  // 	|	LANGUAGE
  // 	|	LARGE
  // 	|	LATERAL
  // 	|	LEADING
  // 	|	LEFT
  // 	|	LIKE
  // 	|	LOCAL
  // 	|	LOCALTIME
  // 	|	LOCALTIMESTAMP
  // 	|	MATCH
  // 	|	MEMBER
  // 	|	MERGE
  // 	|	METHOD
  // 	|	MINUTE
  // 	|	MODIFIES
  // 	|	MODULE
  // 	|	MONTH
  // 	|	MULTISET
  // 	|	NATIONAL
  // 	|	NATURAL
  // 	|	NCHAR
  // 	|	NCLOB
  // 	|	NEW
  // 	|	NO
  // 	|	NONE
  // 	|	NOT
  // 	|	NULL
  // 	|	NUMERIC
  // 	|	OF
  // 	|	OLD
  // 	|	ON
  // 	|	ONLY
  // 	|	OPEN
  // 	|	OR
  // 	|	ORDER
  // 	|	OUT
  // 	|	OUTER
  // 	|	OUTPUT
  // 	|	OVER
  // 	|	OVERLAPS
  // 	|	PARAMETER
  // 	|	PARTITION
  // 	|	PRECISION
  // 	|	PREPARE
  // 	|	PRIMARY
  // 	|	PROCEDURE
  // 	|	RANGE
  // 	|	READS
  // 	|	REAL
  // 	|	RECURSIVE
  // 	|	REF
  // 	|	REFERENCES
  // 	|	REFERENCING
  // 	|	REGR_AVGX
  // 	|	REGR_AVGY
  // 	|	REGR_COUNT
  // 	|	REGR_INTERCEPT
  // 	|	REGR_R2
  // 	|	REGR_SLOPE
  // 	|	REGR_SXX
  // 	|	REGR_SXY
  // 	|	REGR_SYY
  // 	|	RELEASE
  // 	|	RESULT
  // 	|	RETURN
  // 	|	RETURNS
  // 	|	REVOKE
  // 	|	RIGHT
  // 	|	ROLLBACK
  // 	|	ROLLUP
  // 	|	ROW
  // 	|	ROWS
  // 	|	SAVEPOINT
  // 	|	SCROLL
  // 	|	SEARCH
  // 	|	SECOND
  // 	|	SELECT
  // 	|	SENSITIVE
  // 	|	SESSION_USER
  // 	|	SET
  // 	|	SIMILAR
  // 	|	SMALLINT
  // 	|	SOME
  // 	|	SPECIFIC
  // 	|	SPECIFICTYPE
  // 	|	SQL
  // 	|	SQLEXCEPTION
  // 	|	SQLSTATE
  // 	|	SQLWARNING
  // 	|	START
  // 	|	STATIC
  // 	|	SUBMULTISET
  // 	|	SYMMETRIC
  // 	|	SYSTEM
  // 	|	SYSTEM_USER
  // 	|	TABLE
  // 	|	THEN
  // 	|	TIME
  // 	|	TIMESTAMP
  // 	|	TIMEZONE_HOUR
  // 	|	TIMEZONE_MINUTE
  // 	|	TO
  // 	|	TRAILING
  // 	|	TRANSLATION
  // 	|	TREAT
  // 	|	TRIGGER
  // 	|	TRUE
  // 	|	UESCAPE
  // 	|	UNION
  // 	|	UNIQUE
  // 	|	UNKNOWN
  // 	|	UNNEST
  // 	|	UPDATE
  // 	|	UPPER
  // 	|	USER
  // 	|	USING
  // 	|	VALUE
  // 	|	VALUES
  // 	|	VAR_POP
  // 	|	VAR_SAMP
  // 	|	VARCHAR
  // 	|	VARYING
  // 	|	WHEN
  // 	|	WHENEVER
  // 	|	WHERE
  // 	|	WIDTH_BUCKET
  // 	|	WINDOW
  // 	|	WITH
  // 	|	WITHIN
  // 	|	WITHOUT
  // 	|	YEAR
  public static boolean reserved_word(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "reserved_word")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, RESERVED_WORD, "<reserved word>");
    r = consumeToken(b, ADD);
    if (!r) r = consumeToken(b, ALL);
    if (!r) r = consumeToken(b, ALLOCATE);
    if (!r) r = consumeToken(b, ALTER);
    if (!r) r = consumeToken(b, AND);
    if (!r) r = consumeToken(b, ANY);
    if (!r) r = consumeToken(b, ARE);
    if (!r) r = consumeToken(b, ARRAY);
    if (!r) r = consumeToken(b, AS);
    if (!r) r = consumeToken(b, ASENSITIVE);
    if (!r) r = consumeToken(b, ASYMMETRIC);
    if (!r) r = consumeToken(b, AT);
    if (!r) r = consumeToken(b, ATOMIC);
    if (!r) r = consumeToken(b, AUTHORIZATION);
    if (!r) r = consumeToken(b, BEGIN);
    if (!r) r = consumeToken(b, BETWEEN);
    if (!r) r = consumeToken(b, BIGINT);
    if (!r) r = consumeToken(b, BINARY);
    if (!r) r = consumeToken(b, BLOB);
    if (!r) r = consumeToken(b, BOOLEAN);
    if (!r) r = consumeToken(b, BOTH);
    if (!r) r = consumeToken(b, BY);
    if (!r) r = consumeToken(b, CALL);
    if (!r) r = consumeToken(b, CALLED);
    if (!r) r = consumeToken(b, CASCADED);
    if (!r) r = consumeToken(b, CASE);
    if (!r) r = consumeToken(b, CAST);
    if (!r) r = consumeToken(b, CHAR);
    if (!r) r = consumeToken(b, CHARACTER);
    if (!r) r = consumeToken(b, CHECK);
    if (!r) r = consumeToken(b, CLOB);
    if (!r) r = consumeToken(b, CLOSE);
    if (!r) r = consumeToken(b, COLLATE);
    if (!r) r = consumeToken(b, COLUMN);
    if (!r) r = consumeToken(b, COMMIT);
    if (!r) r = consumeToken(b, CONNECT);
    if (!r) r = consumeToken(b, CONSTRAINT);
    if (!r) r = consumeToken(b, CONTINUE);
    if (!r) r = consumeToken(b, CORRESPONDING);
    if (!r) r = consumeToken(b, CREATE);
    if (!r) r = consumeToken(b, CROSS);
    if (!r) r = consumeToken(b, CUBE);
    if (!r) r = consumeToken(b, CURRENT);
    if (!r) r = consumeToken(b, CURRENT_DATE);
    if (!r) r = consumeToken(b, CURRENT_DEFAULT_TRANSFORM_GROUP);
    if (!r) r = consumeToken(b, CURRENT_PATH);
    if (!r) r = consumeToken(b, CURRENT_ROLE);
    if (!r) r = consumeToken(b, CURRENT_TIME);
    if (!r) r = consumeToken(b, CURRENT_TIMESTAMP);
    if (!r) r = consumeToken(b, CURRENT_TRANSFORM_GROUP_FOR_TYPE);
    if (!r) r = consumeToken(b, CURRENT_USER);
    if (!r) r = consumeToken(b, CURSOR);
    if (!r) r = consumeToken(b, CYCLE);
    if (!r) r = consumeToken(b, DATE);
    if (!r) r = consumeToken(b, DAY);
    if (!r) r = consumeToken(b, DEALLOCATE);
    if (!r) r = consumeToken(b, DEC);
    if (!r) r = consumeToken(b, DECIMAL);
    if (!r) r = consumeToken(b, DECLARE);
    if (!r) r = consumeToken(b, DEFAULT);
    if (!r) r = consumeToken(b, DELETE);
    if (!r) r = consumeToken(b, DEREF);
    if (!r) r = consumeToken(b, DESCRIBE);
    if (!r) r = consumeToken(b, DETERMINISTIC);
    if (!r) r = consumeToken(b, DISCONNECT);
    if (!r) r = consumeToken(b, DISTINCT);
    if (!r) r = consumeToken(b, DOUBLE);
    if (!r) r = consumeToken(b, DROP);
    if (!r) r = consumeToken(b, DYNAMIC);
    if (!r) r = consumeToken(b, EACH);
    if (!r) r = consumeToken(b, ELEMENT);
    if (!r) r = consumeToken(b, ELSE);
    if (!r) r = consumeToken(b, END);
    if (!r) r = consumeToken(b, END_EXEC);
    if (!r) r = consumeToken(b, ESCAPE);
    if (!r) r = consumeToken(b, EXCEPT);
    if (!r) r = consumeToken(b, EXEC);
    if (!r) r = consumeToken(b, EXECUTE);
    if (!r) r = consumeToken(b, EXISTS);
    if (!r) r = consumeToken(b, EXTERNAL);
    if (!r) r = consumeToken(b, FALSE);
    if (!r) r = consumeToken(b, FETCH);
    if (!r) r = consumeToken(b, FILTER);
    if (!r) r = consumeToken(b, FLOAT);
    if (!r) r = consumeToken(b, FOR);
    if (!r) r = consumeToken(b, FOREIGN);
    if (!r) r = consumeToken(b, FREE);
    if (!r) r = consumeToken(b, FROM);
    if (!r) r = consumeToken(b, FULL);
    if (!r) r = consumeToken(b, FUNCTION);
    if (!r) r = consumeToken(b, GET);
    if (!r) r = consumeToken(b, GLOBAL);
    if (!r) r = consumeToken(b, GRANT);
    if (!r) r = consumeToken(b, GROUP);
    if (!r) r = consumeToken(b, GROUPING);
    if (!r) r = consumeToken(b, HAVING);
    if (!r) r = consumeToken(b, HOLD);
    if (!r) r = consumeToken(b, HOUR);
    if (!r) r = consumeToken(b, IDENTITY);
    if (!r) r = consumeToken(b, IMMEDIATE);
    if (!r) r = consumeToken(b, IN);
    if (!r) r = consumeToken(b, INDICATOR);
    if (!r) r = consumeToken(b, INNER);
    if (!r) r = consumeToken(b, INOUT);
    if (!r) r = consumeToken(b, INPUT);
    if (!r) r = consumeToken(b, INSENSITIVE);
    if (!r) r = consumeToken(b, INSERT);
    if (!r) r = consumeToken(b, INT);
    if (!r) r = consumeToken(b, INTEGER);
    if (!r) r = consumeToken(b, INTERSECT);
    if (!r) r = consumeToken(b, INTERVAL);
    if (!r) r = consumeToken(b, INTO);
    if (!r) r = consumeToken(b, IS);
    if (!r) r = consumeToken(b, ISOLATION);
    if (!r) r = consumeToken(b, JOIN);
    if (!r) r = consumeToken(b, LANGUAGE);
    if (!r) r = consumeToken(b, LARGE);
    if (!r) r = consumeToken(b, LATERAL);
    if (!r) r = consumeToken(b, LEADING);
    if (!r) r = consumeToken(b, LEFT);
    if (!r) r = consumeToken(b, LIKE);
    if (!r) r = consumeToken(b, LOCAL);
    if (!r) r = consumeToken(b, LOCALTIME);
    if (!r) r = consumeToken(b, LOCALTIMESTAMP);
    if (!r) r = consumeToken(b, MATCH);
    if (!r) r = consumeToken(b, MEMBER);
    if (!r) r = consumeToken(b, MERGE);
    if (!r) r = consumeToken(b, METHOD);
    if (!r) r = consumeToken(b, MINUTE);
    if (!r) r = consumeToken(b, MODIFIES);
    if (!r) r = consumeToken(b, MODULE);
    if (!r) r = consumeToken(b, MONTH);
    if (!r) r = consumeToken(b, MULTISET);
    if (!r) r = consumeToken(b, NATIONAL);
    if (!r) r = consumeToken(b, NATURAL);
    if (!r) r = consumeToken(b, NCHAR);
    if (!r) r = consumeToken(b, NCLOB);
    if (!r) r = consumeToken(b, NEW);
    if (!r) r = consumeToken(b, NO);
    if (!r) r = consumeToken(b, NONE);
    if (!r) r = consumeToken(b, NOT);
    if (!r) r = consumeToken(b, NULL);
    if (!r) r = consumeToken(b, NUMERIC);
    if (!r) r = consumeToken(b, OF);
    if (!r) r = consumeToken(b, OLD);
    if (!r) r = consumeToken(b, ON);
    if (!r) r = consumeToken(b, ONLY);
    if (!r) r = consumeToken(b, OPEN);
    if (!r) r = consumeToken(b, OR);
    if (!r) r = consumeToken(b, ORDER);
    if (!r) r = consumeToken(b, OUT);
    if (!r) r = consumeToken(b, OUTER);
    if (!r) r = consumeToken(b, OUTPUT);
    if (!r) r = consumeToken(b, OVER);
    if (!r) r = consumeToken(b, OVERLAPS);
    if (!r) r = consumeToken(b, PARAMETER);
    if (!r) r = consumeToken(b, PARTITION);
    if (!r) r = consumeToken(b, PRECISION);
    if (!r) r = consumeToken(b, PREPARE);
    if (!r) r = consumeToken(b, PRIMARY);
    if (!r) r = consumeToken(b, PROCEDURE);
    if (!r) r = consumeToken(b, RANGE);
    if (!r) r = consumeToken(b, READS);
    if (!r) r = consumeToken(b, REAL);
    if (!r) r = consumeToken(b, RECURSIVE);
    if (!r) r = consumeToken(b, REF);
    if (!r) r = consumeToken(b, REFERENCES);
    if (!r) r = consumeToken(b, REFERENCING);
    if (!r) r = consumeToken(b, REGR_AVGX);
    if (!r) r = consumeToken(b, REGR_AVGY);
    if (!r) r = consumeToken(b, REGR_COUNT);
    if (!r) r = consumeToken(b, REGR_INTERCEPT);
    if (!r) r = consumeToken(b, REGR_R2);
    if (!r) r = consumeToken(b, REGR_SLOPE);
    if (!r) r = consumeToken(b, REGR_SXX);
    if (!r) r = consumeToken(b, REGR_SXY);
    if (!r) r = consumeToken(b, REGR_SYY);
    if (!r) r = consumeToken(b, RELEASE);
    if (!r) r = consumeToken(b, RESULT);
    if (!r) r = consumeToken(b, RETURN);
    if (!r) r = consumeToken(b, RETURNS);
    if (!r) r = consumeToken(b, REVOKE);
    if (!r) r = consumeToken(b, RIGHT);
    if (!r) r = consumeToken(b, ROLLBACK);
    if (!r) r = consumeToken(b, ROLLUP);
    if (!r) r = consumeToken(b, ROW);
    if (!r) r = consumeToken(b, ROWS);
    if (!r) r = consumeToken(b, SAVEPOINT);
    if (!r) r = consumeToken(b, SCROLL);
    if (!r) r = consumeToken(b, SEARCH);
    if (!r) r = consumeToken(b, SECOND);
    if (!r) r = consumeToken(b, SELECT);
    if (!r) r = consumeToken(b, SENSITIVE);
    if (!r) r = consumeToken(b, SESSION_USER);
    if (!r) r = consumeToken(b, SET);
    if (!r) r = consumeToken(b, SIMILAR);
    if (!r) r = consumeToken(b, SMALLINT);
    if (!r) r = consumeToken(b, SOME);
    if (!r) r = consumeToken(b, SPECIFIC);
    if (!r) r = consumeToken(b, SPECIFICTYPE);
    if (!r) r = consumeToken(b, SQL);
    if (!r) r = consumeToken(b, SQLEXCEPTION);
    if (!r) r = consumeToken(b, SQLSTATE);
    if (!r) r = consumeToken(b, SQLWARNING);
    if (!r) r = consumeToken(b, START);
    if (!r) r = consumeToken(b, STATIC);
    if (!r) r = consumeToken(b, SUBMULTISET);
    if (!r) r = consumeToken(b, SYMMETRIC);
    if (!r) r = consumeToken(b, SYSTEM);
    if (!r) r = consumeToken(b, SYSTEM_USER);
    if (!r) r = consumeToken(b, TABLE);
    if (!r) r = consumeToken(b, THEN);
    if (!r) r = consumeToken(b, TIME);
    if (!r) r = consumeToken(b, TIMESTAMP);
    if (!r) r = consumeToken(b, TIMEZONE_HOUR);
    if (!r) r = consumeToken(b, TIMEZONE_MINUTE);
    if (!r) r = consumeToken(b, TO);
    if (!r) r = consumeToken(b, TRAILING);
    if (!r) r = consumeToken(b, TRANSLATION);
    if (!r) r = consumeToken(b, TREAT);
    if (!r) r = consumeToken(b, TRIGGER);
    if (!r) r = consumeToken(b, TRUE);
    if (!r) r = consumeToken(b, UESCAPE);
    if (!r) r = consumeToken(b, UNION);
    if (!r) r = consumeToken(b, UNIQUE);
    if (!r) r = consumeToken(b, UNKNOWN);
    if (!r) r = consumeToken(b, UNNEST);
    if (!r) r = consumeToken(b, UPDATE);
    if (!r) r = consumeToken(b, UPPER);
    if (!r) r = consumeToken(b, USER);
    if (!r) r = consumeToken(b, USING);
    if (!r) r = consumeToken(b, VALUE);
    if (!r) r = consumeToken(b, VALUES);
    if (!r) r = consumeToken(b, VAR_POP);
    if (!r) r = consumeToken(b, VAR_SAMP);
    if (!r) r = consumeToken(b, VARCHAR);
    if (!r) r = consumeToken(b, VARYING);
    if (!r) r = consumeToken(b, WHEN);
    if (!r) r = consumeToken(b, WHENEVER);
    if (!r) r = consumeToken(b, WHERE);
    if (!r) r = consumeToken(b, WIDTH_BUCKET);
    if (!r) r = consumeToken(b, WINDOW);
    if (!r) r = consumeToken(b, WITH);
    if (!r) r = consumeToken(b, WITHIN);
    if (!r) r = consumeToken(b, WITHOUT);
    if (!r) r = consumeToken(b, YEAR);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <result expression> | NULL
  public static boolean result(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "result")) return false;
    if (!nextTokenIs(b, "<result>", NULL, _RESULT_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, RESULT, "<result>");
    r = result_expression(b, l + 1);
    if (!r) r = consumeToken(b, NULL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CAST FROM <result cast from type>
  public static boolean result_cast(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "result_cast")) return false;
    if (!nextTokenIs(b, CAST)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CAST, FROM, _RESULT_CAST_FROM_TYPE_);
    exit_section_(b, m, RESULT_CAST, r);
    return r;
  }

  /* ********************************************************** */
  // <data type> [ <locator indication> ]
  public static boolean result_cast_from_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "result_cast_from_type")) return false;
    if (!nextTokenIs(b, _DATA_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    r = r && result_cast_from_type_1(b, l + 1);
    exit_section_(b, m, RESULT_CAST_FROM_TYPE, r);
    return r;
  }

  // [ <locator indication> ]
  private static boolean result_cast_from_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "result_cast_from_type_1")) return false;
    locator_indication(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <value expression>
  public static boolean result_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "result_expression")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    exit_section_(b, m, RESULT_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // FOR PROCEDURE <specific routine designator>
  public static boolean result_set_cursor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "result_set_cursor")) return false;
    if (!nextTokenIs(b, FOR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FOR, PROCEDURE, _SPECIFIC_ROUTINE_DESIGNATOR_);
    exit_section_(b, m, RESULT_SET_CURSOR, r);
    return r;
  }

  /* ********************************************************** */
  // <output using clause>
  public static boolean result_using_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "result_using_clause")) return false;
    if (!nextTokenIs(b, _OUTPUT_USING_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = output_using_clause(b, l + 1);
    exit_section_(b, m, RESULT_USING_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // RETURN <return value>
  public static boolean return_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "return_statement")) return false;
    if (!nextTokenIs(b, RETURN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, RETURN, _RETURN_VALUE_);
    exit_section_(b, m, RETURN_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression> | NULL
  public static boolean return_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "return_value")) return false;
    if (!nextTokenIs(b, "<return value>", NULL, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, RETURN_VALUE, "<return value>");
    r = value_expression(b, l + 1);
    if (!r) r = consumeToken(b, NULL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // RETURNS <returns type>
  public static boolean returns_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "returns_clause")) return false;
    if (!nextTokenIs(b, RETURNS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, RETURNS, _RETURNS_TYPE_);
    exit_section_(b, m, RETURNS_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <data type> [ <locator indication> ]
  public static boolean returns_data_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "returns_data_type")) return false;
    if (!nextTokenIs(b, _DATA_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    r = r && returns_data_type_1(b, l + 1);
    exit_section_(b, m, RETURNS_DATA_TYPE, r);
    return r;
  }

  // [ <locator indication> ]
  private static boolean returns_data_type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "returns_data_type_1")) return false;
    locator_indication(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // TABLE <table function column list>
  public static boolean returns_table_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "returns_table_type")) return false;
    if (!nextTokenIs(b, TABLE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLE, _TABLE_FUNCTION_COLUMN_LIST_);
    exit_section_(b, m, RETURNS_TABLE_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // <returns data type> [ <result cast> ]
  // 	|	<returns table type>
  public static boolean returns_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "returns_type")) return false;
    if (!nextTokenIs(b, "<returns type>", _RETURNS_DATA_TYPE_, _RETURNS_TABLE_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, RETURNS_TYPE, "<returns type>");
    r = returns_type_0(b, l + 1);
    if (!r) r = returns_table_type(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <returns data type> [ <result cast> ]
  private static boolean returns_type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "returns_type_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = returns_data_type(b, l + 1);
    r = r && returns_type_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <result cast> ]
  private static boolean returns_type_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "returns_type_0_1")) return false;
    result_cast(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // GRANT OPTION FOR | HIERARCHY OPTION FOR
  public static boolean revoke_option_extension(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_option_extension")) return false;
    if (!nextTokenIs(b, "<revoke option extension>", GRANT, HIERARCHY)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REVOKE_OPTION_EXTENSION, "<revoke option extension>");
    r = parseTokens(b, 0, GRANT, OPTION, FOR);
    if (!r) r = parseTokens(b, 0, HIERARCHY, OPTION, FOR);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // REVOKE [ <revoke option extension> ] <privileges> FROM <grantee> [ { <comma> <grantee> }... ]
  // 		[ GRANTED BY <grantor> ] <drop behavior>
  public static boolean revoke_privilege_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_privilege_statement")) return false;
    if (!nextTokenIs(b, REVOKE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, REVOKE);
    r = r && revoke_privilege_statement_1(b, l + 1);
    r = r && privileges(b, l + 1);
    r = r && consumeTokens(b, 0, FROM, _GRANTEE_);
    r = r && revoke_privilege_statement_5(b, l + 1);
    r = r && revoke_privilege_statement_6(b, l + 1);
    r = r && drop_behavior(b, l + 1);
    exit_section_(b, m, REVOKE_PRIVILEGE_STATEMENT, r);
    return r;
  }

  // [ <revoke option extension> ]
  private static boolean revoke_privilege_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_privilege_statement_1")) return false;
    revoke_option_extension(b, l + 1);
    return true;
  }

  // [ { <comma> <grantee> }... ]
  private static boolean revoke_privilege_statement_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_privilege_statement_5")) return false;
    revoke_privilege_statement_5_0(b, l + 1);
    return true;
  }

  // <comma> <grantee>
  private static boolean revoke_privilege_statement_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_privilege_statement_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && grantee(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ GRANTED BY <grantor> ]
  private static boolean revoke_privilege_statement_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_privilege_statement_6")) return false;
    parseTokens(b, 0, GRANTED, BY, _GRANTOR_);
    return true;
  }

  /* ********************************************************** */
  // REVOKE [ ADMIN OPTION FOR ] <role revoked> [ { <comma> <role revoked> }... ]
  // 		FROM <grantee> [ { <comma> <grantee> }... ] [ GRANTED BY <grantor> ] <drop behavior>
  public static boolean revoke_role_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_role_statement")) return false;
    if (!nextTokenIs(b, REVOKE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, REVOKE);
    r = r && revoke_role_statement_1(b, l + 1);
    r = r && role_revoked(b, l + 1);
    r = r && revoke_role_statement_3(b, l + 1);
    r = r && consumeTokens(b, 0, FROM, _GRANTEE_);
    r = r && revoke_role_statement_6(b, l + 1);
    r = r && revoke_role_statement_7(b, l + 1);
    r = r && drop_behavior(b, l + 1);
    exit_section_(b, m, REVOKE_ROLE_STATEMENT, r);
    return r;
  }

  // [ ADMIN OPTION FOR ]
  private static boolean revoke_role_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_role_statement_1")) return false;
    parseTokens(b, 0, ADMIN, OPTION, FOR);
    return true;
  }

  // [ { <comma> <role revoked> }... ]
  private static boolean revoke_role_statement_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_role_statement_3")) return false;
    revoke_role_statement_3_0(b, l + 1);
    return true;
  }

  // <comma> <role revoked>
  private static boolean revoke_role_statement_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_role_statement_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && role_revoked(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <grantee> }... ]
  private static boolean revoke_role_statement_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_role_statement_6")) return false;
    revoke_role_statement_6_0(b, l + 1);
    return true;
  }

  // <comma> <grantee>
  private static boolean revoke_role_statement_6_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_role_statement_6_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && grantee(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ GRANTED BY <grantor> ]
  private static boolean revoke_role_statement_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_role_statement_7")) return false;
    parseTokens(b, 0, GRANTED, BY, _GRANTOR_);
    return true;
  }

  /* ********************************************************** */
  // <revoke privilege statement>
  // 	|	<revoke role statement>
  public static boolean revoke_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "revoke_statement")) return false;
    if (!nextTokenIs(b, "<revoke statement>", _REVOKE_PRIVILEGE_STATEMENT_, _REVOKE_ROLE_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, REVOKE_STATEMENT, "<revoke statement>");
    r = revoke_privilege_statement(b, l + 1);
    if (!r) r = revoke_role_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <minus sign> <greater than operator>
  public static boolean right_arrow(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "right_arrow")) return false;
    if (!nextTokenIs(b, _MINUS_SIGN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = minus_sign(b, l + 1);
    r = r && greater_than_operator(b, l + 1);
    exit_section_(b, m, RIGHT_ARROW, r);
    return r;
  }

  /* ********************************************************** */
  public static boolean right_brace(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, RIGHT_BRACE, true);
    return true;
  }

  /* ********************************************************** */
  // <right bracket> | <right bracket trigraph>
  public static boolean right_bracket_or_trigraph(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "right_bracket_or_trigraph")) return false;
    if (!nextTokenIs(b, "<right bracket or trigraph>", _RIGHT_BRACKET_, _RIGHT_BRACKET_TRIGRAPH_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, RIGHT_BRACKET_OR_TRIGRAPH, "<right bracket or trigraph>");
    r = consumeToken(b, _RIGHT_BRACKET_);
    if (!r) r = consumeToken(b, _RIGHT_BRACKET_TRIGRAPH_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  public static boolean right_paren(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, RIGHT_PAREN, true);
    return true;
  }

  /* ********************************************************** */
  // SQL SECURITY INVOKER | SQL SECURITY DEFINER
  public static boolean rights_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rights_clause")) return false;
    if (!nextTokenIs(b, SQL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, SQL, SECURITY, INVOKER);
    if (!r) r = parseTokens(b, 0, SQL, SECURITY, DEFINER);
    exit_section_(b, m, RIGHTS_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE ROLE <role name> [ WITH ADMIN <grantor> ]
  public static boolean role_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "role_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, ROLE, _ROLE_NAME_);
    r = r && role_definition_3(b, l + 1);
    exit_section_(b, m, ROLE_DEFINITION, r);
    return r;
  }

  // [ WITH ADMIN <grantor> ]
  private static boolean role_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "role_definition_3")) return false;
    parseTokens(b, 0, WITH, ADMIN, _GRANTOR_);
    return true;
  }

  /* ********************************************************** */
  // <role name>
  public static boolean role_granted(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "role_granted")) return false;
    if (!nextTokenIs(b, _ROLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = role_name(b, l + 1);
    exit_section_(b, m, ROLE_GRANTED, r);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean role_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "role_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, ROLE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <role name>
  public static boolean role_revoked(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "role_revoked")) return false;
    if (!nextTokenIs(b, _ROLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = role_name(b, l + 1);
    exit_section_(b, m, ROLE_REVOKED, r);
    return r;
  }

  /* ********************************************************** */
  // <value specification> | NONE
  public static boolean role_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "role_specification")) return false;
    if (!nextTokenIs(b, "<role specification>", NONE, _VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROLE_SPECIFICATION, "<role specification>");
    r = value_specification(b, l + 1);
    if (!r) r = consumeToken(b, NONE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ROLLBACK [ WORK ] [ AND [ NO ] CHAIN ] [ <savepoint clause> ]
  public static boolean rollback_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rollback_statement")) return false;
    if (!nextTokenIs(b, ROLLBACK)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, ROLLBACK);
    r = r && rollback_statement_1(b, l + 1);
    r = r && rollback_statement_2(b, l + 1);
    r = r && rollback_statement_3(b, l + 1);
    exit_section_(b, m, ROLLBACK_STATEMENT, r);
    return r;
  }

  // [ WORK ]
  private static boolean rollback_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rollback_statement_1")) return false;
    consumeToken(b, WORK);
    return true;
  }

  // [ AND [ NO ] CHAIN ]
  private static boolean rollback_statement_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rollback_statement_2")) return false;
    rollback_statement_2_0(b, l + 1);
    return true;
  }

  // AND [ NO ] CHAIN
  private static boolean rollback_statement_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rollback_statement_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, AND);
    r = r && rollback_statement_2_0_1(b, l + 1);
    r = r && consumeToken(b, CHAIN);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ NO ]
  private static boolean rollback_statement_2_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rollback_statement_2_0_1")) return false;
    consumeToken(b, NO);
    return true;
  }

  // [ <savepoint clause> ]
  private static boolean rollback_statement_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rollback_statement_3")) return false;
    savepoint_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // ROLLUP <left paren> <ordinary grouping set list> <right paren>
  public static boolean rollup_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "rollup_list")) return false;
    if (!nextTokenIs(b, ROLLUP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ROLLUP, _LEFT_PAREN_, _ORDINARY_GROUPING_SET_LIST_, _RIGHT_PAREN_);
    exit_section_(b, m, ROLLUP_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // <SQL routine spec>
  // 	|	<external body reference>
  public static boolean routine_body(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_body")) return false;
    if (!nextTokenIs(b, "<routine body>", _EXTERNAL_BODY_REFERENCE_, _SQL_ROUTINE_SPEC_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROUTINE_BODY, "<routine body>");
    r = SQL_routine_spec(b, l + 1);
    if (!r) r = external_body_reference(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <language clause>
  // 	|	<parameter style clause>
  // 	|	SPECIFIC <specific name>
  // 	|	<deterministic characteristic>
  // 	|	<SQL-data access indication>
  // 	|	<null-call clause>
  // 	|	<dynamic result sets characteristic>
  // 	|	<savepoint level indication>
  public static boolean routine_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_characteristic")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROUTINE_CHARACTERISTIC, "<routine characteristic>");
    r = language_clause(b, l + 1);
    if (!r) r = parameter_style_clause(b, l + 1);
    if (!r) r = parseTokens(b, 0, SPECIFIC, _SPECIFIC_NAME_);
    if (!r) r = deterministic_characteristic(b, l + 1);
    if (!r) r = SQL_data_access_indication(b, l + 1);
    if (!r) r = null_call_clause(b, l + 1);
    if (!r) r = dynamic_result_sets_characteristic(b, l + 1);
    if (!r) r = savepoint_level_indication(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <routine characteristic>... ]
  public static boolean routine_characteristics(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_characteristics")) return false;
    Marker m = enter_section_(b, l, _NONE_, ROUTINE_CHARACTERISTICS, "<routine characteristics>");
    consumeToken(b, _ROUTINE_CHARACTERISTIC____);
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  /* ********************************************************** */
  // <routine name> <SQL argument list>
  public static boolean routine_invocation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_invocation")) return false;
    if (!nextTokenIs(b, _ROUTINE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = routine_name(b, l + 1);
    r = r && SQL_argument_list(b, l + 1);
    exit_section_(b, m, ROUTINE_INVOCATION, r);
    return r;
  }

  /* ********************************************************** */
  // [ <schema name> <period> ] <qualified identifier>
  public static boolean routine_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_name")) return false;
    if (!nextTokenIs(b, "<routine name>", _QUALIFIED_IDENTIFIER_, _SCHEMA_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROUTINE_NAME, "<routine name>");
    r = routine_name_0(b, l + 1);
    r = r && qualified_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <schema name> <period> ]
  private static boolean routine_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_name_0")) return false;
    schema_name(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // ROUTINE
  // 	|	FUNCTION
  // 	|	PROCEDURE
  // 	|	[ INSTANCE | STATIC | CONSTRUCTOR ] METHOD
  public static boolean routine_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROUTINE_TYPE, "<routine type>");
    r = consumeToken(b, ROUTINE);
    if (!r) r = consumeToken(b, FUNCTION);
    if (!r) r = consumeToken(b, PROCEDURE);
    if (!r) r = routine_type_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ INSTANCE | STATIC | CONSTRUCTOR ] METHOD
  private static boolean routine_type_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_type_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = routine_type_3_0(b, l + 1);
    r = r && consumeToken(b, METHOD);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ INSTANCE | STATIC | CONSTRUCTOR ]
  private static boolean routine_type_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_type_3_0")) return false;
    routine_type_3_0_0(b, l + 1);
    return true;
  }

  // INSTANCE | STATIC | CONSTRUCTOR
  private static boolean routine_type_3_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "routine_type_3_0_0")) return false;
    boolean r;
    r = consumeToken(b, INSTANCE);
    if (!r) r = consumeToken(b, STATIC);
    if (!r) r = consumeToken(b, CONSTRUCTOR);
    return r;
  }

  /* ********************************************************** */
  // <subquery>
  public static boolean row_subquery(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_subquery")) return false;
    if (!nextTokenIs(b, _SUBQUERY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = subquery(b, l + 1);
    exit_section_(b, m, ROW_SUBQUERY, r);
    return r;
  }

  /* ********************************************************** */
  // ROW <row type body>
  public static boolean row_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_type")) return false;
    if (!nextTokenIs(b, ROW)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ROW, _ROW_TYPE_BODY_);
    exit_section_(b, m, ROW_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <field definition> [ { <comma> <field definition> }... ] <right paren>
  public static boolean row_type_body(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_type_body")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && field_definition(b, l + 1);
    r = r && row_type_body_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, ROW_TYPE_BODY, r);
    return r;
  }

  // [ { <comma> <field definition> }... ]
  private static boolean row_type_body_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_type_body_2")) return false;
    row_type_body_2_0(b, l + 1);
    return true;
  }

  // <comma> <field definition>
  private static boolean row_type_body_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_type_body_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && field_definition(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <common value expression>
  // 	|	<boolean value expression>
  // 	|	<explicit row value constructor>
  public static boolean row_value_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_constructor")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROW_VALUE_CONSTRUCTOR, "<row value constructor>");
    r = common_value_expression(b, l + 1);
    if (!r) r = boolean_value_expression(b, l + 1);
    if (!r) r = explicit_row_value_constructor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  public static boolean row_value_constructor_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_constructor_element")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    exit_section_(b, m, ROW_VALUE_CONSTRUCTOR_ELEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <row value constructor element> [ { <comma> <row value constructor element> }... ]
  public static boolean row_value_constructor_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_constructor_element_list")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_CONSTRUCTOR_ELEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_constructor_element(b, l + 1);
    r = r && row_value_constructor_element_list_1(b, l + 1);
    exit_section_(b, m, ROW_VALUE_CONSTRUCTOR_ELEMENT_LIST, r);
    return r;
  }

  // [ { <comma> <row value constructor element> }... ]
  private static boolean row_value_constructor_element_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_constructor_element_list_1")) return false;
    row_value_constructor_element_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <row value constructor element>
  private static boolean row_value_constructor_element_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_constructor_element_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && row_value_constructor_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <common value expression>
  // 	|	<boolean predicand>
  // 	|	<explicit row value constructor>
  public static boolean row_value_constructor_predicand(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_constructor_predicand")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROW_VALUE_CONSTRUCTOR_PREDICAND, "<row value constructor predicand>");
    r = common_value_expression(b, l + 1);
    if (!r) r = boolean_predicand(b, l + 1);
    if (!r) r = explicit_row_value_constructor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value special case>
  // 	|	<explicit row value constructor>
  public static boolean row_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_expression")) return false;
    if (!nextTokenIs(b, "<row value expression>", _EXPLICIT_ROW_VALUE_CONSTRUCTOR_, _ROW_VALUE_SPECIAL_CASE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROW_VALUE_EXPRESSION, "<row value expression>");
    r = row_value_special_case(b, l + 1);
    if (!r) r = explicit_row_value_constructor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <table row value expression> [ { <comma> <table row value expression> }... ]
  public static boolean row_value_expression_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_expression_list")) return false;
    if (!nextTokenIs(b, _TABLE_ROW_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_row_value_expression(b, l + 1);
    r = r && row_value_expression_list_1(b, l + 1);
    exit_section_(b, m, ROW_VALUE_EXPRESSION_LIST, r);
    return r;
  }

  // [ { <comma> <table row value expression> }... ]
  private static boolean row_value_expression_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_expression_list_1")) return false;
    row_value_expression_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <table row value expression>
  private static boolean row_value_expression_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_expression_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && table_row_value_expression(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <row value special case>
  // 	|	<row value constructor predicand>
  public static boolean row_value_predicand(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_predicand")) return false;
    if (!nextTokenIs(b, "<row value predicand>", _ROW_VALUE_CONSTRUCTOR_PREDICAND_, _ROW_VALUE_SPECIAL_CASE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, ROW_VALUE_PREDICAND, "<row value predicand>");
    r = row_value_special_case(b, l + 1);
    if (!r) r = row_value_constructor_predicand(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand>
  public static boolean row_value_predicand_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_predicand_1")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    exit_section_(b, m, ROW_VALUE_PREDICAND_1, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand>
  public static boolean row_value_predicand_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_predicand_2")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    exit_section_(b, m, ROW_VALUE_PREDICAND_2, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand>
  public static boolean row_value_predicand_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_predicand_3")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    exit_section_(b, m, ROW_VALUE_PREDICAND_3, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand>
  public static boolean row_value_predicand_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_predicand_4")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    exit_section_(b, m, ROW_VALUE_PREDICAND_4, r);
    return r;
  }

  /* ********************************************************** */
  // <nonparenthesized value expression primary>
  public static boolean row_value_special_case(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "row_value_special_case")) return false;
    if (!nextTokenIs(b, _NONPARENTHESIZED_VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = nonparenthesized_value_expression_primary(b, l + 1);
    exit_section_(b, m, ROW_VALUE_SPECIAL_CASE, r);
    return r;
  }

  /* ********************************************************** */
  // TABLESAMPLE <sample method> <left paren> <sample percentage> <right paren> [ <repeatable clause> ]
  public static boolean sample_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sample_clause")) return false;
    if (!nextTokenIs(b, TABLESAMPLE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLESAMPLE, _SAMPLE_METHOD_, _LEFT_PAREN_, _SAMPLE_PERCENTAGE_, _RIGHT_PAREN_);
    r = r && sample_clause_5(b, l + 1);
    exit_section_(b, m, SAMPLE_CLAUSE, r);
    return r;
  }

  // [ <repeatable clause> ]
  private static boolean sample_clause_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sample_clause_5")) return false;
    repeatable_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // BERNOULLI | SYSTEM
  public static boolean sample_method(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sample_method")) return false;
    if (!nextTokenIs(b, "<sample method>", BERNOULLI, SYSTEM)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SAMPLE_METHOD, "<sample method>");
    r = consumeToken(b, BERNOULLI);
    if (!r) r = consumeToken(b, SYSTEM);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean sample_percentage(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sample_percentage")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, SAMPLE_PERCENTAGE, r);
    return r;
  }

  /* ********************************************************** */
  // TO SAVEPOINT <savepoint specifier>
  public static boolean savepoint_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "savepoint_clause")) return false;
    if (!nextTokenIs(b, TO)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TO, SAVEPOINT, _SAVEPOINT_SPECIFIER_);
    exit_section_(b, m, SAVEPOINT_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // NEW SAVEPOINT LEVEL | OLD SAVEPOINT LEVEL
  public static boolean savepoint_level_indication(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "savepoint_level_indication")) return false;
    if (!nextTokenIs(b, "<savepoint level indication>", NEW, OLD)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SAVEPOINT_LEVEL_INDICATION, "<savepoint level indication>");
    r = parseTokens(b, 0, NEW, SAVEPOINT, LEVEL);
    if (!r) r = parseTokens(b, 0, OLD, SAVEPOINT, LEVEL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean savepoint_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "savepoint_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, SAVEPOINT_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <savepoint name>
  public static boolean savepoint_specifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "savepoint_specifier")) return false;
    if (!nextTokenIs(b, _SAVEPOINT_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = savepoint_name(b, l + 1);
    exit_section_(b, m, SAVEPOINT_SPECIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // SAVEPOINT <savepoint specifier>
  public static boolean savepoint_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "savepoint_statement")) return false;
    if (!nextTokenIs(b, SAVEPOINT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SAVEPOINT, _SAVEPOINT_SPECIFIER_);
    exit_section_(b, m, SAVEPOINT_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <subquery>
  public static boolean scalar_subquery(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "scalar_subquery")) return false;
    if (!nextTokenIs(b, _SUBQUERY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = subquery(b, l + 1);
    exit_section_(b, m, SCALAR_SUBQUERY, r);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean scale(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "scale")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, SCALE, r);
    return r;
  }

  /* ********************************************************** */
  // <authorization identifier>
  public static boolean schema_authorization_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_authorization_identifier")) return false;
    if (!nextTokenIs(b, _AUTHORIZATION_IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = authorization_identifier(b, l + 1);
    exit_section_(b, m, SCHEMA_AUTHORIZATION_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // <schema character set specification>
  // 	|	<schema path specification>
  // 	|	<schema character set specification> <schema path specification>
  // 	|	<schema path specification> <schema character set specification>
  public static boolean schema_character_set_or_path(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_character_set_or_path")) return false;
    if (!nextTokenIs(b, "<schema character set or path>", _SCHEMA_CHARACTER_SET_SPECIFICATION_, _SCHEMA_PATH_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SCHEMA_CHARACTER_SET_OR_PATH, "<schema character set or path>");
    r = schema_character_set_specification(b, l + 1);
    if (!r) r = schema_path_specification(b, l + 1);
    if (!r) r = schema_character_set_specification(b, l + 1);
    if (!r) r = schema_path_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DEFAULT CHARACTER SET <character set specification>
  public static boolean schema_character_set_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_character_set_specification")) return false;
    if (!nextTokenIs(b, DEFAULT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DEFAULT, CHARACTER, SET, _CHARACTER_SET_SPECIFICATION_);
    exit_section_(b, m, SCHEMA_CHARACTER_SET_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE SCHEMA <schema name clause> [ <schema character set or path> ] [ <schema element>... ]
  public static boolean schema_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, SCHEMA, _SCHEMA_NAME_CLAUSE_);
    r = r && schema_definition_3(b, l + 1);
    r = r && schema_definition_4(b, l + 1);
    exit_section_(b, m, SCHEMA_DEFINITION, r);
    return r;
  }

  // [ <schema character set or path> ]
  private static boolean schema_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_definition_3")) return false;
    schema_character_set_or_path(b, l + 1);
    return true;
  }

  // [ <schema element>... ]
  private static boolean schema_definition_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_definition_4")) return false;
    consumeToken(b, _SCHEMA_ELEMENT____);
    return true;
  }

  /* ********************************************************** */
  // <table definition>
  // 	|	<view definition>
  // 	|	<domain definition>
  // 	|	<character set definition>
  // 	|	<collation definition>
  // 	|	<transliteration definition>
  // 	|	<assertion definition>
  // 	|	<trigger definition>
  // 	|	<user-defined type definition>
  // 	|	<user-defined cast definition>
  // 	|	<user-defined ordering definition>
  // 	|	<transform definition>
  // 	|	<schema routine>
  // 	|	<sequence generator definition>
  // 	|	<grant statement>
  // 	|	<role definition>
  public static boolean schema_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_element")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SCHEMA_ELEMENT, "<schema element>");
    r = table_definition(b, l + 1);
    if (!r) r = view_definition(b, l + 1);
    if (!r) r = domain_definition(b, l + 1);
    if (!r) r = character_set_definition(b, l + 1);
    if (!r) r = collation_definition(b, l + 1);
    if (!r) r = transliteration_definition(b, l + 1);
    if (!r) r = assertion_definition(b, l + 1);
    if (!r) r = trigger_definition(b, l + 1);
    if (!r) r = user_defined_type_definition(b, l + 1);
    if (!r) r = user_defined_cast_definition(b, l + 1);
    if (!r) r = user_defined_ordering_definition(b, l + 1);
    if (!r) r = transform_definition(b, l + 1);
    if (!r) r = schema_routine(b, l + 1);
    if (!r) r = sequence_generator_definition(b, l + 1);
    if (!r) r = grant_statement(b, l + 1);
    if (!r) r = role_definition(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CREATE <SQL-invoked function>
  public static boolean schema_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_function")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, _SQL_INVOKED_FUNCTION_);
    exit_section_(b, m, SCHEMA_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // [ <catalog name> <period> ] <unqualified schema name>
  public static boolean schema_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_name")) return false;
    if (!nextTokenIs(b, "<schema name>", _CATALOG_NAME_, _UNQUALIFIED_SCHEMA_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SCHEMA_NAME, "<schema name>");
    r = schema_name_0(b, l + 1);
    r = r && consumeToken(b, _UNQUALIFIED_SCHEMA_NAME_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <catalog name> <period> ]
  private static boolean schema_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_name_0")) return false;
    catalog_name(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // SCHEMA <value specification>
  public static boolean schema_name_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_name_characteristic")) return false;
    if (!nextTokenIs(b, SCHEMA)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SCHEMA, _VALUE_SPECIFICATION_);
    exit_section_(b, m, SCHEMA_NAME_CHARACTERISTIC, r);
    return r;
  }

  /* ********************************************************** */
  // <schema name>
  // 	|	AUTHORIZATION <schema authorization identifier>
  // 	|	<schema name> AUTHORIZATION <schema authorization identifier>
  public static boolean schema_name_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_name_clause")) return false;
    if (!nextTokenIs(b, "<schema name clause>", AUTHORIZATION, _SCHEMA_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SCHEMA_NAME_CLAUSE, "<schema name clause>");
    r = schema_name(b, l + 1);
    if (!r) r = parseTokens(b, 0, AUTHORIZATION, _SCHEMA_AUTHORIZATION_IDENTIFIER_);
    if (!r) r = schema_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <schema name> [ { <comma> <schema name> }... ]
  public static boolean schema_name_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_name_list")) return false;
    if (!nextTokenIs(b, _SCHEMA_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_name(b, l + 1);
    r = r && schema_name_list_1(b, l + 1);
    exit_section_(b, m, SCHEMA_NAME_LIST, r);
    return r;
  }

  // [ { <comma> <schema name> }... ]
  private static boolean schema_name_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_name_list_1")) return false;
    schema_name_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <schema name>
  private static boolean schema_name_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_name_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && schema_name(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <path specification>
  public static boolean schema_path_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_path_specification")) return false;
    if (!nextTokenIs(b, _PATH_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = path_specification(b, l + 1);
    exit_section_(b, m, SCHEMA_PATH_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE <SQL-invoked procedure>
  public static boolean schema_procedure(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_procedure")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, _SQL_INVOKED_PROCEDURE_);
    exit_section_(b, m, SCHEMA_PROCEDURE, r);
    return r;
  }

  /* ********************************************************** */
  // [ <schema name> <period> ] <qualified identifier>
  public static boolean schema_qualified_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_qualified_name")) return false;
    if (!nextTokenIs(b, "<schema qualified name>", _QUALIFIED_IDENTIFIER_, _SCHEMA_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SCHEMA_QUALIFIED_NAME, "<schema qualified name>");
    r = schema_qualified_name_0(b, l + 1);
    r = r && qualified_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <schema name> <period> ]
  private static boolean schema_qualified_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_qualified_name_0")) return false;
    schema_name(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean schema_qualified_routine_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_qualified_routine_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, SCHEMA_QUALIFIED_ROUTINE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // [ <schema name> <period> ] <qualified identifier>
  public static boolean schema_qualified_type_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_qualified_type_name")) return false;
    if (!nextTokenIs(b, "<schema qualified type name>", _QUALIFIED_IDENTIFIER_, _SCHEMA_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SCHEMA_QUALIFIED_TYPE_NAME, "<schema qualified type name>");
    r = schema_qualified_type_name_0(b, l + 1);
    r = r && qualified_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <schema name> <period> ]
  private static boolean schema_qualified_type_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_qualified_type_name_0")) return false;
    schema_name(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <schema procedure> | <schema function>
  public static boolean schema_routine(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_routine")) return false;
    if (!nextTokenIs(b, "<schema routine>", _SCHEMA_FUNCTION_, _SCHEMA_PROCEDURE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SCHEMA_ROUTINE, "<schema routine>");
    r = schema_procedure(b, l + 1);
    if (!r) r = schema_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <user-defined type name>
  public static boolean schema_resolved_user_defined_type_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "schema_resolved_user_defined_type_name")) return false;
    if (!nextTokenIs(b, _USER_DEFINED_TYPE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = user_defined_type_name(b, l + 1);
    exit_section_(b, m, SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // SCOPE <table name>
  public static boolean scope_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "scope_clause")) return false;
    if (!nextTokenIs(b, SCOPE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SCOPE, _TABLE_NAME_);
    exit_section_(b, m, SCOPE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // GLOBAL | LOCAL
  public static boolean scope_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "scope_option")) return false;
    if (!nextTokenIs(b, "<scope option>", GLOBAL, LOCAL)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SCOPE_OPTION, "<scope option>");
    r = consumeToken(b, GLOBAL);
    if (!r) r = consumeToken(b, LOCAL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SEARCH <recursive search order> SET <sequence column>
  public static boolean search_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "search_clause")) return false;
    if (!nextTokenIs(b, SEARCH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SEARCH, _RECURSIVE_SEARCH_ORDER_, SET, _SEQUENCE_COLUMN_);
    exit_section_(b, m, SEARCH_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <boolean value expression>
  public static boolean search_condition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "search_condition")) return false;
    if (!nextTokenIs(b, _BOOLEAN_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = boolean_value_expression(b, l + 1);
    exit_section_(b, m, SEARCH_CONDITION, r);
    return r;
  }

  /* ********************************************************** */
  // <search clause>
  // 	|	<cycle clause>
  // 	|	<search clause> <cycle clause>
  public static boolean search_or_cycle_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "search_or_cycle_clause")) return false;
    if (!nextTokenIs(b, "<search or cycle clause>", _CYCLE_CLAUSE_, _SEARCH_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SEARCH_OR_CYCLE_CLAUSE, "<search or cycle clause>");
    r = search_clause(b, l + 1);
    if (!r) r = cycle_clause(b, l + 1);
    if (!r) r = search_clause(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CASE <searched when clause>...
  public static boolean searched_case(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "searched_case")) return false;
    if (!nextTokenIs(b, CASE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CASE, _SEARCHED_WHEN_CLAUSE_);
    exit_section_(b, m, SEARCHED_CASE, r);
    return r;
  }

  /* ********************************************************** */
  // WHEN <search condition> THEN <result>
  public static boolean searched_when_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "searched_when_clause")) return false;
    if (!nextTokenIs(b, WHEN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WHEN, _SEARCH_CONDITION_, THEN, _RESULT_);
    exit_section_(b, m, SEARCHED_WHEN_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean seconds_fraction(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "seconds_fraction")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, SECONDS_FRACTION, r);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean seconds_integer_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "seconds_integer_value")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, SECONDS_INTEGER_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <seconds integer value> [ <period> [ <seconds fraction> ] ]
  public static boolean seconds_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "seconds_value")) return false;
    if (!nextTokenIs(b, _SECONDS_INTEGER_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = seconds_integer_value(b, l + 1);
    r = r && seconds_value_1(b, l + 1);
    exit_section_(b, m, SECONDS_VALUE, r);
    return r;
  }

  // [ <period> [ <seconds fraction> ] ]
  private static boolean seconds_value_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "seconds_value_1")) return false;
    seconds_value_1_0(b, l + 1);
    return true;
  }

  // <period> [ <seconds fraction> ]
  private static boolean seconds_value_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "seconds_value_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = period(b, l + 1);
    r = r && seconds_value_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <seconds fraction> ]
  private static boolean seconds_value_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "seconds_value_1_0_1")) return false;
    seconds_fraction(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <asterisk> | <select sublist> [ { <comma> <select sublist> }... ]
  public static boolean select_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_list")) return false;
    if (!nextTokenIs(b, "<select list>", _ASTERISK_, _SELECT_SUBLIST_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SELECT_LIST, "<select list>");
    r = asterisk(b, l + 1);
    if (!r) r = select_list_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <select sublist> [ { <comma> <select sublist> }... ]
  private static boolean select_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_list_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = select_sublist(b, l + 1);
    r = r && select_list_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <select sublist> }... ]
  private static boolean select_list_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_list_1_1")) return false;
    select_list_1_1_0(b, l + 1);
    return true;
  }

  // <comma> <select sublist>
  private static boolean select_list_1_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_list_1_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && select_sublist(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // SELECT [ <set quantifier> ] <select list> INTO <select target list> <table expression>
  public static boolean select_statement_single_row(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_statement_single_row")) return false;
    if (!nextTokenIs(b, SELECT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, SELECT);
    r = r && select_statement_single_row_1(b, l + 1);
    r = r && select_list(b, l + 1);
    r = r && consumeTokens(b, 0, INTO, _SELECT_TARGET_LIST_, _TABLE_EXPRESSION_);
    exit_section_(b, m, SELECT_STATEMENT_SINGLE_ROW, r);
    return r;
  }

  // [ <set quantifier> ]
  private static boolean select_statement_single_row_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_statement_single_row_1")) return false;
    set_quantifier(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <derived column> | <qualified asterisk>
  public static boolean select_sublist(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_sublist")) return false;
    if (!nextTokenIs(b, "<select sublist>", _DERIVED_COLUMN_, _QUALIFIED_ASTERISK_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SELECT_SUBLIST, "<select sublist>");
    r = derived_column(b, l + 1);
    if (!r) r = qualified_asterisk(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <target specification> [ { <comma> <target specification> }... ]
  public static boolean select_target_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_target_list")) return false;
    if (!nextTokenIs(b, _TARGET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = target_specification(b, l + 1);
    r = r && select_target_list_1(b, l + 1);
    exit_section_(b, m, SELECT_TARGET_LIST, r);
    return r;
  }

  // [ { <comma> <target specification> }... ]
  private static boolean select_target_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_target_list_1")) return false;
    select_target_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <target specification>
  private static boolean select_target_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "select_target_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && target_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <column name>
  public static boolean self_referencing_column_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "self_referencing_column_name")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    exit_section_(b, m, SELF_REFERENCING_COLUMN_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // REF IS <self-referencing column name> <reference generation>
  public static boolean self_referencing_column_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "self_referencing_column_specification")) return false;
    if (!nextTokenIs(b, REF)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, REF, IS, _SELF_REFERENCING_COLUMN_NAME_, _REFERENCE_GENERATION_);
    exit_section_(b, m, SELF_REFERENCING_COLUMN_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  public static boolean semicolon(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, SEMICOLON, true);
    return true;
  }

  /* ********************************************************** */
  // <comment> | <white space>
  public static boolean separator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "separator")) return false;
    if (!nextTokenIs(b, "<separator>", _COMMENT_, _WHITE_SPACE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SEPARATOR, "<separator>");
    r = comment(b, l + 1);
    if (!r) r = consumeToken(b, _WHITE_SPACE_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <column name>
  public static boolean sequence_column(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_column")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    exit_section_(b, m, SEQUENCE_COLUMN, r);
    return r;
  }

  /* ********************************************************** */
  // CYCLE | NO CYCLE
  public static boolean sequence_generator_cycle_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_cycle_option")) return false;
    if (!nextTokenIs(b, "<sequence generator cycle option>", CYCLE, NO)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SEQUENCE_GENERATOR_CYCLE_OPTION, "<sequence generator cycle option>");
    r = consumeToken(b, CYCLE);
    if (!r) r = parseTokens(b, 0, NO, CYCLE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // AS <data type>
  public static boolean sequence_generator_data_type_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_data_type_option")) return false;
    if (!nextTokenIs(b, AS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, AS, _DATA_TYPE_);
    exit_section_(b, m, SEQUENCE_GENERATOR_DATA_TYPE_OPTION, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE SEQUENCE <sequence generator name> [ <sequence generator options> ]
  public static boolean sequence_generator_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, SEQUENCE, _SEQUENCE_GENERATOR_NAME_);
    r = r && sequence_generator_definition_3(b, l + 1);
    exit_section_(b, m, SEQUENCE_GENERATOR_DEFINITION, r);
    return r;
  }

  // [ <sequence generator options> ]
  private static boolean sequence_generator_definition_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_definition_3")) return false;
    sequence_generator_options(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <signed numeric literal>
  public static boolean sequence_generator_increment(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_increment")) return false;
    if (!nextTokenIs(b, _SIGNED_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = signed_numeric_literal(b, l + 1);
    exit_section_(b, m, SEQUENCE_GENERATOR_INCREMENT, r);
    return r;
  }

  /* ********************************************************** */
  // INCREMENT BY <sequence generator increment>
  public static boolean sequence_generator_increment_by_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_increment_by_option")) return false;
    if (!nextTokenIs(b, INCREMENT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, INCREMENT, BY, _SEQUENCE_GENERATOR_INCREMENT_);
    exit_section_(b, m, SEQUENCE_GENERATOR_INCREMENT_BY_OPTION, r);
    return r;
  }

  /* ********************************************************** */
  // <signed numeric literal>
  public static boolean sequence_generator_max_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_max_value")) return false;
    if (!nextTokenIs(b, _SIGNED_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = signed_numeric_literal(b, l + 1);
    exit_section_(b, m, SEQUENCE_GENERATOR_MAX_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // MAXVALUE <sequence generator max value>
  // 	|	NO MAXVALUE
  public static boolean sequence_generator_maxvalue_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_maxvalue_option")) return false;
    if (!nextTokenIs(b, "<sequence generator maxvalue option>", MAXVALUE, NO)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SEQUENCE_GENERATOR_MAXVALUE_OPTION, "<sequence generator maxvalue option>");
    r = parseTokens(b, 0, MAXVALUE, _SEQUENCE_GENERATOR_MAX_VALUE_);
    if (!r) r = parseTokens(b, 0, NO, MAXVALUE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <signed numeric literal>
  public static boolean sequence_generator_min_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_min_value")) return false;
    if (!nextTokenIs(b, _SIGNED_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = signed_numeric_literal(b, l + 1);
    exit_section_(b, m, SEQUENCE_GENERATOR_MIN_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // MINVALUE <sequence generator min value> | NO MINVALUE
  public static boolean sequence_generator_minvalue_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_minvalue_option")) return false;
    if (!nextTokenIs(b, "<sequence generator minvalue option>", MINVALUE, NO)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SEQUENCE_GENERATOR_MINVALUE_OPTION, "<sequence generator minvalue option>");
    r = parseTokens(b, 0, MINVALUE, _SEQUENCE_GENERATOR_MIN_VALUE_);
    if (!r) r = parseTokens(b, 0, NO, MINVALUE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean sequence_generator_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, SEQUENCE_GENERATOR_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <sequence generator data type option> | <common sequence generator options>
  public static boolean sequence_generator_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_option")) return false;
    if (!nextTokenIs(b, "<sequence generator option>", _COMMON_SEQUENCE_GENERATOR_OPTIONS_, _SEQUENCE_GENERATOR_DATA_TYPE_OPTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SEQUENCE_GENERATOR_OPTION, "<sequence generator option>");
    r = sequence_generator_data_type_option(b, l + 1);
    if (!r) r = common_sequence_generator_options(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <sequence generator option> ...
  public static boolean sequence_generator_options(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_options")) return false;
    if (!nextTokenIs(b, _SEQUENCE_GENERATOR_OPTION_____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _SEQUENCE_GENERATOR_OPTION_____);
    exit_section_(b, m, SEQUENCE_GENERATOR_OPTIONS, r);
    return r;
  }

  /* ********************************************************** */
  // <signed numeric literal>
  public static boolean sequence_generator_restart_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_restart_value")) return false;
    if (!nextTokenIs(b, _SIGNED_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = signed_numeric_literal(b, l + 1);
    exit_section_(b, m, SEQUENCE_GENERATOR_RESTART_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // <signed numeric literal>
  public static boolean sequence_generator_start_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_start_value")) return false;
    if (!nextTokenIs(b, _SIGNED_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = signed_numeric_literal(b, l + 1);
    exit_section_(b, m, SEQUENCE_GENERATOR_START_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // START WITH <sequence generator start value>
  public static boolean sequence_generator_start_with_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sequence_generator_start_with_option")) return false;
    if (!nextTokenIs(b, START)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, START, WITH, _SEQUENCE_GENERATOR_START_VALUE_);
    exit_section_(b, m, SEQUENCE_GENERATOR_START_WITH_OPTION, r);
    return r;
  }

  /* ********************************************************** */
  // <transaction characteristics>
  public static boolean session_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "session_characteristic")) return false;
    if (!nextTokenIs(b, _TRANSACTION_CHARACTERISTICS_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = transaction_characteristics(b, l + 1);
    exit_section_(b, m, SESSION_CHARACTERISTIC, r);
    return r;
  }

  /* ********************************************************** */
  // <session characteristic> [ { <comma> <session characteristic> }... ]
  public static boolean session_characteristic_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "session_characteristic_list")) return false;
    if (!nextTokenIs(b, _SESSION_CHARACTERISTIC_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = session_characteristic(b, l + 1);
    r = r && session_characteristic_list_1(b, l + 1);
    exit_section_(b, m, SESSION_CHARACTERISTIC_LIST, r);
    return r;
  }

  // [ { <comma> <session characteristic> }... ]
  private static boolean session_characteristic_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "session_characteristic_list_1")) return false;
    session_characteristic_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <session characteristic>
  private static boolean session_characteristic_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "session_characteristic_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && session_characteristic(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // SET <catalog name characteristic>
  public static boolean set_catalog_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_catalog_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, _CATALOG_NAME_CHARACTERISTIC_);
    exit_section_(b, m, SET_CATALOG_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <multiple column assignment>
  // 	|	<set target> <equals operator> <update source>
  public static boolean set_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_clause")) return false;
    if (!nextTokenIs(b, "<set clause>", _MULTIPLE_COLUMN_ASSIGNMENT_, _SET_TARGET_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SET_CLAUSE, "<set clause>");
    r = multiple_column_assignment(b, l + 1);
    if (!r) r = set_target(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <set clause> [ { <comma> <set clause> }... ]
  public static boolean set_clause_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_clause_list")) return false;
    if (!nextTokenIs(b, _SET_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = set_clause(b, l + 1);
    r = r && set_clause_list_1(b, l + 1);
    exit_section_(b, m, SET_CLAUSE_LIST, r);
    return r;
  }

  // [ { <comma> <set clause> }... ]
  private static boolean set_clause_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_clause_list_1")) return false;
    set_clause_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <set clause>
  private static boolean set_clause_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_clause_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && set_clause(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // SET <default clause>
  public static boolean set_column_default_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_column_default_clause")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, _DEFAULT_CLAUSE_);
    exit_section_(b, m, SET_COLUMN_DEFAULT_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // SET CONNECTION <connection object>
  public static boolean set_connection_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_connection_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, CONNECTION, _CONNECTION_OBJECT_);
    exit_section_(b, m, SET_CONNECTION_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // SET CONSTRAINTS <constraint name list> { DEFERRED | IMMEDIATE }
  public static boolean set_constraints_mode_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_constraints_mode_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, CONSTRAINTS, _CONSTRAINT_NAME_LIST_);
    r = r && set_constraints_mode_statement_3(b, l + 1);
    exit_section_(b, m, SET_CONSTRAINTS_MODE_STATEMENT, r);
    return r;
  }

  // DEFERRED | IMMEDIATE
  private static boolean set_constraints_mode_statement_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_constraints_mode_statement_3")) return false;
    boolean r;
    r = consumeToken(b, DEFERRED);
    if (!r) r = consumeToken(b, IMMEDIATE);
    return r;
  }

  /* ********************************************************** */
  // <set header information> [ { <comma> <set header information> }... ]
  // 	|	VALUE <item number> <set item information> [ { <comma> <set item information> }... ]
  public static boolean set_descriptor_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_descriptor_information")) return false;
    if (!nextTokenIs(b, "<set descriptor information>", VALUE, _SET_HEADER_INFORMATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SET_DESCRIPTOR_INFORMATION, "<set descriptor information>");
    r = set_descriptor_information_0(b, l + 1);
    if (!r) r = set_descriptor_information_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <set header information> [ { <comma> <set header information> }... ]
  private static boolean set_descriptor_information_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_descriptor_information_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = set_header_information(b, l + 1);
    r = r && set_descriptor_information_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <set header information> }... ]
  private static boolean set_descriptor_information_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_descriptor_information_0_1")) return false;
    set_descriptor_information_0_1_0(b, l + 1);
    return true;
  }

  // <comma> <set header information>
  private static boolean set_descriptor_information_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_descriptor_information_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && set_header_information(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // VALUE <item number> <set item information> [ { <comma> <set item information> }... ]
  private static boolean set_descriptor_information_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_descriptor_information_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, VALUE, _ITEM_NUMBER_, _SET_ITEM_INFORMATION_);
    r = r && set_descriptor_information_1_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <set item information> }... ]
  private static boolean set_descriptor_information_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_descriptor_information_1_3")) return false;
    set_descriptor_information_1_3_0(b, l + 1);
    return true;
  }

  // <comma> <set item information>
  private static boolean set_descriptor_information_1_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_descriptor_information_1_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && set_item_information(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // SET <default clause>
  public static boolean set_domain_default_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_domain_default_clause")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, _DEFAULT_CLAUSE_);
    exit_section_(b, m, SET_DOMAIN_DEFAULT_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <aggregate function> | <grouping operation>
  public static boolean set_function_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_function_specification")) return false;
    if (!nextTokenIs(b, "<set function specification>", _AGGREGATE_FUNCTION_, _GROUPING_OPERATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SET_FUNCTION_SPECIFICATION, "<set function specification>");
    r = aggregate_function(b, l + 1);
    if (!r) r = grouping_operation(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <computational operation>
  public static boolean set_function_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_function_type")) return false;
    if (!nextTokenIs(b, _COMPUTATIONAL_OPERATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = computational_operation(b, l + 1);
    exit_section_(b, m, SET_FUNCTION_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // <header item name> <equals operator> <simple value specification 1>
  public static boolean set_header_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_header_information")) return false;
    if (!nextTokenIs(b, _HEADER_ITEM_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = header_item_name(b, l + 1);
    r = r && equals_operator(b, l + 1);
    r = r && simple_value_specification_1(b, l + 1);
    exit_section_(b, m, SET_HEADER_INFORMATION, r);
    return r;
  }

  /* ********************************************************** */
  // <descriptor item name> <equals operator> <simple value specification 2>
  public static boolean set_item_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_item_information")) return false;
    if (!nextTokenIs(b, _DESCRIPTOR_ITEM_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = descriptor_item_name(b, l + 1);
    r = r && equals_operator(b, l + 1);
    r = r && simple_value_specification_2(b, l + 1);
    exit_section_(b, m, SET_ITEM_INFORMATION, r);
    return r;
  }

  /* ********************************************************** */
  // SET TIME ZONE <set time zone value>
  public static boolean set_local_time_zone_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_local_time_zone_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, TIME, ZONE, _SET_TIME_ZONE_VALUE_);
    exit_section_(b, m, SET_LOCAL_TIME_ZONE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // SET <character set name characteristic>
  public static boolean set_names_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_names_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, _CHARACTER_SET_NAME_CHARACTERISTIC_);
    exit_section_(b, m, SET_NAMES_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // SET <SQL-path characteristic>
  public static boolean set_path_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_path_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, _SQL_PATH_CHARACTERISTIC_);
    exit_section_(b, m, SET_PATH_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <set predicate part 2>
  public static boolean set_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && set_predicate_part_2(b, l + 1);
    exit_section_(b, m, SET_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // IS [ NOT ] A SET
  public static boolean set_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_predicate_part_2")) return false;
    if (!nextTokenIs(b, IS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, IS);
    r = r && set_predicate_part_2_1(b, l + 1);
    r = r && consumeTokens(b, 0, A, SET);
    exit_section_(b, m, SET_PREDICATE_PART_2, r);
    return r;
  }

  // [ NOT ]
  private static boolean set_predicate_part_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_predicate_part_2_1")) return false;
    consumeToken(b, NOT);
    return true;
  }

  /* ********************************************************** */
  // DISTINCT | ALL
  public static boolean set_quantifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_quantifier")) return false;
    if (!nextTokenIs(b, "<set quantifier>", ALL, DISTINCT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SET_QUANTIFIER, "<set quantifier>");
    r = consumeToken(b, DISTINCT);
    if (!r) r = consumeToken(b, ALL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SET ROLE <role specification>
  public static boolean set_role_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_role_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, ROLE, _ROLE_SPECIFICATION_);
    exit_section_(b, m, SET_ROLE_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // SET <schema name characteristic>
  public static boolean set_schema_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_schema_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, _SCHEMA_NAME_CHARACTERISTIC_);
    exit_section_(b, m, SET_SCHEMA_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // SET SESSION CHARACTERISTICS AS <session characteristic list>
  public static boolean set_session_characteristics_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_session_characteristics_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, SESSION, CHARACTERISTICS, AS, _SESSION_CHARACTERISTIC_LIST_);
    exit_section_(b, m, SET_SESSION_CHARACTERISTICS_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // SET COLLATION <collation specification> [ FOR <character set specification list> ]
  // 	|	SET NO COLLATION [ FOR <character set specification list> ]
  public static boolean set_session_collation_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_session_collation_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = set_session_collation_statement_0(b, l + 1);
    if (!r) r = set_session_collation_statement_1(b, l + 1);
    exit_section_(b, m, SET_SESSION_COLLATION_STATEMENT, r);
    return r;
  }

  // SET COLLATION <collation specification> [ FOR <character set specification list> ]
  private static boolean set_session_collation_statement_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_session_collation_statement_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, COLLATION, _COLLATION_SPECIFICATION_);
    r = r && set_session_collation_statement_0_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ FOR <character set specification list> ]
  private static boolean set_session_collation_statement_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_session_collation_statement_0_3")) return false;
    parseTokens(b, 0, FOR, _CHARACTER_SET_SPECIFICATION_LIST_);
    return true;
  }

  // SET NO COLLATION [ FOR <character set specification list> ]
  private static boolean set_session_collation_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_session_collation_statement_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, NO, COLLATION);
    r = r && set_session_collation_statement_1_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ FOR <character set specification list> ]
  private static boolean set_session_collation_statement_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_session_collation_statement_1_3")) return false;
    parseTokens(b, 0, FOR, _CHARACTER_SET_SPECIFICATION_LIST_);
    return true;
  }

  /* ********************************************************** */
  // SET SESSION AUTHORIZATION <value specification>
  public static boolean set_session_user_identifier_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_session_user_identifier_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, SESSION, AUTHORIZATION, _VALUE_SPECIFICATION_);
    exit_section_(b, m, SET_SESSION_USER_IDENTIFIER_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <update target> | <mutated set clause>
  public static boolean set_target(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_target")) return false;
    if (!nextTokenIs(b, "<set target>", _MUTATED_SET_CLAUSE_, _UPDATE_TARGET_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SET_TARGET, "<set target>");
    r = update_target(b, l + 1);
    if (!r) r = mutated_set_clause(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <set target> [ { <comma> <set target> }... ] <right paren>
  public static boolean set_target_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_target_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && set_target(b, l + 1);
    r = r && set_target_list_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, SET_TARGET_LIST, r);
    return r;
  }

  // [ { <comma> <set target> }... ]
  private static boolean set_target_list_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_target_list_2")) return false;
    set_target_list_2_0(b, l + 1);
    return true;
  }

  // <comma> <set target>
  private static boolean set_target_list_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_target_list_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && set_target(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <interval value expression> | LOCAL
  public static boolean set_time_zone_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_time_zone_value")) return false;
    if (!nextTokenIs(b, "<set time zone value>", LOCAL, _INTERVAL_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SET_TIME_ZONE_VALUE, "<set time zone value>");
    r = interval_value_expression(b, l + 1);
    if (!r) r = consumeToken(b, LOCAL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // SET [ LOCAL ] <transaction characteristics>
  public static boolean set_transaction_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_transaction_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, SET);
    r = r && set_transaction_statement_1(b, l + 1);
    r = r && transaction_characteristics(b, l + 1);
    exit_section_(b, m, SET_TRANSACTION_STATEMENT, r);
    return r;
  }

  // [ LOCAL ]
  private static boolean set_transaction_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_transaction_statement_1")) return false;
    consumeToken(b, LOCAL);
    return true;
  }

  /* ********************************************************** */
  // SET <transform group characteristic>
  public static boolean set_transform_group_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "set_transform_group_statement")) return false;
    if (!nextTokenIs(b, SET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SET, _TRANSFORM_GROUP_CHARACTERISTIC_);
    exit_section_(b, m, SET_TRANSFORM_GROUP_STATEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // <plus sign> | <minus sign>
  public static boolean sign(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sign")) return false;
    if (!nextTokenIs(b, "<sign>", _MINUS_SIGN_, _PLUS_SIGN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIGN, "<sign>");
    r = plus_sign(b, l + 1);
    if (!r) r = minus_sign(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <sign> ] <unsigned integer>
  public static boolean signed_integer(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "signed_integer")) return false;
    if (!nextTokenIs(b, "<signed integer>", _SIGN_, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIGNED_INTEGER, "<signed integer>");
    r = signed_integer_0(b, l + 1);
    r = r && unsigned_integer(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <sign> ]
  private static boolean signed_integer_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "signed_integer_0")) return false;
    sign(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // [ <sign> ] <unsigned numeric literal>
  public static boolean signed_numeric_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "signed_numeric_literal")) return false;
    if (!nextTokenIs(b, "<signed numeric literal>", _SIGN_, _UNSIGNED_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIGNED_NUMERIC_LITERAL, "<signed numeric literal>");
    r = signed_numeric_literal_0(b, l + 1);
    r = r && unsigned_numeric_literal(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <sign> ]
  private static boolean signed_numeric_literal_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "signed_numeric_literal_0")) return false;
    sign(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <character value expression>
  public static boolean similar_pattern(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "similar_pattern")) return false;
    if (!nextTokenIs(b, _CHARACTER_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_value_expression(b, l + 1);
    exit_section_(b, m, SIMILAR_PATTERN, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <similar predicate part 2>
  public static boolean similar_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "similar_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && similar_predicate_part_2(b, l + 1);
    exit_section_(b, m, SIMILAR_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // [ NOT ] SIMILAR TO <similar pattern> [ ESCAPE <escape character> ]
  public static boolean similar_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "similar_predicate_part_2")) return false;
    if (!nextTokenIs(b, "<similar predicate part 2>", NOT, SIMILAR)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIMILAR_PREDICATE_PART_2, "<similar predicate part 2>");
    r = similar_predicate_part_2_0(b, l + 1);
    r = r && consumeTokens(b, 0, SIMILAR, TO, _SIMILAR_PATTERN_);
    r = r && similar_predicate_part_2_4(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ NOT ]
  private static boolean similar_predicate_part_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "similar_predicate_part_2_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ ESCAPE <escape character> ]
  private static boolean similar_predicate_part_2_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "similar_predicate_part_2_4")) return false;
    parseTokens(b, 0, ESCAPE, _ESCAPE_CHARACTER_);
    return true;
  }

  /* ********************************************************** */
  // <simple Latin upper case letter> | <simple Latin lower case letter>
  public static boolean simple_Latin_letter(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_Latin_letter")) return false;
    if (!nextTokenIs(b, "<simple latin letter>", _SIMPLE_LATIN_LOWER_CASE_LETTER_, _SIMPLE_LATIN_UPPER_CASE_LETTER_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIMPLE_LATIN_LETTER, "<simple latin letter>");
    r = simple_Latin_upper_case_letter(b, l + 1);
    if (!r) r = simple_Latin_lower_case_letter(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
  public static boolean simple_Latin_lower_case_letter(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_Latin_lower_case_letter")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIMPLE_LATIN_LOWER_CASE_LETTER, "<simple latin lower case letter>");
    r = consumeToken(b, A);
    if (!r) r = consumeToken(b, B);
    if (!r) r = consumeToken(b, C);
    if (!r) r = consumeToken(b, D);
    if (!r) r = consumeToken(b, E);
    if (!r) r = consumeToken(b, F);
    if (!r) r = consumeToken(b, G);
    if (!r) r = consumeToken(b, H);
    if (!r) r = consumeToken(b, I);
    if (!r) r = consumeToken(b, J);
    if (!r) r = consumeToken(b, K);
    if (!r) r = consumeToken(b, L);
    if (!r) r = consumeToken(b, M);
    if (!r) r = consumeToken(b, N);
    if (!r) r = consumeToken(b, O);
    if (!r) r = consumeToken(b, P);
    if (!r) r = consumeToken(b, Q);
    if (!r) r = consumeToken(b, R);
    if (!r) r = consumeToken(b, S);
    if (!r) r = consumeToken(b, T);
    if (!r) r = consumeToken(b, U);
    if (!r) r = consumeToken(b, V);
    if (!r) r = consumeToken(b, W);
    if (!r) r = consumeToken(b, X);
    if (!r) r = consumeToken(b, Y);
    if (!r) r = consumeToken(b, Z);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
  public static boolean simple_Latin_upper_case_letter(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_Latin_upper_case_letter")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIMPLE_LATIN_UPPER_CASE_LETTER, "<simple latin upper case letter>");
    r = consumeToken(b, A);
    if (!r) r = consumeToken(b, B);
    if (!r) r = consumeToken(b, C);
    if (!r) r = consumeToken(b, D);
    if (!r) r = consumeToken(b, E);
    if (!r) r = consumeToken(b, F);
    if (!r) r = consumeToken(b, G);
    if (!r) r = consumeToken(b, H);
    if (!r) r = consumeToken(b, I);
    if (!r) r = consumeToken(b, J);
    if (!r) r = consumeToken(b, K);
    if (!r) r = consumeToken(b, L);
    if (!r) r = consumeToken(b, M);
    if (!r) r = consumeToken(b, N);
    if (!r) r = consumeToken(b, O);
    if (!r) r = consumeToken(b, P);
    if (!r) r = consumeToken(b, Q);
    if (!r) r = consumeToken(b, R);
    if (!r) r = consumeToken(b, S);
    if (!r) r = consumeToken(b, T);
    if (!r) r = consumeToken(b, U);
    if (!r) r = consumeToken(b, V);
    if (!r) r = consumeToken(b, W);
    if (!r) r = consumeToken(b, X);
    if (!r) r = consumeToken(b, Y);
    if (!r) r = consumeToken(b, Z);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CASE <case operand> <simple when clause>...
  public static boolean simple_case(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_case")) return false;
    if (!nextTokenIs(b, CASE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CASE, _CASE_OPERAND_, _SIMPLE_WHEN_CLAUSE_);
    exit_section_(b, m, SIMPLE_CASE, r);
    return r;
  }

  /* ********************************************************** */
  // <simple comment introducer> [ <comment character>... ] <newline>
  public static boolean simple_comment(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_comment")) return false;
    if (!nextTokenIs(b, _SIMPLE_COMMENT_INTRODUCER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_comment_introducer(b, l + 1);
    r = r && simple_comment_1(b, l + 1);
    r = r && consumeToken(b, _NEWLINE_);
    exit_section_(b, m, SIMPLE_COMMENT, r);
    return r;
  }

  // [ <comment character>... ]
  private static boolean simple_comment_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_comment_1")) return false;
    consumeToken(b, _COMMENT_CHARACTER____);
    return true;
  }

  /* ********************************************************** */
  // <minus sign><minus sign> [ <minus sign>... ]
  public static boolean simple_comment_introducer(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_comment_introducer")) return false;
    if (!nextTokenIs(b, _MINUS_SIGN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = minus_sign(b, l + 1);
    r = r && minus_sign(b, l + 1);
    r = r && simple_comment_introducer_2(b, l + 1);
    exit_section_(b, m, SIMPLE_COMMENT_INTRODUCER, r);
    return r;
  }

  // [ <minus sign>... ]
  private static boolean simple_comment_introducer_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_comment_introducer_2")) return false;
    consumeToken(b, _MINUS_SIGN____);
    return true;
  }

  /* ********************************************************** */
  // <query specification>
  // 	|	<table value constructor>
  // 	|	<explicit table>
  public static boolean simple_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_table")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIMPLE_TABLE, "<simple table>");
    r = query_specification(b, l + 1);
    if (!r) r = table_value_constructor(b, l + 1);
    if (!r) r = explicit_table(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <host parameter specification>
  // 	|	<SQL parameter reference>
  // 	|	<column reference>
  // 	|	<embedded variable name>
  public static boolean simple_target_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_target_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIMPLE_TARGET_SPECIFICATION, "<simple target specification>");
    r = host_parameter_specification(b, l + 1);
    if (!r) r = SQL_parameter_reference(b, l + 1);
    if (!r) r = column_reference(b, l + 1);
    if (!r) r = embedded_variable_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <simple target specification>
  public static boolean simple_target_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_target_specification_1")) return false;
    if (!nextTokenIs(b, _SIMPLE_TARGET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_target_specification(b, l + 1);
    exit_section_(b, m, SIMPLE_TARGET_SPECIFICATION_1, r);
    return r;
  }

  /* ********************************************************** */
  // <simple target specification>
  public static boolean simple_target_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_target_specification_2")) return false;
    if (!nextTokenIs(b, _SIMPLE_TARGET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_target_specification(b, l + 1);
    exit_section_(b, m, SIMPLE_TARGET_SPECIFICATION_2, r);
    return r;
  }

  /* ********************************************************** */
  // <literal>
  // 	|	<host parameter name>
  // 	|	<SQL parameter reference>
  // 	|	<embedded variable name>
  public static boolean simple_value_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_value_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SIMPLE_VALUE_SPECIFICATION, "<simple value specification>");
    r = literal(b, l + 1);
    if (!r) r = host_parameter_name(b, l + 1);
    if (!r) r = SQL_parameter_reference(b, l + 1);
    if (!r) r = embedded_variable_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean simple_value_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_value_specification_1")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, SIMPLE_VALUE_SPECIFICATION_1, r);
    return r;
  }

  /* ********************************************************** */
  // <simple value specification>
  public static boolean simple_value_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_value_specification_2")) return false;
    if (!nextTokenIs(b, _SIMPLE_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_value_specification(b, l + 1);
    exit_section_(b, m, SIMPLE_VALUE_SPECIFICATION_2, r);
    return r;
  }

  /* ********************************************************** */
  // WHEN <when operand> THEN <result>
  public static boolean simple_when_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "simple_when_clause")) return false;
    if (!nextTokenIs(b, WHEN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WHEN, _WHEN_OPERAND_, THEN, _RESULT_);
    exit_section_(b, m, SIMPLE_WHEN_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]
  // 	|	SECOND [ <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren> ]
  public static boolean single_datetime_field(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "single_datetime_field")) return false;
    if (!nextTokenIs(b, "<single datetime field>", SECOND, _NON_SECOND_PRIMARY_DATETIME_FIELD_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SINGLE_DATETIME_FIELD, "<single datetime field>");
    r = single_datetime_field_0(b, l + 1);
    if (!r) r = single_datetime_field_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]
  private static boolean single_datetime_field_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "single_datetime_field_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = non_second_primary_datetime_field(b, l + 1);
    r = r && single_datetime_field_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <interval leading field precision> <right paren> ]
  private static boolean single_datetime_field_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "single_datetime_field_0_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // SECOND [ <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren> ]
  private static boolean single_datetime_field_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "single_datetime_field_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, SECOND);
    r = r && single_datetime_field_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren> ]
  private static boolean single_datetime_field_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "single_datetime_field_1_1")) return false;
    single_datetime_field_1_1_0(b, l + 1);
    return true;
  }

  // <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren>
  private static boolean single_datetime_field_1_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "single_datetime_field_1_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && interval_leading_field_precision(b, l + 1);
    r = r && single_datetime_field_1_1_0_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <comma> <interval fractional seconds precision> ]
  private static boolean single_datetime_field_1_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "single_datetime_field_1_1_0_2")) return false;
    comma(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <group name>
  public static boolean single_group_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "single_group_specification")) return false;
    if (!nextTokenIs(b, _GROUP_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = group_name(b, l + 1);
    exit_section_(b, m, SINGLE_GROUP_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // /
  public static boolean solidus(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, SOLIDUS, true);
    return true;
  }

  /* ********************************************************** */
  // SOME | ANY
  public static boolean some(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "some")) return false;
    if (!nextTokenIs(b, "<some>", ANY, SOME)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SOME, "<some>");
    r = consumeToken(b, SOME);
    if (!r) r = consumeToken(b, ANY);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  public static boolean sort_key(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sort_key")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    exit_section_(b, m, SORT_KEY, r);
    return r;
  }

  /* ********************************************************** */
  // <sort key> [ <ordering specification> ] [ <null ordering> ]
  public static boolean sort_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sort_specification")) return false;
    if (!nextTokenIs(b, _SORT_KEY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = sort_key(b, l + 1);
    r = r && sort_specification_1(b, l + 1);
    r = r && sort_specification_2(b, l + 1);
    exit_section_(b, m, SORT_SPECIFICATION, r);
    return r;
  }

  // [ <ordering specification> ]
  private static boolean sort_specification_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sort_specification_1")) return false;
    ordering_specification(b, l + 1);
    return true;
  }

  // [ <null ordering> ]
  private static boolean sort_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sort_specification_2")) return false;
    null_ordering(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <sort specification> [ { <comma> <sort specification> }... ]
  public static boolean sort_specification_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sort_specification_list")) return false;
    if (!nextTokenIs(b, _SORT_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = sort_specification(b, l + 1);
    r = r && sort_specification_list_1(b, l + 1);
    exit_section_(b, m, SORT_SPECIFICATION_LIST, r);
    return r;
  }

  // [ { <comma> <sort specification> }... ]
  private static boolean sort_specification_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sort_specification_list_1")) return false;
    sort_specification_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <sort specification>
  private static boolean sort_specification_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "sort_specification_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && sort_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <character set specification>
  public static boolean source_character_set_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "source_character_set_specification")) return false;
    if (!nextTokenIs(b, _CHARACTER_SET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_set_specification(b, l + 1);
    exit_section_(b, m, SOURCE_CHARACTER_SET_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <data type>
  public static boolean source_data_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "source_data_type")) return false;
    if (!nextTokenIs(b, _DATA_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    exit_section_(b, m, SOURCE_DATA_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // !! See the Syntax Rules.
  public static boolean space(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, SPACE, true);
    return true;
  }

  /* ********************************************************** */
  // [ <schema name> <period> ]<qualified identifier>
  public static boolean specific_method_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_method_name")) return false;
    if (!nextTokenIs(b, "<specific method name>", _QUALIFIED_IDENTIFIER_, _SCHEMA_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SPECIFIC_METHOD_NAME, "<specific method name>");
    r = specific_method_name_0(b, l + 1);
    r = r && qualified_identifier(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <schema name> <period> ]
  private static boolean specific_method_name_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_method_name_0")) return false;
    schema_name(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // [ INSTANCE | STATIC | CONSTRUCTOR ] METHOD <method name> <data type list>
  public static boolean specific_method_specification_designator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_method_specification_designator")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SPECIFIC_METHOD_SPECIFICATION_DESIGNATOR, "<specific method specification designator>");
    r = specific_method_specification_designator_0(b, l + 1);
    r = r && consumeTokens(b, 0, METHOD, _METHOD_NAME_, _DATA_TYPE_LIST_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ INSTANCE | STATIC | CONSTRUCTOR ]
  private static boolean specific_method_specification_designator_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_method_specification_designator_0")) return false;
    specific_method_specification_designator_0_0(b, l + 1);
    return true;
  }

  // INSTANCE | STATIC | CONSTRUCTOR
  private static boolean specific_method_specification_designator_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_method_specification_designator_0_0")) return false;
    boolean r;
    r = consumeToken(b, INSTANCE);
    if (!r) r = consumeToken(b, STATIC);
    if (!r) r = consumeToken(b, CONSTRUCTOR);
    return r;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean specific_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, SPECIFIC_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // SPECIFIC <routine type> <specific name>
  // 			|	<routine type> <member name>
  // 		[ FOR <schema-resolved user-defined type name> ]
  public static boolean specific_routine_designator(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_routine_designator")) return false;
    if (!nextTokenIs(b, "<specific routine designator>", SPECIFIC, _ROUTINE_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SPECIFIC_ROUTINE_DESIGNATOR, "<specific routine designator>");
    r = parseTokens(b, 0, SPECIFIC, _ROUTINE_TYPE_, _SPECIFIC_NAME_);
    if (!r) r = specific_routine_designator_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <routine type> <member name>
  // 		[ FOR <schema-resolved user-defined type name> ]
  private static boolean specific_routine_designator_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_routine_designator_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = routine_type(b, l + 1);
    r = r && member_name(b, l + 1);
    r = r && specific_routine_designator_1_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ FOR <schema-resolved user-defined type name> ]
  private static boolean specific_routine_designator_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_routine_designator_1_2")) return false;
    parseTokens(b, 0, FOR, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_);
    return true;
  }

  /* ********************************************************** */
  // <user-defined type value expression> <period> SPECIFICTYPE
  public static boolean specific_type_method(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "specific_type_method")) return false;
    if (!nextTokenIs(b, _USER_DEFINED_TYPE_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = user_defined_type_value_expression(b, l + 1);
    r = r && period(b, l + 1);
    r = r && consumeToken(b, SPECIFICTYPE);
    exit_section_(b, m, SPECIFIC_TYPE_METHOD, r);
    return r;
  }

  /* ********************************************************** */
  // SQRT <left paren> <numeric value expression> <right paren>
  public static boolean square_root(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "square_root")) return false;
    if (!nextTokenIs(b, SQRT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, SQRT, _LEFT_PAREN_, _NUMERIC_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, SQUARE_ROOT, r);
    return r;
  }

  /* ********************************************************** */
  // <character set name>
  public static boolean standard_character_set_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "standard_character_set_name")) return false;
    if (!nextTokenIs(b, _CHARACTER_SET_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_set_name(b, l + 1);
    exit_section_(b, m, STANDARD_CHARACTER_SET_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]
  public static boolean start_field(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "start_field")) return false;
    if (!nextTokenIs(b, _NON_SECOND_PRIMARY_DATETIME_FIELD_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = non_second_primary_datetime_field(b, l + 1);
    r = r && start_field_1(b, l + 1);
    exit_section_(b, m, START_FIELD, r);
    return r;
  }

  // [ <left paren> <interval leading field precision> <right paren> ]
  private static boolean start_field_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "start_field_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean start_position(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "start_position")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, START_POSITION, r);
    return r;
  }

  /* ********************************************************** */
  // START TRANSACTION [ <transaction mode> [ { <comma> <transaction mode> }...] ]
  public static boolean start_transaction_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "start_transaction_statement")) return false;
    if (!nextTokenIs(b, START)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, START, TRANSACTION);
    r = r && start_transaction_statement_2(b, l + 1);
    exit_section_(b, m, START_TRANSACTION_STATEMENT, r);
    return r;
  }

  // [ <transaction mode> [ { <comma> <transaction mode> }...] ]
  private static boolean start_transaction_statement_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "start_transaction_statement_2")) return false;
    start_transaction_statement_2_0(b, l + 1);
    return true;
  }

  // <transaction mode> [ { <comma> <transaction mode> }...]
  private static boolean start_transaction_statement_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "start_transaction_statement_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = transaction_mode(b, l + 1);
    r = r && start_transaction_statement_2_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ { <comma> <transaction mode> }...]
  private static boolean start_transaction_statement_2_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "start_transaction_statement_2_0_1")) return false;
    start_transaction_statement_2_0_1_0(b, l + 1);
    return true;
  }

  // <comma> <transaction mode>
  private static boolean start_transaction_statement_2_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "start_transaction_statement_2_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && transaction_mode(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // STATE [ <specific name> ]
  public static boolean state_category(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "state_category")) return false;
    if (!nextTokenIs(b, STATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, STATE);
    r = r && state_category_1(b, l + 1);
    exit_section_(b, m, STATE_CATEGORY, r);
    return r;
  }

  // [ <specific name> ]
  private static boolean state_category_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "state_category_1")) return false;
    specific_name(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // [ <cursor sensitivity> ] [ <cursor scrollability> ] CURSOR
  // 		[ <cursor holdability> ] [ <cursor returnability> ] FOR <extended statement name>
  public static boolean statement_cursor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_cursor")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, STATEMENT_CURSOR, "<statement cursor>");
    r = statement_cursor_0(b, l + 1);
    r = r && statement_cursor_1(b, l + 1);
    r = r && consumeToken(b, CURSOR);
    r = r && statement_cursor_3(b, l + 1);
    r = r && statement_cursor_4(b, l + 1);
    r = r && consumeTokens(b, 0, FOR, _EXTENDED_STATEMENT_NAME_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <cursor sensitivity> ]
  private static boolean statement_cursor_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_cursor_0")) return false;
    cursor_sensitivity(b, l + 1);
    return true;
  }

  // [ <cursor scrollability> ]
  private static boolean statement_cursor_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_cursor_1")) return false;
    cursor_scrollability(b, l + 1);
    return true;
  }

  // [ <cursor holdability> ]
  private static boolean statement_cursor_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_cursor_3")) return false;
    cursor_holdability(b, l + 1);
    return true;
  }

  // [ <cursor returnability> ]
  private static boolean statement_cursor_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_cursor_4")) return false;
    cursor_returnability(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <statement information item> [ { <comma> <statement information item> }... ]
  public static boolean statement_information(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_information")) return false;
    if (!nextTokenIs(b, _STATEMENT_INFORMATION_ITEM_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = statement_information_item(b, l + 1);
    r = r && statement_information_1(b, l + 1);
    exit_section_(b, m, STATEMENT_INFORMATION, r);
    return r;
  }

  // [ { <comma> <statement information item> }... ]
  private static boolean statement_information_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_information_1")) return false;
    statement_information_1_0(b, l + 1);
    return true;
  }

  // <comma> <statement information item>
  private static boolean statement_information_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_information_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && statement_information_item(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <simple target specification> <equals operator> <statement information item name>
  public static boolean statement_information_item(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_information_item")) return false;
    if (!nextTokenIs(b, _SIMPLE_TARGET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = simple_target_specification(b, l + 1);
    r = r && equals_operator(b, l + 1);
    r = r && statement_information_item_name(b, l + 1);
    exit_section_(b, m, STATEMENT_INFORMATION_ITEM, r);
    return r;
  }

  /* ********************************************************** */
  // NUMBER
  // 	|	MORE
  // 	|	COMMAND_FUNCTION
  // 	|	COMMAND_FUNCTION_CODE
  // 	|	DYNAMIC_FUNCTION
  // 	|	DYNAMIC_FUNCTION_CODE
  // 	|	ROW_COUNT
  // 	|	TRANSACTIONS_COMMITTED
  // 	|	TRANSACTIONS_ROLLED_BACK
  // 	|	TRANSACTION_ACTIVE
  public static boolean statement_information_item_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_information_item_name")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, STATEMENT_INFORMATION_ITEM_NAME, "<statement information item name>");
    r = consumeToken(b, NUMBER);
    if (!r) r = consumeToken(b, MORE);
    if (!r) r = consumeToken(b, COMMAND_FUNCTION);
    if (!r) r = consumeToken(b, COMMAND_FUNCTION_CODE);
    if (!r) r = consumeToken(b, DYNAMIC_FUNCTION);
    if (!r) r = consumeToken(b, DYNAMIC_FUNCTION_CODE);
    if (!r) r = consumeToken(b, ROW_COUNT);
    if (!r) r = consumeToken(b, TRANSACTIONS_COMMITTED);
    if (!r) r = consumeToken(b, TRANSACTIONS_ROLLED_BACK);
    if (!r) r = consumeToken(b, TRANSACTION_ACTIVE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean statement_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, STATEMENT_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <declare cursor>
  // 	|	<dynamic declare cursor>
  // 	|	<temporary table declaration>
  // 	|	<embedded authorization declaration>
  // 	|	<embedded path specification>
  // 	|	<embedded transform group specification>
  // 	|	<embedded collation specification>
  // 	|	<embedded exception declaration>
  // 	|	<handler declaration>
  // 	|	<SQL procedure statement>
  public static boolean statement_or_declaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "statement_or_declaration")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, STATEMENT_OR_DECLARATION, "<statement or declaration>");
    r = declare_cursor(b, l + 1);
    if (!r) r = dynamic_declare_cursor(b, l + 1);
    if (!r) r = temporary_table_declaration(b, l + 1);
    if (!r) r = embedded_authorization_declaration(b, l + 1);
    if (!r) r = embedded_path_specification(b, l + 1);
    if (!r) r = embedded_transform_group_specification(b, l + 1);
    if (!r) r = embedded_collation_specification(b, l + 1);
    if (!r) r = embedded_exception_declaration(b, l + 1);
    if (!r) r = consumeToken(b, _HANDLER_DECLARATION_);
    if (!r) r = SQL_procedure_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <path-resolved user-defined type name> <double colon> <method name> [ <SQL argument list> ]
  public static boolean static_method_invocation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "static_method_invocation")) return false;
    if (!nextTokenIs(b, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = path_resolved_user_defined_type_name(b, l + 1);
    r = r && double_colon(b, l + 1);
    r = r && method_name(b, l + 1);
    r = r && static_method_invocation_3(b, l + 1);
    exit_section_(b, m, STATIC_METHOD_INVOCATION, r);
    return r;
  }

  // [ <SQL argument list> ]
  private static boolean static_method_invocation_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "static_method_invocation_3")) return false;
    SQL_argument_list(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <routine invocation>
  public static boolean static_method_selection(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "static_method_selection")) return false;
    if (!nextTokenIs(b, _ROUTINE_INVOCATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = routine_invocation(b, l + 1);
    exit_section_(b, m, STATIC_METHOD_SELECTION, r);
    return r;
  }

  /* ********************************************************** */
  // SQLSTATE
  public static boolean status_parameter(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "status_parameter")) return false;
    if (!nextTokenIs(b, SQLSTATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, SQLSTATE);
    exit_section_(b, m, STATUS_PARAMETER, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean string_length(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "string_length")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, STRING_LENGTH, r);
    return r;
  }

  /* ********************************************************** */
  // POSITION <left paren> <string value expression> IN <string value expression> [ USING <char length units> ] <right paren>
  public static boolean string_position_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "string_position_expression")) return false;
    if (!nextTokenIs(b, POSITION)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, POSITION, _LEFT_PAREN_, _STRING_VALUE_EXPRESSION_, IN, _STRING_VALUE_EXPRESSION_);
    r = r && string_position_expression_5(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, STRING_POSITION_EXPRESSION, r);
    return r;
  }

  // [ USING <char length units> ]
  private static boolean string_position_expression_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "string_position_expression_5")) return false;
    parseTokens(b, 0, USING, _CHAR_LENGTH_UNITS_);
    return true;
  }

  /* ********************************************************** */
  // <character value expression> | <blob value expression>
  public static boolean string_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "string_value_expression")) return false;
    if (!nextTokenIs(b, "<string value expression>", _BLOB_VALUE_EXPRESSION_, _CHARACTER_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, STRING_VALUE_EXPRESSION, "<string value expression>");
    r = character_value_expression(b, l + 1);
    if (!r) r = blob_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character value function> | <blob value function>
  public static boolean string_value_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "string_value_function")) return false;
    if (!nextTokenIs(b, "<string value function>", _BLOB_VALUE_FUNCTION_, _CHARACTER_VALUE_FUNCTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, STRING_VALUE_FUNCTION, "<string value function>");
    r = character_value_function(b, l + 1);
    if (!r) r = blob_value_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <submultiset predicate part 2>
  public static boolean submultiset_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "submultiset_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && submultiset_predicate_part_2(b, l + 1);
    exit_section_(b, m, SUBMULTISET_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // [ NOT ] SUBMULTISET [ OF ] <multiset value expression>
  public static boolean submultiset_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "submultiset_predicate_part_2")) return false;
    if (!nextTokenIs(b, "<submultiset predicate part 2>", NOT, SUBMULTISET)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SUBMULTISET_PREDICATE_PART_2, "<submultiset predicate part 2>");
    r = submultiset_predicate_part_2_0(b, l + 1);
    r = r && consumeToken(b, SUBMULTISET);
    r = r && submultiset_predicate_part_2_2(b, l + 1);
    r = r && multiset_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ NOT ]
  private static boolean submultiset_predicate_part_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "submultiset_predicate_part_2_0")) return false;
    consumeToken(b, NOT);
    return true;
  }

  // [ OF ]
  private static boolean submultiset_predicate_part_2_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "submultiset_predicate_part_2_2")) return false;
    consumeToken(b, OF);
    return true;
  }

  /* ********************************************************** */
  // <left paren> <query expression> <right paren>
  public static boolean subquery(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "subquery")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && query_expression(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, SUBQUERY, r);
    return r;
  }

  /* ********************************************************** */
  // UNDER <supertable clause>
  public static boolean subtable_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "subtable_clause")) return false;
    if (!nextTokenIs(b, UNDER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UNDER, _SUPERTABLE_CLAUSE_);
    exit_section_(b, m, SUBTABLE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // UNDER <supertype name>
  public static boolean subtype_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "subtype_clause")) return false;
    if (!nextTokenIs(b, UNDER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UNDER, _SUPERTYPE_NAME_);
    exit_section_(b, m, SUBTYPE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression>
  public static boolean subtype_operand(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "subtype_operand")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression(b, l + 1);
    exit_section_(b, m, SUBTYPE_OPERAND, r);
    return r;
  }

  /* ********************************************************** */
  // TREAT <left paren> <subtype operand> AS <target subtype> <right paren>
  public static boolean subtype_treatment(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "subtype_treatment")) return false;
    if (!nextTokenIs(b, TREAT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TREAT, _LEFT_PAREN_, _SUBTYPE_OPERAND_, AS, _TARGET_SUBTYPE_, _RIGHT_PAREN_);
    exit_section_(b, m, SUBTYPE_TREATMENT, r);
    return r;
  }

  /* ********************************************************** */
  // UNDER <table name>
  public static boolean subview_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "subview_clause")) return false;
    if (!nextTokenIs(b, UNDER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UNDER, _TABLE_NAME_);
    exit_section_(b, m, SUBVIEW_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <supertable name>
  public static boolean supertable_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "supertable_clause")) return false;
    if (!nextTokenIs(b, _SUPERTABLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = supertable_name(b, l + 1);
    exit_section_(b, m, SUPERTABLE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <table name>
  public static boolean supertable_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "supertable_name")) return false;
    if (!nextTokenIs(b, _TABLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_name(b, l + 1);
    exit_section_(b, m, SUPERTABLE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <path-resolved user-defined type name>
  public static boolean supertype_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "supertype_name")) return false;
    if (!nextTokenIs(b, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = path_resolved_user_defined_type_name(b, l + 1);
    exit_section_(b, m, SUPERTYPE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <allocate descriptor statement>
  // 	|	<deallocate descriptor statement>
  // 	|	<set descriptor statement>
  // 	|	<get descriptor statement>
  public static boolean system_descriptor_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "system_descriptor_statement")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SYSTEM_DESCRIPTOR_STATEMENT, "<system descriptor statement>");
    r = allocate_descriptor_statement(b, l + 1);
    if (!r) r = deallocate_descriptor_statement(b, l + 1);
    if (!r) r = consumeToken(b, _SET_DESCRIPTOR_STATEMENT_);
    if (!r) r = consumeToken(b, _GET_DESCRIPTOR_STATEMENT_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // REF IS SYSTEM GENERATED
  public static boolean system_generated_representation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "system_generated_representation")) return false;
    if (!nextTokenIs(b, REF)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, REF, IS, SYSTEM, GENERATED);
    exit_section_(b, m, SYSTEM_GENERATED_REPRESENTATION, r);
    return r;
  }

  /* ********************************************************** */
  // PRESERVE | DELETE
  public static boolean table_commit_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_commit_action")) return false;
    if (!nextTokenIs(b, "<table commit action>", DELETE, PRESERVE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_COMMIT_ACTION, "<table commit action>");
    r = consumeToken(b, PRESERVE);
    if (!r) r = consumeToken(b, DELETE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <unique constraint definition>
  // 	|	<referential constraint definition>
  // 	|	<check constraint definition>
  public static boolean table_constraint(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_constraint")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_CONSTRAINT, "<table constraint>");
    r = unique_constraint_definition(b, l + 1);
    if (!r) r = referential_constraint_definition(b, l + 1);
    if (!r) r = check_constraint_definition(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // [ <constraint name definition> ] <table constraint> [ <constraint characteristics> ]
  public static boolean table_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_constraint_definition")) return false;
    if (!nextTokenIs(b, "<table constraint definition>", _CONSTRAINT_NAME_DEFINITION_, _TABLE_CONSTRAINT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_CONSTRAINT_DEFINITION, "<table constraint definition>");
    r = table_constraint_definition_0(b, l + 1);
    r = r && table_constraint(b, l + 1);
    r = r && table_constraint_definition_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <constraint name definition> ]
  private static boolean table_constraint_definition_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_constraint_definition_0")) return false;
    constraint_name_definition(b, l + 1);
    return true;
  }

  // [ <constraint characteristics> ]
  private static boolean table_constraint_definition_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_constraint_definition_2")) return false;
    constraint_characteristics(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <table element list>
  // 	|	OF <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
  // 	|	<as subquery clause>
  public static boolean table_contents_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_contents_source")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_CONTENTS_SOURCE, "<table contents source>");
    r = table_element_list(b, l + 1);
    if (!r) r = table_contents_source_1(b, l + 1);
    if (!r) r = as_subquery_clause(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // OF <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
  private static boolean table_contents_source_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_contents_source_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, OF, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_);
    r = r && table_contents_source_1_2(b, l + 1);
    r = r && table_contents_source_1_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <subtable clause> ]
  private static boolean table_contents_source_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_contents_source_1_2")) return false;
    subtable_clause(b, l + 1);
    return true;
  }

  // [ <table element list> ]
  private static boolean table_contents_source_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_contents_source_1_3")) return false;
    table_element_list(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // CREATE [ <table scope> ] TABLE <table name> <table contents source>
  // 		[ ON COMMIT <table commit action> ROWS ]
  public static boolean table_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CREATE);
    r = r && table_definition_1(b, l + 1);
    r = r && consumeTokens(b, 0, TABLE, _TABLE_NAME_, _TABLE_CONTENTS_SOURCE_);
    r = r && table_definition_5(b, l + 1);
    exit_section_(b, m, TABLE_DEFINITION, r);
    return r;
  }

  // [ <table scope> ]
  private static boolean table_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_definition_1")) return false;
    table_scope(b, l + 1);
    return true;
  }

  // [ ON COMMIT <table commit action> ROWS ]
  private static boolean table_definition_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_definition_5")) return false;
    parseTokens(b, 0, ON, COMMIT, _TABLE_COMMIT_ACTION_, ROWS);
    return true;
  }

  /* ********************************************************** */
  // <column definition>
  // 	|	<table constraint definition>
  // 	|	<like clause>
  // 	|	<self-referencing column specification>
  // 	|	<column options>
  public static boolean table_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_element")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_ELEMENT, "<table element>");
    r = column_definition(b, l + 1);
    if (!r) r = table_constraint_definition(b, l + 1);
    if (!r) r = like_clause(b, l + 1);
    if (!r) r = self_referencing_column_specification(b, l + 1);
    if (!r) r = column_options(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <table element> [ { <comma> <table element> }... ] <right paren>
  public static boolean table_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_element_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && table_element(b, l + 1);
    r = r && table_element_list_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, TABLE_ELEMENT_LIST, r);
    return r;
  }

  // [ { <comma> <table element> }... ]
  private static boolean table_element_list_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_element_list_2")) return false;
    table_element_list_2_0(b, l + 1);
    return true;
  }

  // <comma> <table element>
  private static boolean table_element_list_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_element_list_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && table_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <from clause>
  // 		[ <where clause> ]
  // 		[ <group by clause> ]
  // 		[ <having clause> ]
  // 		[ <window clause> ]
  public static boolean table_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_expression")) return false;
    if (!nextTokenIs(b, _FROM_CLAUSE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = from_clause(b, l + 1);
    r = r && table_expression_1(b, l + 1);
    r = r && table_expression_2(b, l + 1);
    r = r && table_expression_3(b, l + 1);
    r = r && table_expression_4(b, l + 1);
    exit_section_(b, m, TABLE_EXPRESSION, r);
    return r;
  }

  // [ <where clause> ]
  private static boolean table_expression_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_expression_1")) return false;
    where_clause(b, l + 1);
    return true;
  }

  // [ <group by clause> ]
  private static boolean table_expression_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_expression_2")) return false;
    group_by_clause(b, l + 1);
    return true;
  }

  // [ <having clause> ]
  private static boolean table_expression_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_expression_3")) return false;
    having_clause(b, l + 1);
    return true;
  }

  // [ <window clause> ]
  private static boolean table_expression_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_expression_4")) return false;
    window_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <left paren>
  // 		<table function column list element> [ { <comma> <table function column list element> }... ]
  // 		<right paren>
  public static boolean table_function_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_function_column_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && table_function_column_list_element(b, l + 1);
    r = r && table_function_column_list_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, TABLE_FUNCTION_COLUMN_LIST, r);
    return r;
  }

  // [ { <comma> <table function column list element> }... ]
  private static boolean table_function_column_list_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_function_column_list_2")) return false;
    table_function_column_list_2_0(b, l + 1);
    return true;
  }

  // <comma> <table function column list element>
  private static boolean table_function_column_list_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_function_column_list_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && table_function_column_list_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <column name> <data type>
  public static boolean table_function_column_list_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_function_column_list_element")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    r = r && data_type(b, l + 1);
    exit_section_(b, m, TABLE_FUNCTION_COLUMN_LIST_ELEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // TABLE <left paren> <collection value expression> <right paren>
  public static boolean table_function_derived_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_function_derived_table")) return false;
    if (!nextTokenIs(b, TABLE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLE, _LEFT_PAREN_, _COLLECTION_VALUE_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, TABLE_FUNCTION_DERIVED_TABLE, r);
    return r;
  }

  /* ********************************************************** */
  // <local or schema qualified name>
  public static boolean table_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_name")) return false;
    if (!nextTokenIs(b, _LOCAL_OR_SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = local_or_schema_qualified_name(b, l + 1);
    exit_section_(b, m, TABLE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <table name> | <query name>
  public static boolean table_or_query_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_or_query_name")) return false;
    if (!nextTokenIs(b, "<table or query name>", _QUERY_NAME_, _TABLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_OR_QUERY_NAME, "<table or query name>");
    r = table_name(b, l + 1);
    if (!r) r = query_name(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <table or query name> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
  // 	|	<derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  // 	|	<lateral derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  // 	|	<collection derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  // 	|	<table function derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  // 	|	<only spec> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
  // 	|	<left paren> <joined table> <right paren>
  public static boolean table_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_PRIMARY, "<table primary>");
    r = table_primary_0(b, l + 1);
    if (!r) r = table_primary_1(b, l + 1);
    if (!r) r = table_primary_2(b, l + 1);
    if (!r) r = table_primary_3(b, l + 1);
    if (!r) r = table_primary_4(b, l + 1);
    if (!r) r = table_primary_5(b, l + 1);
    if (!r) r = left_paren(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <table or query name> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
  private static boolean table_primary_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_or_query_name(b, l + 1);
    r = r && table_primary_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
  private static boolean table_primary_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_0_1")) return false;
    table_primary_0_1_0(b, l + 1);
    return true;
  }

  // [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_primary_0_1_0_0(b, l + 1);
    r = r && correlation_name(b, l + 1);
    r = r && table_primary_0_1_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean table_primary_0_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_0_1_0_0")) return false;
    consumeToken(b, AS);
    return true;
  }

  // [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_0_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_0_1_0_2")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // <derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = derived_table(b, l + 1);
    r = r && table_primary_1_1(b, l + 1);
    r = r && correlation_name(b, l + 1);
    r = r && table_primary_1_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean table_primary_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_1_1")) return false;
    consumeToken(b, AS);
    return true;
  }

  // [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_1_3")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // <lateral derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = lateral_derived_table(b, l + 1);
    r = r && table_primary_2_1(b, l + 1);
    r = r && correlation_name(b, l + 1);
    r = r && table_primary_2_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean table_primary_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_2_1")) return false;
    consumeToken(b, AS);
    return true;
  }

  // [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_2_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_2_3")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // <collection derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = collection_derived_table(b, l + 1);
    r = r && table_primary_3_1(b, l + 1);
    r = r && correlation_name(b, l + 1);
    r = r && table_primary_3_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean table_primary_3_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_3_1")) return false;
    consumeToken(b, AS);
    return true;
  }

  // [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_3_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_3_3")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // <table function derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_4")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_function_derived_table(b, l + 1);
    r = r && table_primary_4_1(b, l + 1);
    r = r && correlation_name(b, l + 1);
    r = r && table_primary_4_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean table_primary_4_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_4_1")) return false;
    consumeToken(b, AS);
    return true;
  }

  // [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_4_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_4_3")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // <only spec> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
  private static boolean table_primary_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_5")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = only_spec(b, l + 1);
    r = r && table_primary_5_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
  private static boolean table_primary_5_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_5_1")) return false;
    table_primary_5_1_0(b, l + 1);
    return true;
  }

  // [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_5_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_5_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_primary_5_1_0_0(b, l + 1);
    r = r && correlation_name(b, l + 1);
    r = r && table_primary_5_1_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ AS ]
  private static boolean table_primary_5_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_5_1_0_0")) return false;
    consumeToken(b, AS);
    return true;
  }

  // [ <left paren> <derived column list> <right paren> ]
  private static boolean table_primary_5_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_5_1_0_2")) return false;
    left_paren(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <table primary> | <joined table>
  public static boolean table_primary_or_joined_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_primary_or_joined_table")) return false;
    if (!nextTokenIs(b, "<table primary or joined table>", _JOINED_TABLE_, _TABLE_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_PRIMARY_OR_JOINED_TABLE, "<table primary or joined table>");
    r = table_primary(b, l + 1);
    if (!r) r = joined_table(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <table primary or joined table> [ <sample clause> ]
  public static boolean table_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_reference")) return false;
    if (!nextTokenIs(b, _TABLE_PRIMARY_OR_JOINED_TABLE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_primary_or_joined_table(b, l + 1);
    r = r && table_reference_1(b, l + 1);
    exit_section_(b, m, TABLE_REFERENCE, r);
    return r;
  }

  // [ <sample clause> ]
  private static boolean table_reference_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_reference_1")) return false;
    sample_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <table reference> [ { <comma> <table reference> }... ]
  public static boolean table_reference_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_reference_list")) return false;
    if (!nextTokenIs(b, _TABLE_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_reference(b, l + 1);
    r = r && table_reference_list_1(b, l + 1);
    exit_section_(b, m, TABLE_REFERENCE_LIST, r);
    return r;
  }

  // [ { <comma> <table reference> }... ]
  private static boolean table_reference_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_reference_list_1")) return false;
    table_reference_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <table reference>
  private static boolean table_reference_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_reference_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && table_reference(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <row value special case>
  // 	|	<row value constructor>
  public static boolean table_row_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_row_value_expression")) return false;
    if (!nextTokenIs(b, "<table row value expression>", _ROW_VALUE_CONSTRUCTOR_, _ROW_VALUE_SPECIAL_CASE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TABLE_ROW_VALUE_EXPRESSION, "<table row value expression>");
    r = row_value_special_case(b, l + 1);
    if (!r) r = row_value_constructor(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <global or local> TEMPORARY
  public static boolean table_scope(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_scope")) return false;
    if (!nextTokenIs(b, _GLOBAL_OR_LOCAL_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = global_or_local(b, l + 1);
    r = r && consumeToken(b, TEMPORARY);
    exit_section_(b, m, TABLE_SCOPE, r);
    return r;
  }

  /* ********************************************************** */
  // <subquery>
  public static boolean table_subquery(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_subquery")) return false;
    if (!nextTokenIs(b, _SUBQUERY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = subquery(b, l + 1);
    exit_section_(b, m, TABLE_SUBQUERY, r);
    return r;
  }

  /* ********************************************************** */
  // VALUES <row value expression list>
  public static boolean table_value_constructor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_value_constructor")) return false;
    if (!nextTokenIs(b, VALUES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, VALUES, _ROW_VALUE_EXPRESSION_LIST_);
    exit_section_(b, m, TABLE_VALUE_CONSTRUCTOR, r);
    return r;
  }

  /* ********************************************************** */
  // TABLE <left paren> <query expression> <right paren>
  public static boolean table_value_constructor_by_query(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "table_value_constructor_by_query")) return false;
    if (!nextTokenIs(b, TABLE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLE, _LEFT_PAREN_, _QUERY_EXPRESSION_, _RIGHT_PAREN_);
    exit_section_(b, m, TABLE_VALUE_CONSTRUCTOR_BY_QUERY, r);
    return r;
  }

  /* ********************************************************** */
  // <target array reference> <left bracket or trigraph> <simple value specification> <right bracket or trigraph>
  public static boolean target_array_element_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "target_array_element_specification")) return false;
    if (!nextTokenIs(b, _TARGET_ARRAY_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = target_array_reference(b, l + 1);
    r = r && left_bracket_or_trigraph(b, l + 1);
    r = r && simple_value_specification(b, l + 1);
    r = r && right_bracket_or_trigraph(b, l + 1);
    exit_section_(b, m, TARGET_ARRAY_ELEMENT_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <SQL parameter reference> | <column reference>
  public static boolean target_array_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "target_array_reference")) return false;
    if (!nextTokenIs(b, "<target array reference>", _COLUMN_REFERENCE_, _SQL_PARAMETER_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TARGET_ARRAY_REFERENCE, "<target array reference>");
    r = SQL_parameter_reference(b, l + 1);
    if (!r) r = column_reference(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <character set specification>
  public static boolean target_character_set_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "target_character_set_specification")) return false;
    if (!nextTokenIs(b, _CHARACTER_SET_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_set_specification(b, l + 1);
    exit_section_(b, m, TARGET_CHARACTER_SET_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <data type>
  public static boolean target_data_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "target_data_type")) return false;
    if (!nextTokenIs(b, _DATA_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = data_type(b, l + 1);
    exit_section_(b, m, TARGET_DATA_TYPE, r);
    return r;
  }

  /* ********************************************************** */
  // <host parameter specification>
  // 	|	<SQL parameter reference>
  // 	|	<column reference>
  // 	|	<target array element specification>
  // 	|	<dynamic parameter specification>
  // 	|	<embedded variable specification>
  public static boolean target_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "target_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TARGET_SPECIFICATION, "<target specification>");
    r = host_parameter_specification(b, l + 1);
    if (!r) r = SQL_parameter_reference(b, l + 1);
    if (!r) r = column_reference(b, l + 1);
    if (!r) r = target_array_element_specification(b, l + 1);
    if (!r) r = dynamic_parameter_specification(b, l + 1);
    if (!r) r = embedded_variable_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <path-resolved user-defined type name>
  // 	|	<reference type>
  public static boolean target_subtype(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "target_subtype")) return false;
    if (!nextTokenIs(b, "<target subtype>", _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, _REFERENCE_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TARGET_SUBTYPE, "<target subtype>");
    r = path_resolved_user_defined_type_name(b, l + 1);
    if (!r) r = reference_type(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <table name>
  // 	|	ONLY <left paren> <table name> <right paren>
  public static boolean target_table(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "target_table")) return false;
    if (!nextTokenIs(b, "<target table>", ONLY, _TABLE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TARGET_TABLE, "<target table>");
    r = table_name(b, l + 1);
    if (!r) r = parseTokens(b, 0, ONLY, _LEFT_PAREN_, _TABLE_NAME_, _RIGHT_PAREN_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // DECLARE LOCAL TEMPORARY TABLE <table name> <table element list>
  // 		[ ON COMMIT <table commit action> ROWS ]
  public static boolean temporary_table_declaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "temporary_table_declaration")) return false;
    if (!nextTokenIs(b, DECLARE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, DECLARE, LOCAL, TEMPORARY, TABLE, _TABLE_NAME_, _TABLE_ELEMENT_LIST_);
    r = r && temporary_table_declaration_6(b, l + 1);
    exit_section_(b, m, TEMPORARY_TABLE_DECLARATION, r);
    return r;
  }

  // [ ON COMMIT <table commit action> ROWS ]
  private static boolean temporary_table_declaration_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "temporary_table_declaration_6")) return false;
    parseTokens(b, 0, ON, COMMIT, _TABLE_COMMIT_ACTION_, ROWS);
    return true;
  }

  /* ********************************************************** */
  // <factor>
  // 	|	<term> <asterisk> <factor>
  // 	|	<term> <solidus> <factor>
  public static boolean term(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "term")) return false;
    if (!nextTokenIs(b, "<term>", _FACTOR_, _TERM_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TERM, "<term>");
    r = factor(b, l + 1);
    if (!r) r = term(b, l + 1);
    if (!r) r = term(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <unsigned integer>
  public static boolean time_fractional_seconds_precision(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_fractional_seconds_precision")) return false;
    if (!nextTokenIs(b, _UNSIGNED_INTEGER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_integer(b, l + 1);
    exit_section_(b, m, TIME_FRACTIONAL_SECONDS_PRECISION, r);
    return r;
  }

  /* ********************************************************** */
  // <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ]
  // 	|	<minutes value> [ <colon> <seconds value> ]
  // 	|	<seconds value>
  public static boolean time_interval(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_interval")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TIME_INTERVAL, "<time interval>");
    r = time_interval_0(b, l + 1);
    if (!r) r = time_interval_1(b, l + 1);
    if (!r) r = seconds_value(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ]
  private static boolean time_interval_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_interval_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = hours_value(b, l + 1);
    r = r && time_interval_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <colon> <minutes value> [ <colon> <seconds value> ] ]
  private static boolean time_interval_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_interval_0_1")) return false;
    time_interval_0_1_0(b, l + 1);
    return true;
  }

  // <colon> <minutes value> [ <colon> <seconds value> ]
  private static boolean time_interval_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_interval_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = colon(b, l + 1);
    r = r && minutes_value(b, l + 1);
    r = r && time_interval_0_1_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <colon> <seconds value> ]
  private static boolean time_interval_0_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_interval_0_1_0_2")) return false;
    colon(b, l + 1);
    return true;
  }

  // <minutes value> [ <colon> <seconds value> ]
  private static boolean time_interval_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_interval_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = minutes_value(b, l + 1);
    r = r && time_interval_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <colon> <seconds value> ]
  private static boolean time_interval_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_interval_1_1")) return false;
    colon(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // TIME <time string>
  public static boolean time_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_literal")) return false;
    if (!nextTokenIs(b, TIME)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TIME, _TIME_STRING_);
    exit_section_(b, m, TIME_LITERAL, r);
    return r;
  }

  /* ********************************************************** */
  // <time fractional seconds precision>
  public static boolean time_precision(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_precision")) return false;
    if (!nextTokenIs(b, _TIME_FRACTIONAL_SECONDS_PRECISION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = time_fractional_seconds_precision(b, l + 1);
    exit_section_(b, m, TIME_PRECISION, r);
    return r;
  }

  /* ********************************************************** */
  // <quote> <unquoted time string> <quote>
  public static boolean time_string(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_string")) return false;
    if (!nextTokenIs(b, _QUOTE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = quote(b, l + 1);
    r = r && unquoted_time_string(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, TIME_STRING, r);
    return r;
  }

  /* ********************************************************** */
  // <hours value> <colon> <minutes value> <colon> <seconds value>
  public static boolean time_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_value")) return false;
    if (!nextTokenIs(b, _HOURS_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = hours_value(b, l + 1);
    r = r && colon(b, l + 1);
    r = r && minutes_value(b, l + 1);
    r = r && colon(b, l + 1);
    r = r && seconds_value(b, l + 1);
    exit_section_(b, m, TIME_VALUE, r);
    return r;
  }

  /* ********************************************************** */
  // AT <time zone specifier>
  public static boolean time_zone(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_zone")) return false;
    if (!nextTokenIs(b, AT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, AT, _TIME_ZONE_SPECIFIER_);
    exit_section_(b, m, TIME_ZONE, r);
    return r;
  }

  /* ********************************************************** */
  // TIMEZONE_HOUR | TIMEZONE_MINUTE
  public static boolean time_zone_field(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_zone_field")) return false;
    if (!nextTokenIs(b, "<time zone field>", TIMEZONE_HOUR, TIMEZONE_MINUTE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TIME_ZONE_FIELD, "<time zone field>");
    r = consumeToken(b, TIMEZONE_HOUR);
    if (!r) r = consumeToken(b, TIMEZONE_MINUTE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <sign> <hours value> <colon> <minutes value>
  public static boolean time_zone_interval(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_zone_interval")) return false;
    if (!nextTokenIs(b, _SIGN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = sign(b, l + 1);
    r = r && hours_value(b, l + 1);
    r = r && colon(b, l + 1);
    r = r && minutes_value(b, l + 1);
    exit_section_(b, m, TIME_ZONE_INTERVAL, r);
    return r;
  }

  /* ********************************************************** */
  // LOCAL | TIME ZONE <interval primary>
  public static boolean time_zone_specifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "time_zone_specifier")) return false;
    if (!nextTokenIs(b, "<time zone specifier>", LOCAL, TIME)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TIME_ZONE_SPECIFIER, "<time zone specifier>");
    r = consumeToken(b, LOCAL);
    if (!r) r = parseTokens(b, 0, TIME, ZONE, _INTERVAL_PRIMARY_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // TIMESTAMP <timestamp string>
  public static boolean timestamp_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "timestamp_literal")) return false;
    if (!nextTokenIs(b, TIMESTAMP)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TIMESTAMP, _TIMESTAMP_STRING_);
    exit_section_(b, m, TIMESTAMP_LITERAL, r);
    return r;
  }

  /* ********************************************************** */
  // <time fractional seconds precision>
  public static boolean timestamp_precision(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "timestamp_precision")) return false;
    if (!nextTokenIs(b, _TIME_FRACTIONAL_SECONDS_PRECISION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = time_fractional_seconds_precision(b, l + 1);
    exit_section_(b, m, TIMESTAMP_PRECISION, r);
    return r;
  }

  /* ********************************************************** */
  // <quote> <unquoted timestamp string> <quote>
  public static boolean timestamp_string(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "timestamp_string")) return false;
    if (!nextTokenIs(b, _QUOTE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = quote(b, l + 1);
    r = r && unquoted_timestamp_string(b, l + 1);
    r = r && quote(b, l + 1);
    exit_section_(b, m, TIMESTAMP_STRING, r);
    return r;
  }

  /* ********************************************************** */
  // TO SQL WITH <to sql function>
  public static boolean to_sql(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "to_sql")) return false;
    if (!nextTokenIs(b, TO)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TO, SQL, WITH, _TO_SQL_FUNCTION_);
    exit_section_(b, m, TO_SQL, r);
    return r;
  }

  /* ********************************************************** */
  // <specific routine designator>
  public static boolean to_sql_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "to_sql_function")) return false;
    if (!nextTokenIs(b, _SPECIFIC_ROUTINE_DESIGNATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = specific_routine_designator(b, l + 1);
    exit_section_(b, m, TO_SQL_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <nondelimiter token> | <delimiter token>
  public static boolean token(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "token")) return false;
    if (!nextTokenIs(b, "<token>", _DELIMITER_TOKEN_, _NONDELIMITER_TOKEN_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TOKEN, "<token>");
    r = nondelimiter_token(b, l + 1);
    if (!r) r = consumeToken(b, _DELIMITER_TOKEN_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // READ ONLY | READ WRITE
  public static boolean transaction_access_mode(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transaction_access_mode")) return false;
    if (!nextTokenIs(b, READ)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, READ, ONLY);
    if (!r) r = parseTokens(b, 0, READ, WRITE);
    exit_section_(b, m, TRANSACTION_ACCESS_MODE, r);
    return r;
  }

  /* ********************************************************** */
  // TRANSACTION <transaction mode> [ { <comma> <transaction mode> }... ]
  public static boolean transaction_characteristics(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transaction_characteristics")) return false;
    if (!nextTokenIs(b, TRANSACTION)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TRANSACTION, _TRANSACTION_MODE_);
    r = r && transaction_characteristics_2(b, l + 1);
    exit_section_(b, m, TRANSACTION_CHARACTERISTICS, r);
    return r;
  }

  // [ { <comma> <transaction mode> }... ]
  private static boolean transaction_characteristics_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transaction_characteristics_2")) return false;
    transaction_characteristics_2_0(b, l + 1);
    return true;
  }

  // <comma> <transaction mode>
  private static boolean transaction_characteristics_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transaction_characteristics_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && transaction_mode(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <isolation level> | <transaction access mode> | <diagnostics size>
  public static boolean transaction_mode(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transaction_mode")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRANSACTION_MODE, "<transaction mode>");
    r = isolation_level(b, l + 1);
    if (!r) r = transaction_access_mode(b, l + 1);
    if (!r) r = diagnostics_size(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CONVERT <left paren> <character value expression> USING <transcoding name> <right paren>
  public static boolean transcoding(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transcoding")) return false;
    if (!nextTokenIs(b, CONVERT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CONVERT, _LEFT_PAREN_, _CHARACTER_VALUE_EXPRESSION_, USING, _TRANSCODING_NAME_, _RIGHT_PAREN_);
    exit_section_(b, m, TRANSCODING, r);
    return r;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean transcoding_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transcoding_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, TRANSCODING_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE { TRANSFORM | TRANSFORMS } FOR <schema-resolved user-defined type name> <transform group>...
  public static boolean transform_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CREATE);
    r = r && transform_definition_1(b, l + 1);
    r = r && consumeTokens(b, 0, FOR, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_, _TRANSFORM_GROUP_);
    exit_section_(b, m, TRANSFORM_DEFINITION, r);
    return r;
  }

  // TRANSFORM | TRANSFORMS
  private static boolean transform_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_definition_1")) return false;
    boolean r;
    r = consumeToken(b, TRANSFORM);
    if (!r) r = consumeToken(b, TRANSFORMS);
    return r;
  }

  /* ********************************************************** */
  // <to sql> | <from sql>
  public static boolean transform_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_element")) return false;
    if (!nextTokenIs(b, "<transform element>", _FROM_SQL_, _TO_SQL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRANSFORM_ELEMENT, "<transform element>");
    r = to_sql(b, l + 1);
    if (!r) r = from_sql(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <transform element> [ <comma> <transform element> ]
  public static boolean transform_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_element_list")) return false;
    if (!nextTokenIs(b, _TRANSFORM_ELEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = transform_element(b, l + 1);
    r = r && transform_element_list_1(b, l + 1);
    exit_section_(b, m, TRANSFORM_ELEMENT_LIST, r);
    return r;
  }

  // [ <comma> <transform element> ]
  private static boolean transform_element_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_element_list_1")) return false;
    comma(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <group name> <left paren> <transform element list> <right paren>
  public static boolean transform_group(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_group")) return false;
    if (!nextTokenIs(b, _GROUP_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = group_name(b, l + 1);
    r = r && left_paren(b, l + 1);
    r = r && transform_element_list(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, TRANSFORM_GROUP, r);
    return r;
  }

  /* ********************************************************** */
  // DEFAULT TRANSFORM GROUP <value specification>
  // 	|	TRANSFORM GROUP FOR TYPE <path-resolved user-defined type name> <value specification>
  public static boolean transform_group_characteristic(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_group_characteristic")) return false;
    if (!nextTokenIs(b, "<transform group characteristic>", DEFAULT, TRANSFORM)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRANSFORM_GROUP_CHARACTERISTIC, "<transform group characteristic>");
    r = parseTokens(b, 0, DEFAULT, TRANSFORM, GROUP, _VALUE_SPECIFICATION_);
    if (!r) r = parseTokens(b, 0, TRANSFORM, GROUP, FOR, TYPE, _PATH_RESOLVED_USER_DEFINED_TYPE_NAME_, _VALUE_SPECIFICATION_);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <group name>
  public static boolean transform_group_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_group_element")) return false;
    if (!nextTokenIs(b, _GROUP_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = group_name(b, l + 1);
    exit_section_(b, m, TRANSFORM_GROUP_ELEMENT, r);
    return r;
  }

  /* ********************************************************** */
  // TRANSFORM GROUP { <single group specification> | <multiple group specification> }
  public static boolean transform_group_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_group_specification")) return false;
    if (!nextTokenIs(b, TRANSFORM)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TRANSFORM, GROUP);
    r = r && transform_group_specification_2(b, l + 1);
    exit_section_(b, m, TRANSFORM_GROUP_SPECIFICATION, r);
    return r;
  }

  // <single group specification> | <multiple group specification>
  private static boolean transform_group_specification_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_group_specification_2")) return false;
    boolean r;
    r = single_group_specification(b, l + 1);
    if (!r) r = multiple_group_specification(b, l + 1);
    return r;
  }

  /* ********************************************************** */
  // TO SQL | FROM SQL
  public static boolean transform_kind(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transform_kind")) return false;
    if (!nextTokenIs(b, "<transform kind>", FROM, TO)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRANSFORM_KIND, "<transform kind>");
    r = parseTokens(b, 0, TO, SQL);
    if (!r) r = parseTokens(b, 0, FROM, SQL);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ALL | <transform group element>
  public static boolean transforms_to_be_dropped(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transforms_to_be_dropped")) return false;
    if (!nextTokenIs(b, "<transforms to be dropped>", ALL, _TRANSFORM_GROUP_ELEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRANSFORMS_TO_BE_DROPPED, "<transforms to be dropped>");
    r = consumeToken(b, ALL);
    if (!r) r = transform_group_element(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // CREATE TRANSLATION <transliteration name> FOR <source character set specification>
  // 		TO <target character set specification> FROM <transliteration source>
  public static boolean transliteration_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transliteration_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, TRANSLATION, _TRANSLITERATION_NAME_, FOR, _SOURCE_CHARACTER_SET_SPECIFICATION_, TO, _TARGET_CHARACTER_SET_SPECIFICATION_, FROM, _TRANSLITERATION_SOURCE_);
    exit_section_(b, m, TRANSLITERATION_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean transliteration_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transliteration_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, TRANSLITERATION_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <specific routine designator>
  public static boolean transliteration_routine(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transliteration_routine")) return false;
    if (!nextTokenIs(b, _SPECIFIC_ROUTINE_DESIGNATOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = specific_routine_designator(b, l + 1);
    exit_section_(b, m, TRANSLITERATION_ROUTINE, r);
    return r;
  }

  /* ********************************************************** */
  // <existing transliteration name> | <transliteration routine>
  public static boolean transliteration_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "transliteration_source")) return false;
    if (!nextTokenIs(b, "<transliteration source>", _EXISTING_TRANSLITERATION_NAME_, _TRANSLITERATION_ROUTINE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRANSLITERATION_SOURCE, "<transliteration source>");
    r = existing_transliteration_name(b, l + 1);
    if (!r) r = transliteration_routine(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // BEFORE | AFTER
  public static boolean trigger_action_time(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trigger_action_time")) return false;
    if (!nextTokenIs(b, "<trigger action time>", AFTER, BEFORE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRIGGER_ACTION_TIME, "<trigger action time>");
    r = consumeToken(b, BEFORE);
    if (!r) r = consumeToken(b, AFTER);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean trigger_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trigger_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, TRIGGER_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE TRIGGER <trigger name> <trigger action time> <trigger event>
  // 		ON <table name> [ REFERENCING <old or new values alias list> ]
  // 		<triggered action>
  public static boolean trigger_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trigger_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, TRIGGER, _TRIGGER_NAME_, _TRIGGER_ACTION_TIME_, _TRIGGER_EVENT_, ON, _TABLE_NAME_);
    r = r && trigger_definition_7(b, l + 1);
    r = r && triggered_action(b, l + 1);
    exit_section_(b, m, TRIGGER_DEFINITION, r);
    return r;
  }

  // [ REFERENCING <old or new values alias list> ]
  private static boolean trigger_definition_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trigger_definition_7")) return false;
    parseTokens(b, 0, REFERENCING, _OLD_OR_NEW_VALUES_ALIAS_LIST_);
    return true;
  }

  /* ********************************************************** */
  // INSERT | DELETE | UPDATE [ OF <trigger column list> ]
  public static boolean trigger_event(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trigger_event")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRIGGER_EVENT, "<trigger event>");
    r = consumeToken(b, INSERT);
    if (!r) r = consumeToken(b, DELETE);
    if (!r) r = trigger_event_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // UPDATE [ OF <trigger column list> ]
  private static boolean trigger_event_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trigger_event_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, UPDATE);
    r = r && trigger_event_2_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ OF <trigger column list> ]
  private static boolean trigger_event_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trigger_event_2_1")) return false;
    parseTokens(b, 0, OF, _TRIGGER_COLUMN_LIST_);
    return true;
  }

  /* ********************************************************** */
  // <schema qualified name>
  public static boolean trigger_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trigger_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_name(b, l + 1);
    exit_section_(b, m, TRIGGER_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <SQL procedure statement>
  // 	|	BEGIN ATOMIC { <SQL procedure statement> <semicolon> }...  END
  public static boolean triggered_SQL_statement(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "triggered_SQL_statement")) return false;
    if (!nextTokenIs(b, "<triggered sql statement>", BEGIN, _SQL_PROCEDURE_STATEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRIGGERED_SQL_STATEMENT, "<triggered sql statement>");
    r = SQL_procedure_statement(b, l + 1);
    if (!r) r = triggered_SQL_statement_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // BEGIN ATOMIC { <SQL procedure statement> <semicolon> }...  END
  private static boolean triggered_SQL_statement_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "triggered_SQL_statement_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, BEGIN, ATOMIC);
    r = r && triggered_SQL_statement_1_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // <SQL procedure statement> <semicolon>
  private static boolean triggered_SQL_statement_1_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "triggered_SQL_statement_1_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = SQL_procedure_statement(b, l + 1);
    r = r && semicolon(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // [ FOR EACH { ROW | STATEMENT } ]
  // 		[ WHEN <left paren> <search condition> <right paren> ]
  // 		<triggered SQL statement>
  public static boolean triggered_action(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "triggered_action")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRIGGERED_ACTION, "<triggered action>");
    r = triggered_action_0(b, l + 1);
    r = r && triggered_action_1(b, l + 1);
    r = r && triggered_SQL_statement(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ FOR EACH { ROW | STATEMENT } ]
  private static boolean triggered_action_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "triggered_action_0")) return false;
    triggered_action_0_0(b, l + 1);
    return true;
  }

  // FOR EACH { ROW | STATEMENT }
  private static boolean triggered_action_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "triggered_action_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FOR, EACH);
    r = r && triggered_action_0_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ROW | STATEMENT
  private static boolean triggered_action_0_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "triggered_action_0_0_2")) return false;
    boolean r;
    r = consumeToken(b, ROW);
    if (!r) r = consumeToken(b, STATEMENT);
    return r;
  }

  // [ WHEN <left paren> <search condition> <right paren> ]
  private static boolean triggered_action_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "triggered_action_1")) return false;
    parseTokens(b, 0, WHEN, _LEFT_PAREN_, _SEARCH_CONDITION_, _RIGHT_PAREN_);
    return true;
  }

  /* ********************************************************** */
  // <character value expression>
  public static boolean trim_character(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_character")) return false;
    if (!nextTokenIs(b, _CHARACTER_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_value_expression(b, l + 1);
    exit_section_(b, m, TRIM_CHARACTER, r);
    return r;
  }

  /* ********************************************************** */
  // TRIM <left paren> <trim operands> <right paren>
  public static boolean trim_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_function")) return false;
    if (!nextTokenIs(b, TRIM)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TRIM, _LEFT_PAREN_, _TRIM_OPERANDS_, _RIGHT_PAREN_);
    exit_section_(b, m, TRIM_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <blob value expression>
  public static boolean trim_octet(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_octet")) return false;
    if (!nextTokenIs(b, _BLOB_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = blob_value_expression(b, l + 1);
    exit_section_(b, m, TRIM_OCTET, r);
    return r;
  }

  /* ********************************************************** */
  // [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>
  public static boolean trim_operands(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_operands")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRIM_OPERANDS, "<trim operands>");
    r = trim_operands_0(b, l + 1);
    r = r && trim_source(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ [ <trim specification> ] [ <trim character> ] FROM ]
  private static boolean trim_operands_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_operands_0")) return false;
    trim_operands_0_0(b, l + 1);
    return true;
  }

  // [ <trim specification> ] [ <trim character> ] FROM
  private static boolean trim_operands_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_operands_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = trim_operands_0_0_0(b, l + 1);
    r = r && trim_operands_0_0_1(b, l + 1);
    r = r && consumeToken(b, FROM);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <trim specification> ]
  private static boolean trim_operands_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_operands_0_0_0")) return false;
    trim_specification(b, l + 1);
    return true;
  }

  // [ <trim character> ]
  private static boolean trim_operands_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_operands_0_0_1")) return false;
    trim_character(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <character value expression>
  public static boolean trim_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_source")) return false;
    if (!nextTokenIs(b, _CHARACTER_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_value_expression(b, l + 1);
    exit_section_(b, m, TRIM_SOURCE, r);
    return r;
  }

  /* ********************************************************** */
  // LEADING | TRAILING | BOTH
  public static boolean trim_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "trim_specification")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRIM_SPECIFICATION, "<trim specification>");
    r = consumeToken(b, LEADING);
    if (!r) r = consumeToken(b, TRAILING);
    if (!r) r = consumeToken(b, BOTH);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // TRUE | FALSE | UNKNOWN
  public static boolean truth_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "truth_value")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TRUTH_VALUE, "<truth value>");
    r = consumeToken(b, TRUE);
    if (!r) r = consumeToken(b, FALSE);
    if (!r) r = consumeToken(b, UNKNOWN);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <user-defined type specification> [ { <comma> <user-defined type specification> }... ]
  public static boolean type_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "type_list")) return false;
    if (!nextTokenIs(b, _USER_DEFINED_TYPE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = user_defined_type_specification(b, l + 1);
    r = r && type_list_1(b, l + 1);
    exit_section_(b, m, TYPE_LIST, r);
    return r;
  }

  // [ { <comma> <user-defined type specification> }... ]
  private static boolean type_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "type_list_1")) return false;
    type_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <user-defined type specification>
  private static boolean type_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "type_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && user_defined_type_specification(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand> <type predicate part 2>
  public static boolean type_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "type_predicate")) return false;
    if (!nextTokenIs(b, _ROW_VALUE_PREDICAND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = row_value_predicand(b, l + 1);
    r = r && type_predicate_part_2(b, l + 1);
    exit_section_(b, m, TYPE_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // IS [ NOT ] OF <left paren> <type list> <right paren>
  public static boolean type_predicate_part_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "type_predicate_part_2")) return false;
    if (!nextTokenIs(b, IS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, IS);
    r = r && type_predicate_part_2_1(b, l + 1);
    r = r && consumeTokens(b, 0, OF, _LEFT_PAREN_, _TYPE_LIST_, _RIGHT_PAREN_);
    exit_section_(b, m, TYPE_PREDICATE_PART_2, r);
    return r;
  }

  // [ NOT ]
  private static boolean type_predicate_part_2_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "type_predicate_part_2_1")) return false;
    consumeToken(b, NOT);
    return true;
  }

  /* ********************************************************** */
  // _
  public static boolean underscore(PsiBuilder b, int l) {
    Marker m = enter_section_(b);
    exit_section_(b, m, UNDERSCORE, true);
    return true;
  }

  /* ********************************************************** */
  // <table reference> UNION JOIN <table primary>
  public static boolean union_join(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "union_join")) return false;
    if (!nextTokenIs(b, _TABLE_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = table_reference(b, l + 1);
    r = r && consumeTokens(b, 0, UNION, JOIN, _TABLE_PRIMARY_);
    exit_section_(b, m, UNION_JOIN, r);
    return r;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean unique_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unique_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, UNIQUE_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // <unique specification> <left paren> <unique column list> <right paren>
  // 	|	UNIQUE ( VALUE )
  public static boolean unique_constraint_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unique_constraint_definition")) return false;
    if (!nextTokenIs(b, "<unique constraint definition>", UNIQUE, _UNIQUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNIQUE_CONSTRAINT_DEFINITION, "<unique constraint definition>");
    r = unique_specification(b, l + 1);
    if (!r) r = unique_constraint_definition_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // UNIQUE ( VALUE )
  private static boolean unique_constraint_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unique_constraint_definition_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, UNIQUE);
    r = r && consumeToken(b, VALUE);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // UNIQUE <table subquery>
  public static boolean unique_predicate(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unique_predicate")) return false;
    if (!nextTokenIs(b, UNIQUE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UNIQUE, _TABLE_SUBQUERY_);
    exit_section_(b, m, UNIQUE_PREDICATE, r);
    return r;
  }

  /* ********************************************************** */
  // UNIQUE | PRIMARY KEY
  public static boolean unique_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unique_specification")) return false;
    if (!nextTokenIs(b, "<unique specification>", PRIMARY, UNIQUE)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNIQUE_SPECIFICATION, "<unique specification>");
    r = consumeToken(b, UNIQUE);
    if (!r) r = parseTokens(b, 0, PRIMARY, KEY);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <date value>
  public static boolean unquoted_date_string(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unquoted_date_string")) return false;
    if (!nextTokenIs(b, _DATE_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = date_value(b, l + 1);
    exit_section_(b, m, UNQUOTED_DATE_STRING, r);
    return r;
  }

  /* ********************************************************** */
  // [ <sign> ] { <year-month literal> | <day-time literal> }
  public static boolean unquoted_interval_string(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unquoted_interval_string")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNQUOTED_INTERVAL_STRING, "<unquoted interval string>");
    r = unquoted_interval_string_0(b, l + 1);
    r = r && unquoted_interval_string_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <sign> ]
  private static boolean unquoted_interval_string_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unquoted_interval_string_0")) return false;
    sign(b, l + 1);
    return true;
  }

  // <year-month literal> | <day-time literal>
  private static boolean unquoted_interval_string_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unquoted_interval_string_1")) return false;
    boolean r;
    r = year_month_literal(b, l + 1);
    if (!r) r = day_time_literal(b, l + 1);
    return r;
  }

  /* ********************************************************** */
  // <time value> [ <time zone interval> ]
  public static boolean unquoted_time_string(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unquoted_time_string")) return false;
    if (!nextTokenIs(b, _TIME_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = time_value(b, l + 1);
    r = r && unquoted_time_string_1(b, l + 1);
    exit_section_(b, m, UNQUOTED_TIME_STRING, r);
    return r;
  }

  // [ <time zone interval> ]
  private static boolean unquoted_time_string_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unquoted_time_string_1")) return false;
    time_zone_interval(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <unquoted date string> <space> <unquoted time string>
  public static boolean unquoted_timestamp_string(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unquoted_timestamp_string")) return false;
    if (!nextTokenIs(b, _UNQUOTED_DATE_STRING_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unquoted_date_string(b, l + 1);
    r = r && space(b, l + 1);
    r = r && unquoted_time_string(b, l + 1);
    exit_section_(b, m, UNQUOTED_TIMESTAMP_STRING, r);
    return r;
  }

  /* ********************************************************** */
  // <digit>...
  public static boolean unsigned_integer(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unsigned_integer")) return false;
    if (!nextTokenIs(b, _DIGIT____)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, _DIGIT____);
    exit_section_(b, m, UNSIGNED_INTEGER, r);
    return r;
  }

  /* ********************************************************** */
  // <unsigned numeric literal> | <general literal>
  public static boolean unsigned_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unsigned_literal")) return false;
    if (!nextTokenIs(b, "<unsigned literal>", _GENERAL_LITERAL_, _UNSIGNED_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNSIGNED_LITERAL, "<unsigned literal>");
    r = unsigned_numeric_literal(b, l + 1);
    if (!r) r = general_literal(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <exact numeric literal> | <approximate numeric literal>
  public static boolean unsigned_numeric_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unsigned_numeric_literal")) return false;
    if (!nextTokenIs(b, "<unsigned numeric literal>", _APPROXIMATE_NUMERIC_LITERAL_, _EXACT_NUMERIC_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNSIGNED_NUMERIC_LITERAL, "<unsigned numeric literal>");
    r = exact_numeric_literal(b, l + 1);
    if (!r) r = approximate_numeric_literal(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <unsigned literal> | <general value specification>
  public static boolean unsigned_value_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "unsigned_value_specification")) return false;
    if (!nextTokenIs(b, "<unsigned value specification>", _GENERAL_VALUE_SPECIFICATION_, _UNSIGNED_LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UNSIGNED_VALUE_SPECIFICATION, "<unsigned value specification>");
    r = unsigned_literal(b, l + 1);
    if (!r) r = general_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // FOR { READ ONLY | UPDATE [ OF <column name list> ] }
  public static boolean updatability_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "updatability_clause")) return false;
    if (!nextTokenIs(b, FOR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, FOR);
    r = r && updatability_clause_1(b, l + 1);
    exit_section_(b, m, UPDATABILITY_CLAUSE, r);
    return r;
  }

  // READ ONLY | UPDATE [ OF <column name list> ]
  private static boolean updatability_clause_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "updatability_clause_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, READ, ONLY);
    if (!r) r = updatability_clause_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // UPDATE [ OF <column name list> ]
  private static boolean updatability_clause_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "updatability_clause_1_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, UPDATE);
    r = r && updatability_clause_1_1_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ OF <column name list> ]
  private static boolean updatability_clause_1_1_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "updatability_clause_1_1_1")) return false;
    parseTokens(b, 0, OF, _COLUMN_NAME_LIST_);
    return true;
  }

  /* ********************************************************** */
  // ON UPDATE <referential action>
  public static boolean update_rule(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "update_rule")) return false;
    if (!nextTokenIs(b, ON)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ON, UPDATE, _REFERENTIAL_ACTION_);
    exit_section_(b, m, UPDATE_RULE, r);
    return r;
  }

  /* ********************************************************** */
  // <value expression> | <contextually typed value specification>
  public static boolean update_source(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "update_source")) return false;
    if (!nextTokenIs(b, "<update source>", _CONTEXTUALLY_TYPED_VALUE_SPECIFICATION_, _VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, UPDATE_SOURCE, "<update source>");
    r = value_expression(b, l + 1);
    if (!r) r = contextually_typed_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // UPDATE <target table> SET <set clause list> WHERE CURRENT OF <cursor name>
  public static boolean update_statement_positioned(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "update_statement_positioned")) return false;
    if (!nextTokenIs(b, UPDATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UPDATE, _TARGET_TABLE_, SET, _SET_CLAUSE_LIST_, WHERE, CURRENT, OF, _CURSOR_NAME_);
    exit_section_(b, m, UPDATE_STATEMENT_POSITIONED, r);
    return r;
  }

  /* ********************************************************** */
  // UPDATE <target table> SET <set clause list> [ WHERE <search condition> ]
  public static boolean update_statement_searched(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "update_statement_searched")) return false;
    if (!nextTokenIs(b, UPDATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, UPDATE, _TARGET_TABLE_, SET, _SET_CLAUSE_LIST_);
    r = r && update_statement_searched_4(b, l + 1);
    exit_section_(b, m, UPDATE_STATEMENT_SEARCHED, r);
    return r;
  }

  // [ WHERE <search condition> ]
  private static boolean update_statement_searched_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "update_statement_searched_4")) return false;
    parseTokens(b, 0, WHERE, _SEARCH_CONDITION_);
    return true;
  }

  /* ********************************************************** */
  // <object column>
  // 	|	<object column> <left bracket or trigraph> <simple value specification> <right bracket or trigraph>
  public static boolean update_target(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "update_target")) return false;
    if (!nextTokenIs(b, _OBJECT_COLUMN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = object_column(b, l + 1);
    if (!r) r = object_column(b, l + 1);
    exit_section_(b, m, UPDATE_TARGET, r);
    return r;
  }

  /* ********************************************************** */
  // <comma> [ <high value> ]
  public static boolean upper_limit(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "upper_limit")) return false;
    if (!nextTokenIs(b, _COMMA_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && upper_limit_1(b, l + 1);
    exit_section_(b, m, UPPER_LIMIT, r);
    return r;
  }

  // [ <high value> ]
  private static boolean upper_limit_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "upper_limit_1")) return false;
    high_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean user_identifier(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_identifier")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, USER_IDENTIFIER, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE CAST <left paren> <source data type> AS <target data type> <right paren>
  // 		WITH <cast function> [ AS ASSIGNMENT ]
  public static boolean user_defined_cast_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_cast_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, CAST, _LEFT_PAREN_, _SOURCE_DATA_TYPE_, AS, _TARGET_DATA_TYPE_, _RIGHT_PAREN_, WITH, _CAST_FUNCTION_);
    r = r && user_defined_cast_definition_9(b, l + 1);
    exit_section_(b, m, USER_DEFINED_CAST_DEFINITION, r);
    return r;
  }

  // [ AS ASSIGNMENT ]
  private static boolean user_defined_cast_definition_9(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_cast_definition_9")) return false;
    parseTokens(b, 0, AS, ASSIGNMENT);
    return true;
  }

  /* ********************************************************** */
  // <character set name>
  public static boolean user_defined_character_set_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_character_set_name")) return false;
    if (!nextTokenIs(b, _CHARACTER_SET_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = character_set_name(b, l + 1);
    exit_section_(b, m, USER_DEFINED_CHARACTER_SET_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE ORDERING FOR <schema-resolved user-defined type name> <ordering form>
  public static boolean user_defined_ordering_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_ordering_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, ORDERING, FOR, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_, _ORDERING_FORM_);
    exit_section_(b, m, USER_DEFINED_ORDERING_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // REF USING <predefined type>
  public static boolean user_defined_representation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_representation")) return false;
    if (!nextTokenIs(b, REF)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, REF, USING, _PREDEFINED_TYPE_);
    exit_section_(b, m, USER_DEFINED_REPRESENTATION, r);
    return r;
  }

  /* ********************************************************** */
  // <schema-resolved user-defined type name> [ <subtype clause> ]
  // 		[ AS <representation> ] [ <user-defined type option list> ] [ <method specification list> ]
  public static boolean user_defined_type_body(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_body")) return false;
    if (!nextTokenIs(b, _SCHEMA_RESOLVED_USER_DEFINED_TYPE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_resolved_user_defined_type_name(b, l + 1);
    r = r && user_defined_type_body_1(b, l + 1);
    r = r && user_defined_type_body_2(b, l + 1);
    r = r && user_defined_type_body_3(b, l + 1);
    r = r && user_defined_type_body_4(b, l + 1);
    exit_section_(b, m, USER_DEFINED_TYPE_BODY, r);
    return r;
  }

  // [ <subtype clause> ]
  private static boolean user_defined_type_body_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_body_1")) return false;
    subtype_clause(b, l + 1);
    return true;
  }

  // [ AS <representation> ]
  private static boolean user_defined_type_body_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_body_2")) return false;
    parseTokens(b, 0, AS, _REPRESENTATION_);
    return true;
  }

  // [ <user-defined type option list> ]
  private static boolean user_defined_type_body_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_body_3")) return false;
    user_defined_type_option_list(b, l + 1);
    return true;
  }

  // [ <method specification list> ]
  private static boolean user_defined_type_body_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_body_4")) return false;
    method_specification_list(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // CREATE TYPE <user-defined type body>
  public static boolean user_defined_type_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, CREATE, TYPE, _USER_DEFINED_TYPE_BODY_);
    exit_section_(b, m, USER_DEFINED_TYPE_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // <schema qualified type name>
  public static boolean user_defined_type_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_name")) return false;
    if (!nextTokenIs(b, _SCHEMA_QUALIFIED_TYPE_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = schema_qualified_type_name(b, l + 1);
    exit_section_(b, m, USER_DEFINED_TYPE_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <instantiable clause>
  // 	|	<finality>
  // 	|	<reference type specification>
  // 	|	<ref cast option>
  // 	|	<cast option>
  public static boolean user_defined_type_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_option")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, USER_DEFINED_TYPE_OPTION, "<user defined type option>");
    r = instantiable_clause(b, l + 1);
    if (!r) r = finality(b, l + 1);
    if (!r) r = reference_type_specification(b, l + 1);
    if (!r) r = ref_cast_option(b, l + 1);
    if (!r) r = cast_option(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <user-defined type option> [ <user-defined type option>... ]
  public static boolean user_defined_type_option_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_option_list")) return false;
    if (!nextTokenIs(b, _USER_DEFINED_TYPE_OPTION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = user_defined_type_option(b, l + 1);
    r = r && user_defined_type_option_list_1(b, l + 1);
    exit_section_(b, m, USER_DEFINED_TYPE_OPTION_LIST, r);
    return r;
  }

  // [ <user-defined type option>... ]
  private static boolean user_defined_type_option_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_option_list_1")) return false;
    consumeToken(b, _USER_DEFINED_TYPE_OPTION____);
    return true;
  }

  /* ********************************************************** */
  // <inclusive user-defined type specification>
  // 	|	<exclusive user-defined type specification>
  public static boolean user_defined_type_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_specification")) return false;
    if (!nextTokenIs(b, "<user defined type specification>", _EXCLUSIVE_USER_DEFINED_TYPE_SPECIFICATION_, _INCLUSIVE_USER_DEFINED_TYPE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, USER_DEFINED_TYPE_SPECIFICATION, "<user defined type specification>");
    r = inclusive_user_defined_type_specification(b, l + 1);
    if (!r) r = exclusive_user_defined_type_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <value expression primary>
  public static boolean user_defined_type_value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "user_defined_type_value_expression")) return false;
    if (!nextTokenIs(b, _VALUE_EXPRESSION_PRIMARY_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = value_expression_primary(b, l + 1);
    exit_section_(b, m, USER_DEFINED_TYPE_VALUE_EXPRESSION, r);
    return r;
  }

  /* ********************************************************** */
  // <general value specification>
  public static boolean using_argument(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "using_argument")) return false;
    if (!nextTokenIs(b, _GENERAL_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = general_value_specification(b, l + 1);
    exit_section_(b, m, USING_ARGUMENT, r);
    return r;
  }

  /* ********************************************************** */
  // USING <using argument> [ { <comma> <using argument> }... ]
  public static boolean using_arguments(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "using_arguments")) return false;
    if (!nextTokenIs(b, USING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, USING, _USING_ARGUMENT_);
    r = r && using_arguments_2(b, l + 1);
    exit_section_(b, m, USING_ARGUMENTS, r);
    return r;
  }

  // [ { <comma> <using argument> }... ]
  private static boolean using_arguments_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "using_arguments_2")) return false;
    using_arguments_2_0(b, l + 1);
    return true;
  }

  // <comma> <using argument>
  private static boolean using_arguments_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "using_arguments_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && using_argument(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // USING [ SQL ] DESCRIPTOR <descriptor name>
  public static boolean using_descriptor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "using_descriptor")) return false;
    if (!nextTokenIs(b, USING)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, USING);
    r = r && using_descriptor_1(b, l + 1);
    r = r && consumeTokens(b, 0, DESCRIPTOR, _DESCRIPTOR_NAME_);
    exit_section_(b, m, USING_DESCRIPTOR, r);
    return r;
  }

  // [ SQL ]
  private static boolean using_descriptor_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "using_descriptor_1")) return false;
    consumeToken(b, SQL);
    return true;
  }

  /* ********************************************************** */
  // <using descriptor>
  public static boolean using_input_descriptor(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "using_input_descriptor")) return false;
    if (!nextTokenIs(b, _USING_DESCRIPTOR_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = using_descriptor(b, l + 1);
    exit_section_(b, m, USING_INPUT_DESCRIPTOR, r);
    return r;
  }

  /* ********************************************************** */
  // <common value expression>
  // 	|	<boolean value expression>
  // 	|	<row value expression>
  public static boolean value_expression(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "value_expression")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, VALUE_EXPRESSION, "<value expression>");
    r = common_value_expression(b, l + 1);
    if (!r) r = boolean_value_expression(b, l + 1);
    if (!r) r = row_value_expression(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <parenthesized value expression>
  // 	|	<nonparenthesized value expression primary>
  public static boolean value_expression_primary(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "value_expression_primary")) return false;
    if (!nextTokenIs(b, "<value expression primary>", _NONPARENTHESIZED_VALUE_EXPRESSION_PRIMARY_, _PARENTHESIZED_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, VALUE_EXPRESSION_PRIMARY, "<value expression primary>");
    r = parenthesized_value_expression(b, l + 1);
    if (!r) r = nonparenthesized_value_expression_primary(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <literal> | <general value specification>
  public static boolean value_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "value_specification")) return false;
    if (!nextTokenIs(b, "<value specification>", _GENERAL_VALUE_SPECIFICATION_, _LITERAL_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, VALUE_SPECIFICATION, "<value specification>");
    r = literal(b, l + 1);
    if (!r) r = general_value_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // |
  public static boolean vertical_bar(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "vertical_bar")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, VERTICAL_BAR, "<vertical bar>");
    r = consumeToken(b, VERTICAL_BAR_0_0);
    if (!r) r = consumeToken(b, VERTICAL_BAR_1_0);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean view_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, VIEW_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // <column name> WITH OPTIONS <scope clause>
  public static boolean view_column_option(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_column_option")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name(b, l + 1);
    r = r && consumeTokens(b, 0, WITH, OPTIONS, _SCOPE_CLAUSE_);
    exit_section_(b, m, VIEW_COLUMN_OPTION, r);
    return r;
  }

  /* ********************************************************** */
  // CREATE [ RECURSIVE ] VIEW <table name> <view specification> AS <query expression>
  // 		[ WITH [ <levels clause> ] CHECK OPTION ]
  public static boolean view_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_definition")) return false;
    if (!nextTokenIs(b, CREATE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, CREATE);
    r = r && view_definition_1(b, l + 1);
    r = r && consumeTokens(b, 0, VIEW, _TABLE_NAME_, _VIEW_SPECIFICATION_, AS, _QUERY_EXPRESSION_);
    r = r && view_definition_7(b, l + 1);
    exit_section_(b, m, VIEW_DEFINITION, r);
    return r;
  }

  // [ RECURSIVE ]
  private static boolean view_definition_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_definition_1")) return false;
    consumeToken(b, RECURSIVE);
    return true;
  }

  // [ WITH [ <levels clause> ] CHECK OPTION ]
  private static boolean view_definition_7(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_definition_7")) return false;
    view_definition_7_0(b, l + 1);
    return true;
  }

  // WITH [ <levels clause> ] CHECK OPTION
  private static boolean view_definition_7_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_definition_7_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, WITH);
    r = r && view_definition_7_0_1(b, l + 1);
    r = r && consumeTokens(b, 0, CHECK, OPTION);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <levels clause> ]
  private static boolean view_definition_7_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_definition_7_0_1")) return false;
    levels_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <self-referencing column specification> | <view column option>
  public static boolean view_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_element")) return false;
    if (!nextTokenIs(b, "<view element>", _SELF_REFERENCING_COLUMN_SPECIFICATION_, _VIEW_COLUMN_OPTION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, VIEW_ELEMENT, "<view element>");
    r = self_referencing_column_specification(b, l + 1);
    if (!r) r = view_column_option(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <view element> [ { <comma> <view element> }... ] <right paren>
  public static boolean view_element_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_element_list")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && view_element(b, l + 1);
    r = r && view_element_list_2(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, VIEW_ELEMENT_LIST, r);
    return r;
  }

  // [ { <comma> <view element> }... ]
  private static boolean view_element_list_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_element_list_2")) return false;
    view_element_list_2_0(b, l + 1);
    return true;
  }

  // <comma> <view element>
  private static boolean view_element_list_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_element_list_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && view_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <regular view specification> | <referenceable view specification>
  public static boolean view_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "view_specification")) return false;
    if (!nextTokenIs(b, "<view specification>", _REFERENCEABLE_VIEW_SPECIFICATION_, _REGULAR_VIEW_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, VIEW_SPECIFICATION, "<view specification>");
    r = regular_view_specification(b, l + 1);
    if (!r) r = referenceable_view_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <row value predicand>
  // 	|	<comparison predicate part 2>
  // 	|	<between predicate part 2>
  // 	|	<in predicate part 2>
  // 	|	<character like predicate part 2>
  // 	|	<octet like predicate part 2>
  // 	|	<similar predicate part 2>
  // 	|	<null predicate part 2>
  // 	|	<quantified comparison predicate part 2>
  // 	|	<match predicate part 2>
  // 	|	<overlaps predicate part 2>
  // 	|	<distinct predicate part 2>
  // 	|	<member predicate part 2>
  // 	|	<submultiset predicate part 2>
  // 	|	<set predicate part 2>
  // 	|	<type predicate part 2>
  public static boolean when_operand(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "when_operand")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WHEN_OPERAND, "<when operand>");
    r = row_value_predicand(b, l + 1);
    if (!r) r = comparison_predicate_part_2(b, l + 1);
    if (!r) r = between_predicate_part_2(b, l + 1);
    if (!r) r = in_predicate_part_2(b, l + 1);
    if (!r) r = character_like_predicate_part_2(b, l + 1);
    if (!r) r = octet_like_predicate_part_2(b, l + 1);
    if (!r) r = similar_predicate_part_2(b, l + 1);
    if (!r) r = null_predicate_part_2(b, l + 1);
    if (!r) r = quantified_comparison_predicate_part_2(b, l + 1);
    if (!r) r = match_predicate_part_2(b, l + 1);
    if (!r) r = overlaps_predicate_part_2(b, l + 1);
    if (!r) r = distinct_predicate_part_2(b, l + 1);
    if (!r) r = member_predicate_part_2(b, l + 1);
    if (!r) r = submultiset_predicate_part_2(b, l + 1);
    if (!r) r = set_predicate_part_2(b, l + 1);
    if (!r) r = type_predicate_part_2(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // WHERE <search condition>
  public static boolean where_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "where_clause")) return false;
    if (!nextTokenIs(b, WHERE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WHERE, _SEARCH_CONDITION_);
    exit_section_(b, m, WHERE_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean width_bucket_bound_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "width_bucket_bound_1")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, WIDTH_BUCKET_BOUND_1, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean width_bucket_bound_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "width_bucket_bound_2")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, WIDTH_BUCKET_BOUND_2, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean width_bucket_count(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "width_bucket_count")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, WIDTH_BUCKET_COUNT, r);
    return r;
  }

  /* ********************************************************** */
  // WIDTH_BUCKET <left paren> <width bucket operand> <comma> <width bucket bound 1> <comma> <width bucket bound 2> <comma> <width bucket count> <right paren>
  public static boolean width_bucket_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "width_bucket_function")) return false;
    if (!nextTokenIs(b, WIDTH_BUCKET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WIDTH_BUCKET, _LEFT_PAREN_, _WIDTH_BUCKET_OPERAND_, _COMMA_, _WIDTH_BUCKET_BOUND_1_, _COMMA_, _WIDTH_BUCKET_BOUND_2_, _COMMA_, _WIDTH_BUCKET_COUNT_, _RIGHT_PAREN_);
    exit_section_(b, m, WIDTH_BUCKET_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <numeric value expression>
  public static boolean width_bucket_operand(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "width_bucket_operand")) return false;
    if (!nextTokenIs(b, _NUMERIC_VALUE_EXPRESSION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = numeric_value_expression(b, l + 1);
    exit_section_(b, m, WIDTH_BUCKET_OPERAND, r);
    return r;
  }

  /* ********************************************************** */
  // WINDOW <window definition list>
  public static boolean window_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_clause")) return false;
    if (!nextTokenIs(b, WINDOW)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WINDOW, _WINDOW_DEFINITION_LIST_);
    exit_section_(b, m, WINDOW_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <new window name> AS <window specification>
  public static boolean window_definition(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_definition")) return false;
    if (!nextTokenIs(b, _NEW_WINDOW_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = new_window_name(b, l + 1);
    r = r && consumeTokens(b, 0, AS, _WINDOW_SPECIFICATION_);
    exit_section_(b, m, WINDOW_DEFINITION, r);
    return r;
  }

  /* ********************************************************** */
  // <window definition> [ { <comma> <window definition> }... ]
  public static boolean window_definition_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_definition_list")) return false;
    if (!nextTokenIs(b, _WINDOW_DEFINITION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_definition(b, l + 1);
    r = r && window_definition_list_1(b, l + 1);
    exit_section_(b, m, WINDOW_DEFINITION_LIST, r);
    return r;
  }

  // [ { <comma> <window definition> }... ]
  private static boolean window_definition_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_definition_list_1")) return false;
    window_definition_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <window definition>
  private static boolean window_definition_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_definition_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && window_definition(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // BETWEEN <window frame bound 1> AND <window frame bound 2>
  public static boolean window_frame_between(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_between")) return false;
    if (!nextTokenIs(b, BETWEEN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, BETWEEN, _WINDOW_FRAME_BOUND_1_, AND, _WINDOW_FRAME_BOUND_2_);
    exit_section_(b, m, WINDOW_FRAME_BETWEEN, r);
    return r;
  }

  /* ********************************************************** */
  // <window frame start>
  // 	|	UNBOUNDED FOLLOWING
  // 	|	<window frame following>
  public static boolean window_frame_bound(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_bound")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WINDOW_FRAME_BOUND, "<window frame bound>");
    r = window_frame_start(b, l + 1);
    if (!r) r = parseTokens(b, 0, UNBOUNDED, FOLLOWING);
    if (!r) r = window_frame_following(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <window frame bound>
  public static boolean window_frame_bound_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_bound_1")) return false;
    if (!nextTokenIs(b, _WINDOW_FRAME_BOUND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_frame_bound(b, l + 1);
    exit_section_(b, m, WINDOW_FRAME_BOUND_1, r);
    return r;
  }

  /* ********************************************************** */
  // <window frame bound>
  public static boolean window_frame_bound_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_bound_2")) return false;
    if (!nextTokenIs(b, _WINDOW_FRAME_BOUND_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_frame_bound(b, l + 1);
    exit_section_(b, m, WINDOW_FRAME_BOUND_2, r);
    return r;
  }

  /* ********************************************************** */
  // <window frame units> <window frame extent> [ <window frame exclusion> ]
  public static boolean window_frame_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_clause")) return false;
    if (!nextTokenIs(b, _WINDOW_FRAME_UNITS_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_frame_units(b, l + 1);
    r = r && window_frame_extent(b, l + 1);
    r = r && window_frame_clause_2(b, l + 1);
    exit_section_(b, m, WINDOW_FRAME_CLAUSE, r);
    return r;
  }

  // [ <window frame exclusion> ]
  private static boolean window_frame_clause_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_clause_2")) return false;
    window_frame_exclusion(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // EXCLUDE CURRENT ROW
  // 	|	EXCLUDE GROUP
  // 	|	EXCLUDE TIES
  // 	|	EXCLUDE NO OTHERS
  public static boolean window_frame_exclusion(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_exclusion")) return false;
    if (!nextTokenIs(b, EXCLUDE)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, EXCLUDE, CURRENT, ROW);
    if (!r) r = parseTokens(b, 0, EXCLUDE, GROUP);
    if (!r) r = parseTokens(b, 0, EXCLUDE, TIES);
    if (!r) r = parseTokens(b, 0, EXCLUDE, NO, OTHERS);
    exit_section_(b, m, WINDOW_FRAME_EXCLUSION, r);
    return r;
  }

  /* ********************************************************** */
  // <window frame start> | <window frame between>
  public static boolean window_frame_extent(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_extent")) return false;
    if (!nextTokenIs(b, "<window frame extent>", _WINDOW_FRAME_BETWEEN_, _WINDOW_FRAME_START_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WINDOW_FRAME_EXTENT, "<window frame extent>");
    r = window_frame_start(b, l + 1);
    if (!r) r = window_frame_between(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <unsigned value specification> FOLLOWING
  public static boolean window_frame_following(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_following")) return false;
    if (!nextTokenIs(b, _UNSIGNED_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_value_specification(b, l + 1);
    r = r && consumeToken(b, FOLLOWING);
    exit_section_(b, m, WINDOW_FRAME_FOLLOWING, r);
    return r;
  }

  /* ********************************************************** */
  // <unsigned value specification> PRECEDING
  public static boolean window_frame_preceding(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_preceding")) return false;
    if (!nextTokenIs(b, _UNSIGNED_VALUE_SPECIFICATION_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = unsigned_value_specification(b, l + 1);
    r = r && consumeToken(b, PRECEDING);
    exit_section_(b, m, WINDOW_FRAME_PRECEDING, r);
    return r;
  }

  /* ********************************************************** */
  // UNBOUNDED PRECEDING | <window frame preceding> | CURRENT ROW
  public static boolean window_frame_start(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_start")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WINDOW_FRAME_START, "<window frame start>");
    r = parseTokens(b, 0, UNBOUNDED, PRECEDING);
    if (!r) r = window_frame_preceding(b, l + 1);
    if (!r) r = parseTokens(b, 0, CURRENT, ROW);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ROWS | RANGE
  public static boolean window_frame_units(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_frame_units")) return false;
    if (!nextTokenIs(b, "<window frame units>", RANGE, ROWS)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WINDOW_FRAME_UNITS, "<window frame units>");
    r = consumeToken(b, ROWS);
    if (!r) r = consumeToken(b, RANGE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <window function type> OVER <window name or specification>
  public static boolean window_function(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_function")) return false;
    if (!nextTokenIs(b, _WINDOW_FUNCTION_TYPE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_function_type(b, l + 1);
    r = r && consumeTokens(b, 0, OVER, _WINDOW_NAME_OR_SPECIFICATION_);
    exit_section_(b, m, WINDOW_FUNCTION, r);
    return r;
  }

  /* ********************************************************** */
  // <rank function type> <left paren> <right paren>
  // 	|	ROW_NUMBER <left paren> <right paren>
  // 	|	<aggregate function>
  public static boolean window_function_type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_function_type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WINDOW_FUNCTION_TYPE, "<window function type>");
    r = rank_function_type(b, l + 1);
    if (!r) r = parseTokens(b, 0, ROW_NUMBER, _LEFT_PAREN_, _RIGHT_PAREN_);
    if (!r) r = aggregate_function(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // <identifier>
  public static boolean window_name(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_name")) return false;
    if (!nextTokenIs(b, _IDENTIFIER_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = identifier(b, l + 1);
    exit_section_(b, m, WINDOW_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // <window name> | <in-line window specification>
  public static boolean window_name_or_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_name_or_specification")) return false;
    if (!nextTokenIs(b, "<window name or specification>", _IN_LINE_WINDOW_SPECIFICATION_, _WINDOW_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WINDOW_NAME_OR_SPECIFICATION, "<window name or specification>");
    r = window_name(b, l + 1);
    if (!r) r = in_line_window_specification(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ORDER BY <sort specification list>
  public static boolean window_order_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_order_clause")) return false;
    if (!nextTokenIs(b, ORDER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ORDER, BY, _SORT_SPECIFICATION_LIST_);
    exit_section_(b, m, WINDOW_ORDER_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // PARTITION BY <window partition column reference list>
  public static boolean window_partition_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_partition_clause")) return false;
    if (!nextTokenIs(b, PARTITION)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, PARTITION, BY, _WINDOW_PARTITION_COLUMN_REFERENCE_LIST_);
    exit_section_(b, m, WINDOW_PARTITION_CLAUSE, r);
    return r;
  }

  /* ********************************************************** */
  // <column reference> [ <collate clause> ]
  public static boolean window_partition_column_reference(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_partition_column_reference")) return false;
    if (!nextTokenIs(b, _COLUMN_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_reference(b, l + 1);
    r = r && window_partition_column_reference_1(b, l + 1);
    exit_section_(b, m, WINDOW_PARTITION_COLUMN_REFERENCE, r);
    return r;
  }

  // [ <collate clause> ]
  private static boolean window_partition_column_reference_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_partition_column_reference_1")) return false;
    collate_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <window partition column reference> [ { <comma> <window partition column reference> }... ]
  public static boolean window_partition_column_reference_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_partition_column_reference_list")) return false;
    if (!nextTokenIs(b, _WINDOW_PARTITION_COLUMN_REFERENCE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = window_partition_column_reference(b, l + 1);
    r = r && window_partition_column_reference_list_1(b, l + 1);
    exit_section_(b, m, WINDOW_PARTITION_COLUMN_REFERENCE_LIST, r);
    return r;
  }

  // [ { <comma> <window partition column reference> }... ]
  private static boolean window_partition_column_reference_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_partition_column_reference_list_1")) return false;
    window_partition_column_reference_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <window partition column reference>
  private static boolean window_partition_column_reference_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_partition_column_reference_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && window_partition_column_reference(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <left paren> <window specification details> <right paren>
  public static boolean window_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_specification")) return false;
    if (!nextTokenIs(b, _LEFT_PAREN_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = left_paren(b, l + 1);
    r = r && window_specification_details(b, l + 1);
    r = r && right_paren(b, l + 1);
    exit_section_(b, m, WINDOW_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // [ <existing window name> ] [ <window partition clause> ] [ <window order clause> ] [ <window frame clause> ]
  public static boolean window_specification_details(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_specification_details")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WINDOW_SPECIFICATION_DETAILS, "<window specification details>");
    r = window_specification_details_0(b, l + 1);
    r = r && window_specification_details_1(b, l + 1);
    r = r && window_specification_details_2(b, l + 1);
    r = r && window_specification_details_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <existing window name> ]
  private static boolean window_specification_details_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_specification_details_0")) return false;
    existing_window_name(b, l + 1);
    return true;
  }

  // [ <window partition clause> ]
  private static boolean window_specification_details_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_specification_details_1")) return false;
    window_partition_clause(b, l + 1);
    return true;
  }

  // [ <window order clause> ]
  private static boolean window_specification_details_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_specification_details_2")) return false;
    window_order_clause(b, l + 1);
    return true;
  }

  // [ <window frame clause> ]
  private static boolean window_specification_details_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "window_specification_details_3")) return false;
    window_frame_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // WITH [ RECURSIVE ] <with list>
  public static boolean with_clause(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_clause")) return false;
    if (!nextTokenIs(b, WITH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, WITH);
    r = r && with_clause_1(b, l + 1);
    r = r && with_list(b, l + 1);
    exit_section_(b, m, WITH_CLAUSE, r);
    return r;
  }

  // [ RECURSIVE ]
  private static boolean with_clause_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_clause_1")) return false;
    consumeToken(b, RECURSIVE);
    return true;
  }

  /* ********************************************************** */
  // <column name list>
  public static boolean with_column_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_column_list")) return false;
    if (!nextTokenIs(b, _COLUMN_NAME_LIST_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = column_name_list(b, l + 1);
    exit_section_(b, m, WITH_COLUMN_LIST, r);
    return r;
  }

  /* ********************************************************** */
  // <with list element> [ { <comma> <with list element> }... ]
  public static boolean with_list(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_list")) return false;
    if (!nextTokenIs(b, _WITH_LIST_ELEMENT_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = with_list_element(b, l + 1);
    r = r && with_list_1(b, l + 1);
    exit_section_(b, m, WITH_LIST, r);
    return r;
  }

  // [ { <comma> <with list element> }... ]
  private static boolean with_list_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_list_1")) return false;
    with_list_1_0(b, l + 1);
    return true;
  }

  // <comma> <with list element>
  private static boolean with_list_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_list_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = comma(b, l + 1);
    r = r && with_list_element(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // <query name> [ <left paren> <with column list> <right paren> ]
  // 		AS <left paren> <query expression> <right paren> [ <search or cycle clause> ]
  public static boolean with_list_element(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_list_element")) return false;
    if (!nextTokenIs(b, _QUERY_NAME_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = query_name(b, l + 1);
    r = r && with_list_element_1(b, l + 1);
    r = r && consumeTokens(b, 0, AS, _LEFT_PAREN_, _QUERY_EXPRESSION_, _RIGHT_PAREN_);
    r = r && with_list_element_6(b, l + 1);
    exit_section_(b, m, WITH_LIST_ELEMENT, r);
    return r;
  }

  // [ <left paren> <with column list> <right paren> ]
  private static boolean with_list_element_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_list_element_1")) return false;
    left_paren(b, l + 1);
    return true;
  }

  // [ <search or cycle clause> ]
  private static boolean with_list_element_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_list_element_6")) return false;
    search_or_cycle_clause(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // WITH NO DATA | WITH DATA
  public static boolean with_or_without_data(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_or_without_data")) return false;
    if (!nextTokenIs(b, WITH)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, WITH, NO, DATA);
    if (!r) r = parseTokens(b, 0, WITH, DATA);
    exit_section_(b, m, WITH_OR_WITHOUT_DATA, r);
    return r;
  }

  /* ********************************************************** */
  // WITH TIME ZONE | WITHOUT TIME ZONE
  public static boolean with_or_without_time_zone(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "with_or_without_time_zone")) return false;
    if (!nextTokenIs(b, "<with or without time zone>", WITH, WITHOUT)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, WITH_OR_WITHOUT_TIME_ZONE, "<with or without time zone>");
    r = parseTokens(b, 0, WITH, TIME, ZONE);
    if (!r) r = parseTokens(b, 0, WITHOUT, TIME, ZONE);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // WITHIN GROUP <left paren> ORDER BY <sort specification list> <right paren>
  public static boolean within_group_specification(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "within_group_specification")) return false;
    if (!nextTokenIs(b, WITHIN)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, WITHIN, GROUP, _LEFT_PAREN_, ORDER, BY, _SORT_SPECIFICATION_LIST_, _RIGHT_PAREN_);
    exit_section_(b, m, WITHIN_GROUP_SPECIFICATION, r);
    return r;
  }

  /* ********************************************************** */
  // <years value> | [ <years value> <minus sign> ] <months value>
  public static boolean year_month_literal(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "year_month_literal")) return false;
    if (!nextTokenIs(b, "<year month literal>", _MONTHS_VALUE_, _YEARS_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, YEAR_MONTH_LITERAL, "<year month literal>");
    r = years_value(b, l + 1);
    if (!r) r = year_month_literal_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [ <years value> <minus sign> ] <months value>
  private static boolean year_month_literal_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "year_month_literal_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = year_month_literal_1_0(b, l + 1);
    r = r && months_value(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [ <years value> <minus sign> ]
  private static boolean year_month_literal_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "year_month_literal_1_0")) return false;
    years_value(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // <datetime value>
  public static boolean years_value(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "years_value")) return false;
    if (!nextTokenIs(b, _DATETIME_VALUE_)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = datetime_value(b, l + 1);
    exit_section_(b, m, YEARS_VALUE, r);
    return r;
  }

}
